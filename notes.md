<link href="styles.css" rel="stylesheet" />

# Разработка мобильных приложений 2023-2024 (МДК 01.03)
66d6b6e6d048d3735272200f

- [Общее](#общее)
  - [Дополнительные материалы по курсу](#дополнительные-материалы-по-курсу)
  - [Официальные бесплатные курсы от Google](#официальные-бесплатные-курсы-от-google)
  - [Примерные теоретические вопросы к экзамену](#примерные-теоретические-вопросы-к-экзамену)
  - [Примерные практические задания на экзамен](#примерные-практические-задания-на-экзамен)
- [01 Введение](#01-введение)
  - [Коротко о GitHub](#коротко-о-github)
  - [Подключение VCS к IntelliJ IDEA](#подключение-vcs-к-intellij-idea)
  - [Хекслет](#хекслет)
- [02 Синтаксис языка. Управляющие конструкции - решение задач](#02-синтаксис-языка-управляющие-конструкции---решение-задач)
  - [Основной синтаксис](#основной-синтаксис)
    - [Определение имени пакета и импорт](#определение-имени-пакета-и-импорт)
    - [Точка входа в программу](#точка-входа-в-программу)
    - [Вывод в стандартный поток (с помощью `print()` и `println()`)](#вывод-в-стандартный-поток-с-помощью-print-и-println)
    - [Чтение данных с консоли](#чтение-данных-с-консоли)
    - [Переменные. Объявление переменных](#переменные-объявление-переменных)
  - [Основные типы](#основные-типы)
    - [Числа](#числа)
      - [Целочисленные типы](#целочисленные-типы)
      - [Типы с плавающей точкой](#типы-с-плавающей-точкой)
      - [Представление чисел в JVM](#представление-чисел-в-jvm)
      - [Символьные постоянные](#символьные-постоянные)
      - [Явные преобразования](#явные-преобразования)
      - [Арифметические операции](#арифметические-операции)
        - [Деление целых чисел](#деление-целых-чисел)
        - [Побитовые операции](#побитовые-операции)
      - [Сравнение чисел с плавающей точкой](#сравнение-чисел-с-плавающей-точкой)
      - [Целые беззнаковые числа](#целые-беззнаковые-числа)
        - [Беззнаковые массивы и диапазоны](#беззнаковые-массивы-и-диапазоны)
        - [Литералы](#литералы)
    - [Логический тип](#логический-тип)
    - [Символы](#символы)
    - [Строки](#строки)
      - [Строковые литералы](#строковые-литералы)
      - [Строковые шаблоны](#строковые-шаблоны)
    - [Массивы](#массивы)
      - [Массивы примитивных типов](#массивы-примитивных-типов)
  - [Условия и циклы](#условия-и-циклы)
    - [Условное выражение `if`](#условное-выражение-if)
    - [Условное выражение `when`](#условное-выражение-when)
    - [Цикл `for`](#цикл-for)
    - [Цикл `while`](#цикл-while)
    - [Break и continue в циклах](#break-и-continue-в-циклах)
  - [Операторы перехода](#операторы-перехода)
    - [Метки операторов break и continue](#метки-операторов-break-и-continue)
    - [Возврат к меткам](#возврат-к-меткам)
  - [Диапазоны и прогрессии](#диапазоны-и-прогрессии)
    - [Диапазоны](#диапазоны)
    - [Прогрессии](#прогрессии)

## Общее
66df5d7ed048d373527220f7

### Дополнительные материалы по курсу

- [Документация по Kotlin](https://kotlinlang.org/docs/home.html)
- [Документация по Kotlin (ru)](https://kotlinlang.ru/)
- [Материал по коллекциям](https://trello.com/b/7eWLU7kG/kotlin-collections)
- [Android for Developers](https://developer.android.com/)
- [Документация по GitHub](https://docs.github.com/en)
- [Книга Pro Git (на русском)](https://git-scm.com/book/ru/v2)
- [Различные иконки](https://www.flaticon.com/)
- [Шрифты от Google](https://fonts.google.com/)
- [Material Design](https://m3.material.io/)
- [Android разработчик](https://developer.android.com/guide/index.html)
- [Android Developer Fundamentals (Version 2)](https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/index.html)
- [On-line редактор для работы с Kotlin - официальный](https://play.kotlinlang.org/)
- [On-line редактор для работы с Kotlin - работает с интерактивом](https://www.jdoodle.com/compile-kotlin-online/)

### Официальные бесплатные курсы от Google

- [Android Basics (RUS)](https://javarush.ru/quests/QUEST_GOOGLE_ANDROID)
- [Developing Android Apps - Intermediate level (ENG)](https://www.udacity.com/course/new-android-fundamentals--ud851)
- [Android app development - Advanced level (ENG)](https://www.udacity.com/course/-advanced-android-app-development--ud855)
- [Kotlin Bootcamp for Programmers (ENG)](https://www.udacity.com/course/kotlin-bootcamp-for-programmers--ud9011)
- [Developing Android Apps with Kotlin (ENG)](https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012)
- [Kotlin for Android Developers (ENG)](https://www.udacity.com/course/kotlin-for-android-developers--ud888)
- [Advanced Android with Kotlin (ENG)](https://www.udacity.com/course/advanced-android-with-kotlin--ud940)
- [Android Performance (ENG)](https://www.udacity.com/course/android-performance--ud825)
- [Material Design for Android Developers (ENG)](https://www.udacity.com/course/material-design-for-android-developers--ud862)
- [Firebase in a Weekend: Android (ENG)](https://www.udacity.com/course/firebase-in-a-weekend-by-google-android--ud0352)
- [Build Native Mobile Apps with Flutter (ENG)](https://www.udacity.com/course/build-native-mobile-apps-with-flutter--ud905)

### Примерные теоретические вопросы к экзамену
66e01520d048d3735272210c

1. Понятие мобильной разработки. История развития.

2. Инструментарий разработчика мобильных приложений

3. Использование систем контроля версий при разработке мобильных приложений

4. История языка Kotlin. Преимущества и недостатки Kotlin.

5. Типы данных, используемые в языке Kotlin

6. Структура программы на языке Kotlin. Использование условий и циклов

7. Встроенные и пользовательские функции языка Kotlin. Нефиксированное число аргументов. Перегрузка функций.

8. Массивы и их использование в языке Kotlin.

9. Immutable Collection. Mutable Collection. List и его использование в языке Kotlin.

10. Immutable Collection. Mutable Collection. Set и его использование в языке Kotlin.

11. Immutable Collection. Mutable Collection. Map и его использование в языке Kotlin.

12. ООП в Kotlin. Создание и использование классов. Свойства и методы классов.

13. ООП в Kotlin. Использование конструкторов и интерфейсов.

14. Среда разработки Android Studio. Краткий обзор базовых UI-компонентов.

15. Среда разработки Android Studio. Файловая структура проекта. Режимы Project и Android

16. Создание экрана приложения. Использование компоновщиков.

17. Обработка нажатия кнопки. Использование события onClick и параметра viewBinding

18. ToolBar и создание меню для ToolBar

19. BottomNavigationView и создание меню.

20. Activity и ее жизненный цикл. Способы создания.

21. Переход между Activity и передача данных между Activity

22. Fragment. Создание и использование

23. Передача данных между Fragment и Activity с помощью ViewModal

24. Создание базы данных с использованием Kotlin.

25. Работа с базой данных с использованием Room

26. Списки и их использование. Работа с ListView

27. Списки и их использование. Использование RecyclerView

###  Примерные практические задания на экзамен
66e015b8d048d3735272210e

1. Расположить на экране, в центре, квадрат размером 200х200 синего цвета. Внизу экрана расположить кнопку с надписью «СТАРТ». При нажатии на кнопку цвет квадрата меняется циклично в следующем порядке: синий – красный – желтый

2. Создать приложение, состоящее из двух Activity. На каждой Activity расположить по центру соответствующие надписи: «Activity 01» и «Activity 02». Также на каждой Activity расположить ниже надписей (на 100px), кнопки. Нажатием на кнопку пользователь переходит на другую Activity.

3. Создать приложение, состоящее из кнопки и текстового поля. При запуске приложения в текстовом поле стоит число 1.  При нажатии на кнопку значение в текстовом поле меняется от 1 до 10 с шагом 1. После 10-и отсчет опять начинается с 1-ы.

4. Создать приложение, состоящее из кнопки и текстового поля. При запуске приложения в текстовом поле стоит число 0.  При последовательных нажатиях на кнопку в текстовое поле выводятся последовательно нечетные числа в диапазоне [1;10]. После 10-и отсчет опять начинается с наименьшего нечетного числа.

5. Создать приложение, состоящее из кнопки и текстового поля. При запуске приложения в текстовом поле стоит число 0.  При последовательных нажатиях на кнопку в текстовое поле выводятся последовательно четные числа в диапазоне [1;10]. После 10-и отсчет опять начинается с наименьшего четного числа.

6. Создать приложение, состоящее из Activity и двух Fragment. На Fragment расположены соответственно надписи – «Фрагмент01» и «Фрагмент02». На Activity расположить кнопку, нажатие на которую будет показывать циклично Fragment01 и Fragment02.

7. Создать приложение, состоящее из двух Activity. На каждом Activity находится кнопка для перехода на другую Activity, и текстовое поле, в которое можно ввести только цифры. Пользователь вводит в поле какое-то значение и нажимает кнопку. Осуществляется переход на другую Activity при котором в поле для ввода передается введенное значение.

8. Создать простое приложение, демонстрирующее передачу данных от Activity во Fragment.

9. Создать простое приложение, демонстрирующее передачу данных от Fragment в Activity.

10. Создать простое приложение, демонстрирующее передачу данных из одного Fragment в другой Fragment.

11. Создать приложение, в котором имеется меню в ToolBar, состоящее из пунктов – Red, Green и Yellow. В центре экрана имеется квадрат, который при выборе пункта меню меняет свой цвет на соответствующий. При запуске приложения цвет квадрата Black.

12. Создать приложение, в котором имеется меню в BottomNavigationView, состоящее из пунктов – Red, Green и Yellow. В центре экрана имеется квадрат, который при выборе пункта меню меняет свой цвет на соответствующий. При запуске приложения цвет квадрата Black.

13. Вывести на экран приложения элементы массива нечетных чисел (не менее 30-и элементов) с использованием ListView и ArrayAdapter.

14. Имеется два массива – массив четных чисел и массив числительных, соответствующих этим числам. Вывести на экран приложения элементы массива четных чисел (не менее 30-и элементов) с использованием ListView и ArrayAdapter. При нажатии на элемент списка во всплывающем сообщении появляется соответствующее ему числительное.

15. Показать приложение «Рецепты», созданное с использованием ListView, и объяснить его работу (свой Adapter, изменения в Manifest и т.д.). Приложение необходимо сделать заранее по презентации до экзамена.

16. Показать приложение «Пикачу», созданное с использованием RecyclerView, и объяснить его работу (свой Adapter, ресурсы, изменения в Manifest и т.д.). Приложение необходимо сделать заранее по презентации до экзамена.

17. Создать приложение, состоящее из кнопки в центре экрана и четырех пронумерованных квадратов, расположенных по углам Activity. Квадрат с номером 1 расположен в верхнем правом углу. Далее – по часовой стрелке. При нажатии на кнопку у квадратов последовательно меняется цвет на красный. Ранее выделенный красным квадрат меняет свой цвет на цвет по умолчанию (синий).

18. Создать приложение, состоящее из кнопки в центре экрана и четырех пронумерованных квадратов, расположенных по углам Activity. Квадрат с номером 1 расположен в верхнем правом углу. Далее – по часовой стрелке. При нажатии на кнопку случайным образом выбирается квадрат и его цвет меняется на красный. Ранее выделенный красным квадрат меняет свой цвет на цвет по умолчанию (синий).

19. Создать приложение, состоящее из двух полей ввода и текстового поля, а также кнопки «РЕЗУЛЬТАТ». Пользователь вводит целые числа в поля ввода. При нажатии на кнопку в текстовом поле получаем сумму введенных чисел. Сделать так, чтобы в поля ввода можно было вводить только числовые значения.

20. Создать приложение, с помощью которого пользователь вводит в соответствующие поля только числовые значения и при нажатии на кнопку «РЕЗУЛЬТАТ» получает частное и остаток от деления первого числа на второе.

21. Создать приложение, в котором пользователь вводит в соответствующие поля два целых числа и при нажатии на кнопку «РЕЗУЛЬТАТ» между введенными числами ставится знак «<» или «>», в зависимости от введенных значений.

22. Создать приложение, в котором пользователь вводит в соответствующее поле любое число (целое или дробное). При нажатии на кнопку «РЕЗУЛЬТАТ» в другом текстовом поле отображается округленное до ближайшего большего целое число.

23. Создать приложение, которое подсчитывает в веденном слове количество гласных букв.

24. Создать приложение, которое подсчитывает в веденном слове количество согласных букв.

25. Создать приложение, в котором пользователь вводит в соответствующее поле любое число (целое или дробное). При нажатии на кнопку «РЕЗУЛЬТАТ» в другом текстовом поле отображается округленное до ближайшего нечетного большего целое число.

26. Создать приложение, в котором пользователь вводит в соответствующее поле любое число (целое или дробное). При нажатии на кнопку «РЕЗУЛЬТАТ» в другом текстовом поле отображается округленное до ближайшего большего четного целое число.

27. Создать приложение, с помощью которого пользователь вводит в соответствующее поле числовое значение и при нажатии на кнопку «РЕЗУЛЬТАТ» получает сообщение о четности или нечетности числа.

## 01 Введение
66e0171ad048d37352722110

### Коротко о GitHub
66e1bf5ad048d37352722148

Сервис для совместной разработки и хостинга ИТ-проектов Github был основан в апреле 2008 года программистами Крисом Ванстрасом (Chris Wanstrath), Томом Престон-Вернером (Thomas Preston-Werner) и Пи Джей Хайеттом (PJ Hyett).

![](./img/github-1.webp)

Первоначально проект предполагался как сообщество по разработке с помощью открытого исходного кода, использующего систему управления версиями Git.

В 2005 году программист Линус Торвальдс создал Git в ходе работы над ядром Linux. Разработчики начали применять эту систему в своей работе. Создание Git считалось выходом «на следующий уровень» по сравнению с другим программным обеспечением для управления версиями.

![](./img/github-2.webp)

При этом, по мнению Престон-Вернера, проблема совместной работы не исчезла — Git делала её возможной, но сложной. GitHub был призван стать решением проблемы. В дальнейшем первым слоганом платформы станет «Гит-хостинг: больше не боль в заднице» (Git hosting: No longer a pain in the ass).

Идея пришла Ванстрасу и Престону-Вернеру во время митапа Ruby-разработчиков в октябре 2007 года в Сан-Франциско. Они планировали, что будущий проект должен стать местом, где разработчики могли бы легко делиться кодом и изучать программы друг друга.

В то время Ванстрас зарабатывал консалтингом, а до этого занимался техническим развитием сайта о технологиях Cnet. В свою очередь Престон-Вернер был разработчиком в компании Powerset.

В конце 2007 года они приступили к созданию собственного проекта — по субботам разработчики устраивали мозговой штурм, а в свободное время писали код будущей платформы. Престон-Вернер взял на себя разработку пользовательского интерфейса GitHub, а Ванстрас занялся разработкой самого приложения на Ruby on Rails.

«GitHub не должен был стать стартапом или компанией. GitHub был всего лишь инструментом, который был нужен нам самим», — рассказывал в интервью Wired Ванстрас.

Престон-Вернеру в работе над GitHub также пригодился опыт создания сервиса Gravatar в 2007 году, который позволял сохранять изображения для профилей в соцсетях на отдельном сервере. В том же году разработчик продал сайт компании Automattic (владеет блог-платформой WordPress).

Молодые люди потратили «несколько сотен долларов» на покупку домена у VPS-провайдера Slicehost, регистрацию компании Logical Awesome и графику для будущего сайта.

Кроме того, разработчики приобрели в фотостоке iStockphoto права на рисунок «осьмикота» (смесь кота и осьминога) художника Саймона Оуксли, создавшего первый логотип Twitter. Выдуманное животное стало маскотом GitHub.

![](./img/github-3.webp)

Должность генерального директора компании занял Ванстрас. Первое время команда GitHub работала удаленно в кофейнях и из дома, общаясь через сервис Campfire. Собственный офис в Сан-Франциско у компании появился только в 2010 году.

В начале 2008 года разработчики запустили бета-версию платформы и разослали приглашения друзьям и знакомым. Первые участники начали пользоваться GitHub, размещая на площадке свои рабочие коды. Одним из первых проектов, который присоединился к новой платформе, стал фреймворк Ruby on Rails.

В феврале 2008 к команде основателей проекта присоединился Пи Джей Хайетт. С ним в 2007 году Ванстрас познакомился в Cnet, а затем молодые люди пытались запустить аналог Google+ под названием Famspam. Однако их стартап не стал успешным.

Публичный запуск GitHub состоялся 10 апреля 2008 года. К этому моменту проект содержал 20 тысяч репозиториев, а количество пользователей составило более двух тысяч.

«Мы действительно гордимся этим сайтом, и у нас есть так много идей на будущее. Это только начало», — написал в блоге проекта Ванстрас.

Разработчики заложили в GitHub такие возможности, как дублирование или форкинг (Forking), запросы на включение в проект изменений (Pull Requests) и слияние (Merging).

В GitHub можно скопировать любой опубликованный репозиторий в свой профиль, чтобы модифицировать его. Затем разработчик может поделиться изменениями с владельцем репозитория посредством запроса на включение. Если владельцу нравятся изменения, то он может слить их с первоначальным репозиторием.

Таким образом подход GitHub позволил любому зарегистрированному пользователю делиться, улучшать или развивать открытые проекты.

Также GitHub предоставил такие функции совместной работы, как отслеживание ошибок, запрос функций, управление задачами и вики-страницами для каждого проекта.

3 июня 2018 года Bloomberg сообщило, что Microsoft заключила соглашение о покупке GitHub. По словам одного из источников агентства, владельцы GitHub решили не выводить компанию на биржу, а продать её, так как их впечатлил глава корпорации Сатья Наделла.

На следующий день Microsoft и GitHub подтвердили сделку. Её стоимость составила $7,5 млрд.

### Подключение VCS к IntelliJ IDEA
[66e1c090d048d3735272214a](https://rutube.ru/video/private/b9a41fbd9e87579966bb398b1c1e3baf/?p=hQYXvP2kkS5ONZM9CaDxHQ)

1. Go *GitHub.com* and generate a new classical token with the following settings:

   - [x] repo
     - [x] repo:status
     - [x] repo_deployment
     - [x] public_repo
     - [x] repo:invite
     - [x] security_events
   - [ ] admin:org
     - [ ] write:org
     - [x] read:org
     - [ ] manage_runners:org
   - [x] gist

2. Copy and saved a newly generated token.
2. IntelliJ IDEA: *File* > *Settings* > *Version Control* > *GitHub*. Press "+" and choose to "Log in with Token...".
3. Add GitHub Account with the following settings:
   - Server: *github.com*
   - Token: *your generated GitHub token*
4. Replace .gitignore contents with the [following](https://github.com/JetBrains/kotlin/blob/master/.gitignore):

    <details>
    <summary><b><i>.gitignore</i></b></summary>

    ```
    .DS_Store
    .idea/shelf
    /confluence/target
    /dependencies/repo
    /android.tests.dependencies
    /dependencies/android.tests.dependencies
    /dist
    /local
    /gh-pages
    /ideaSDK
    /clionSDK
    /android-studio/sdk
    out/
    /tmp
    /intellij
    workspace.xml
    *.versionsBackup
    /idea/testData/debugger/tinyApp/classes*
    /jps-plugin/testData/kannotator
    /js/js.translator/testData/out/
    /js/js.translator/testData/out-min/
    /js/js.translator/testData/out-pir/
    .gradle/
    build/
    !**/src/**/build
    !**/test/**/build
    *.iml
    !**/testData/**/*.iml
    .idea/artifacts
    .idea/remote-targets.xml
    .idea/libraries/Gradle*.xml
    .idea/libraries/Maven*.xml
    .idea/modules
    .idea/runConfigurations/JPS_*.xml
    .idea/runConfigurations/_JPS_*.xml
    .idea/runConfigurations/PILL_*.xml
    .idea/runConfigurations/_FP_*.xml
    .idea/runConfigurations/_MT_*.xml
    .idea/libraries
    .idea/modules.xml
    .idea/gradle.xml
    .idea/compiler.xml
    .idea/inspectionProfiles/profiles_settings.xml
    .idea/.name
    .idea/jarRepositories.xml
    .idea/csv-plugin.xml
    .idea/libraries-with-intellij-classes.xml
    .idea/misc.xml
    .idea/protoeditor.xml
    .idea/uiDesigner.xml
    node_modules/
    .rpt2_cache/
    local.properties
    buildSrcTmp/
    distTmp/
    outTmp/
    /test.output
    /kotlin-native/dist
    kotlin-ide/
    .kotlin/
    .teamcity/
    ```

    </details>

5. Create new repository and branch from main.
6. Do your work, commit and push to GitHub.
7. Create pull request at GitHub.
8. Attach GitHub pull request url at the colledge system.
9. Merge branch to main after approval.

### Хекслет
[66ec3c46d048d37352722213](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345139)

Зарегистрироваться при необходимости на сайте Хекслет

Пройти курс [Введение в Git](https://ru.hexlet.io/courses/intro_to_git)

В качестве отчета приложить архив скриншота экрана главной страницы курса с открытым меню для профиля (см. пример). Преподаватель может попросить войти на указанный ресурс с компьютера колледжа для проверки достоверности указанных сведений.

## 02 Синтаксис языка. Управляющие конструкции - решение задач
66ec3cb8d048d37352722215

### Основной синтаксис
[66ed9ed65040133e8429e165](https://e-learn.petrocollege.ru/mod/url/view.php?id=345141) https://kotlinlang.ru/docs/basic-syntax.html

#### Определение имени пакета и импорт
Имя пакета указывается в начале исходного файла, так же как и в Java.
```kotlin
package my.demo

import java.util.*

// ...
```

Но в отличие от Java, нет необходимости, чтобы структура пакетов совпадала со структурой папок: исходные файлы могут располагаться в произвольном месте на диске.

См. [Пакеты](https://kotlinlang.ru/docs/packages.html).

#### Точка входа в программу
В Kotlin точкой входа в программу является функция `main`.
```kotlin
fun main() {
    println("Hello world!")
}
```

Другая форма `main` может принимать массив строк `String`.
```kotlin
fun main(args: Array<String>) {
    println(args.contentToString())
}
```

#### Вывод в стандартный поток (с помощью `print()` и `println()`)
`print` выводит свой аргумент в стандартный поток вывода.
```kotlin
print("Hello ")
print("world!")
```

`println` выводит свой аргумент и добавляет перевод строки, так что следующее, что вы выведите, появится на следующей строке.
```kotlin
println("Hello world!")
println(42)
```

!!! example [Example](samples\02_Syntax\02_Output\src\Main.kt)
```kotlin
fun main() {
    val testF = "1234567"
    for (i in 0..testF.length - 1) {
        println(testF[i])
    }
    println("====================")
    for (i in 0..testF.length - 1) {
        print(testF[i])
    }
}

```

<details>
<summary>Output</summary>

```
1
2
3
4
5
6
7
====================
1234567

Process finished with exit code 0
```

</details>


!!! example [Example](samples\02_Syntax\03_Output\src\Main.kt)
```kotlin
fun main() {
    print("Введите трехзначное число: ")
    val testF = readln()
    println("==============")
    println("Простой вывод значения переменной")
    println(testF)
    println("Вывод переменной как части строки")
    println("Мы ввели число - $testF")
    println("Некорректное обращение к части строки")
    println("Первый символ введенного числа - $testF[0]")
    println("Обратите внимание на фигурные скобки")
    println("Первый символ введенного числа - ${testF[0]}")
}

```

<details>
<summary>Output</summary>

```
Введите трехзначное число: 987
==============
Простой вывод значения переменной
987
Вывод переменной как части строки
Мы ввели число - 987
Некорректное обращение к части строки
Первый символ введенного числа - 987[0]
Обратите внимание на фигурные скобки
Первый символ введенного числа - 9

Process finished with exit code 0
```

</details>

#### Чтение данных с консоли

!!! example [Example](samples\02_Syntax\04_ConsoleInput\src\Main.kt)
```kotlin
fun main() {
    print("Введите строку символов: ")
    val testF = readln()
    println()

    for (i in 0..testF.length - 1) {
        print(testF[i])
    }
}
```

<details>
<summary>Output</summary>

```
Введите строку символов: Это строка символов

Это строка символов
Process finished with exit code 0

```

</details>

!!! example [Example](samples\02_Syntax\05_ConsoleIO\src\Main.kt)
```kotlin
fun main() {
    print("Введите строку символов: ")
    val testF = readln()
    println()

    for (i in testF) {
        print(i)
    }
}

```

<details>
<summary>Output</summary>

```
Введите строку символов: Чтение символов из строки

Чтение символов из строки
Process finished with exit code 0

```

</details>

#### Переменные. Объявление переменных
Неизменяемые (только для чтения) локальные переменные определяются с помощью ключевого слова `val`. Присвоить им значение можно только один раз.
```kotlin
val a: Int = 1   // Инициализация при объявлении
val b = 1        // Тип `Int` определен автоматически
val c: Int       // Указывать тип обязательно, если переменная не инициализирована сразу
c = 1            // Последующее присвоение
```

Изменяемые переменные объявляются с помощью ключевого слова `var`.
```kotlin
var x = 5 // Тип `Int` определен автоматически
x += 1
```

Вы можете объявлять глобальные переменные.
```kotlin
val PI = 3.14
var x = 0

fun incrementX() { 
    x += 1 
}
```

!!! example [Example](samples\02_Syntax\01_VariableDeclaration\src\Main.kt)
```kotlin
fun main() {
    // Неизменяемые (только для чтения)
    // локальные переменные определяются
    // с помощью ключевого слова val.
    // Присвоить им значение можно только один раз.
    val testC = 7
    println(testC) // => 7

    // testC = 9 // => Kotlin: Val cannot be reassigned

    // Изменяемые переменные объявляются
    // с помощью ключевого слова var.
    var testD = "строка символов"
    println(testD) // => строка символов

    testD = "новая строка символов"
    println(testD) // => новая строка символов
}
```

<details>
<summary>Output</summary>

```
7
строка символов
новая строка символов

Process finished with exit code 0
```

</details>

!!! error Error
```kotlin
testC = 9 // => Kotlin: Val cannot be reassigned
```

<details>
<summary>Output</summary>

```
Kotlin: Val cannot be reassigned

Process finished with exit code 0
```

</details>

### Основные типы
https://kotlinlang.ru/docs/basic-types.html

В Kotlin всё является объектом, в том смысле, что пользователь может вызвать функцию или получить доступ к свойству любой переменной. Некоторые типы являются встроенными, т.к. их реализация оптимизирована, хотя для пользователя они выглядят как обычные классы. В данном разделе описываются основные типы: числа, логические переменные, символы, строки и массивы.

#### Числа

##### Целочисленные типы
В Kotlin есть набор встроенных типов, которые представляют числа. Для целых чисел существует четыре типа с разными размерами и, следовательно, разными диапазонами значений.

| Тип |	Размер (биты) |	Минимальное значение |	Максимальное значение |
| --- | :--: | --: | -----------: |
| `Byte` |	8 |	-128 |	127 |
| `Short` |	16 |	-32768 |	32767 |
| `Int` |	32 |	-2,147,483,648 (-2^31^) |	2,147,483,647 (2^31^ - 1) |
| `Long` |	64 |	-9,223,372,036,854,775,808 (-2^63^) |	9,223,372,036,854,775,807 (2^63^ - 1) |

Все переменные, инициализированные целыми значениями, не превышающими максимальное значение `Int`, имеют предполагаемый тип `Int`. Если начальное значение превышает это значение, то тип `Long`. Чтобы явно указать тип `Long`, добавьте после значения `L`.
```kotlin
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1
```

!!! example [Example](samples\02_Syntax\06_IntegerTypes\src\Main.kt)
```kotlin
fun main() {
    var testByte: Byte = 120
    var testShort: Short = 32000
    var testInt: Int = 957_235_455
    var testLong: Long = 873_554_554_545_525
    var testLongTwo: Long = 934_347_523_555L
}

```

##### Типы с плавающей точкой
Для действительных чисел в Kotlin есть типы с плавающей точкой `Float` и `Double`. Согласно стандарту IEEE 754, типы с плавающей точкой различаются своим десятичным разрядом, то есть количеством десятичных цифр, которые они могут хранить. С точки зрения IEEE 754 `Float` является одинарно точным, а `Double` обеспечивает двойную точность.

| Тип    | Размер (биты) | Значимые биты | Биты экспоненты | Разряды |
| ------ | :-----------: | :-----------: | :-------------: | :-----: |
| `Float`  | 32            | 24            | 8               | 6-7     |
| `Double` | 64            | 53            | 11              | 15-16   |

Вы можете инициализировать переменные `Double` и `Float` числами, имеющими дробную часть. Она должна быть отделена от целой части точкой (`.`). Для переменных, инициализированных дробными числами, компилятор автоматически определяет тип `Double`.
```kotlin
val pi = 3.14 // Double
// val one: Double = 1 // Ошибка: несоответствие типов
val oneDouble = 1.0 // Double
```

Чтобы явно указать тип `Float`, добавьте после значения `f` или `F`. Если такое значение содержит более 6-7 разрядов, оно будет округлено.
```kotlin
val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float, фактическое значение 2.7182817
```

Обратите внимание, что в отличие от некоторых других языков, в Kotlin нет неявных преобразований для чисел. Например, функция с `Double` параметром может вызываться только для `Double`, но не для `Float`, `Int` или других числовых значений.
```kotlin
fun main() {
    fun printDouble(d: Double) { print(d) }

    val i = 1    
    val d = 1.0
    val f = 1.0f 

    printDouble(d)
//  printDouble(i) // Ошибка: несоответствие типов
//  printDouble(f) // Ошибка: несоответствие типов
}
```

Чтобы преобразовать числовые значения в различные типы, используйте [Явные преобразования](#явные-преобразования).


!!! example [Example](samples\02_Syntax\07_Floats\src\Main.kt)
```kotlin
fun main() {
    var testDouble: Double = 120.0
    // val one: Double = 1 // Ошибка: несоответствие типов
    // var testDoubleTwo: Double = 120 // => Kotlin: Initializer type mismatch: expected 'kotlin/Double', actual 'kotlin/Int'
    printDouble(testDouble) // => 120.0

    var testFloat: Float = 32000F
    // var testFloatTwo: Float = 32000.7 // => Kotlin: Initializer type mismatch: expected 'kotlin/Float', actual 'kotlin/Double'
    printDouble(testFloat) // => 32000.0

    val i = 1
    // printDouble(i) // Ошибка: несоответствие типов
}

fun printDouble(testPar: Float) {
    println(testPar)
}

fun printDouble(testPar: Double) {
    println(testPar)
}
```

<details>
<summary>Output</summary>

```
120.0
32000.0

Process finished with exit code 0

```

</details>

##### Представление чисел в JVM
Обычно платформа JVM хранит числа в виде примитивных типов: `int`, `double` и так далее. Если же вам необходима ссылка, которая может принимать значение `null` (например, `Int?`), то используйте обёртки. В этих случаях числа помещаются в Java классы как `Integer`, `Double` и так далее.

Обратите внимание, что использование обёрток для одного и того же числа не гарантирует равенства ссылок на них.
```kotlin
val a: Int = 100
val boxedA: Int? = a
val anotherBoxedA: Int? = a

val b: Int = 10000
val boxedB: Int? = b
val anotherBoxedB: Int? = b

println(boxedA === anotherBoxedA) // true
println(boxedB === anotherBoxedB) // false
```

Все nullable-ссылки на `a` на самом деле являются одним и тем же объектом из-за оптимизации памяти, которую JVM применяет к `Integer` между “-128” и “127”. Но `b` больше этих значений, поэтому ссылки на `b` являются разными объектами.

Однако, равенство по значению сохраняется.
```kotlin
val b: Int = 10000
println(b == b) // Prints 'true'
val boxedB: Int? = b
val anotherBoxedB: Int? = b
println(boxedB == anotherBoxedB) // Prints 'true'
```

##### Символьные постоянные
В языке Kotlin присутствуют следующие виды символьных постоянных (констант) для целых значений:

- Десятичные числа: `123`
  - Тип `Long` обозначается заглавной `L`: `123L`
- Шестнадцатеричные числа: `0x0F`
- Двоичные числа: `0b00001011`

> ВНИМАНИЕ: Восьмеричные литералы не поддерживаются.

Также Kotlin поддерживает числа с плавающей запятой:

- Тип `Double` по умолчанию: `123.5`, `123.5e10`
- Тип `Float` обозначается с помощью `f` или `F`: `123.5f`

Вы можете использовать нижние подчеркивания, чтобы сделать числовые константы более читаемыми:
```kotlin
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

!!! error [Error](samples\02_Syntax\08_NumericLiterals\src\Main.kt)
```kotlin
fun main() {
    var testInt = 123
    var testLong = 120L

    var testHex = 0x0F
    var testBinary = 0b00001011
    printDouble(testBinary) // => // Ошибка: несоответствие типов

    var testDoublePoint = 123.5
    var testDoubleE = 123.5e12

    var testFloat_f = 481.78f
    var testFloat_F = 346.49F

    val oneMillion = 1_000_000
    val creditCardNumber = 1234_5678_9012_3456L
    val socialSecurityNumber = 999_99_9999L
    val hexBytes = 0xFF_EC_DE_5E
    val bytes = 0b11010010_01101001_10010100_10010010
}

fun printDouble(testPar: Double) {
    println(testPar)
}
```

<details>
<summary>Output</summary>

```
Kotlin: Argument type mismatch: actual type is 'kotlin/Int' but 'kotlin/Double' was expected

```

</details>

##### Явные преобразования
Из-за разницы в представлениях меньшие типы не являются подтипами бОльших типов. В противном случае возникли бы сложности.
```kotlin
// Возможный код, который на самом деле не скомпилируется:
val a: Int? = 1 // "Обёрнутый" Int (java.lang.Integer)
val b: Long? = a // неявное преобразование возвращает "обёрнутый" Long (java.lang.Long)
print(b == a) // Внимание! Данное выражение выведет "false" т. к. метод equals() типа Long предполагает, что вторая часть выражения также имеет тип Long
```

Таким образом, будет утрачена не только тождественность (равенство по ссылке), но и равенство по значению.

Как следствие, неявное преобразование меньших типов в большие НЕ происходит. Это значит, что мы не можем присвоить значение типа `Byte` переменной типа `Int` без явного преобразования.
```kotlin
val b: Byte = 1 // всё хорошо, литералы проверяются статически
// val i: Int = b // ОШИБКА
val i1: Int = b.toInt()
```

Каждый численный тип поддерживает следующие преобразования:

- `toByte(): Byte`
- `toShort(): Short`
- `toInt(): Int`
- `toLong(): Long`
- `toFloat(): Float`
- `toDouble(): Double`
- `toChar(): Char`

Часто необходимости в явных преобразованиях нет, поскольку тип выводится из контекста, а арифметические действия перегружаются для подходящих преобразований.
```kotlin
val l = 1L + 3 // Long + Int => Long
```

!!! example [Example](samples\02_Syntax\09_ExplicitConversions\src\Main.kt)
```kotlin
fun main() {
    val testA = 1
    val testB: Byte = 1
    // println(testA == testB) // => Kotlin: Operator '==' cannot be applied to 'kotlin/Int' and 'kotlin/Byte'
    // val testD: Int = testB // => Kotlin: Initializer type mismatch: expected 'kotlin/Int', actual 'kotlin/Byte'

    val testH = testB.toInt()

    println(5 / 2)      // => 2
    println(5 / 2.0)    // => 2.5
    println(6.0 / 2.0)  // => 3.0

    val l = 1L + 3      // Long + Int => Long
    println(l)          // => 4
}
```

<details>
<summary>Output</summary>

```
2
2.5
3.0
4

Process finished with exit code 0

```

</details>

!!! error Error
```kotlin
fun main() {
    val testA = 1
    val testB: Byte = 1
    println(testA == testB)
}
```

<details>
<summary>Output</summary>

```
Kotlin: Operator '==' cannot be applied to 'kotlin/Int' and 'kotlin/Byte'

```

</details>

!!! error Error
```kotlin
fun main() {
    val testA = 1
    val testB: Byte = 1
    val testD: Int = testB // => Kotlin: Initializer type mismatch: expected 'kotlin/Int', actual 'kotlin/Byte'
}

```

<details>
<summary>Output</summary>

```
Kotlin: Initializer type mismatch: expected 'kotlin/Int', actual 'kotlin/Byte'

```

</details>

##### Арифметические операции
Котлин поддерживает стандартный набор арифметических операций над числами: `+`, `-`, `*`, `/`, `%`. Они объявляются членами соответствующих классов.
```kotlin
println(1 + 2)
println(2_500_000_000L - 1L)
println(3.14 * 2.71)
println(10.0 / 3)
```

Вы также можете переопределить эти операторы для пользовательских классов. См. [Перегрузка операторов](https://kotlinlang.ru/docs/operator-overloading.html) для деталей.

!!! example [Example](samples\02_Syntax\10_ArithmeticOperations\src\Main.kt)
```kotlin
fun main() {
    println(78 + 96)
    println(158 - 9)
    println(3.14 * 51)
    println(854 / 32)
    println(9 % 4)

    for (i in 2..9) {
        print("$i ")
    }
    println()
    println(2 in -3..9)
    println(-12 !in -3..9)
}
```

<details>
<summary>Output</summary>

```
174
149
160.14000000000001
26
1
2 3 4 5 6 7 8 9 
true
true

Process finished with exit code 0
```

</details>

###### Деление целых чисел
Деление целых чисел всегда возвращает целое число. Любая дробная часть отбрасывается.
```kotlin
val x = 5 / 2
// println(x == 2.5) // ОШИБКА: Оператор '==' не может быть применен к 'Int' и 'Double'
println(x == 2) // true
```

Это справедливо для деления любых двух целочисленных типов.
```kotlin
val x = 5L / 2
println(x == 2L) // true
```

Чтобы вернуть тип с плавающей точкой, явно преобразуйте один из аргументов в тип с плавающей точкой.
```kotlin
val x = 5 / 2.toDouble()
println(x == 2.5) // true
```

###### Побитовые операции
Kotlin поддерживает обычный набор *побитовых операций* над целыми числами. Они работают на двоичном уровне непосредственно с битовыми представлениями чисел. Побитовые операции представлены функциями, которые могут быть вызваны в инфиксной форме. Они могут быть применены только к `Int` и `Long`.
```kotlin
val x = (1 shl 2) and 0x000FF000
```

Ниже приведён полный список битовых операций:

- `shl(bits)` – сдвиг влево с учётом знака (`<<` в Java)
- `shr(bits)` – сдвиг вправо с учётом знака (`>>` в Java)
- `ushr(bits)` – сдвиг вправо без учёта знака (`>>>` в Java)
- `and(bits)` – побитовое И
- `or(bits)` – побитовое ИЛИ
- `xor(bits)` – побитовое исключающее ИЛИ
- `inv()` – побитовое отрицание

##### Сравнение чисел с плавающей точкой
В этом разделе обсуждаются следующие операции над числами с плавающей запятой:

- Проверки на равенство: `a == b` и `a != b`
- Операторы сравнения: `a < b`, `a > b`, `a <= b`, `a >= b`
- Создание диапазона и проверка диапазона: `a..b`, `x in a..b`, `x !in a..b`

Когда статически известно, что операнды `a` и `b` являются `Float` или `Double` или их аналогами с nullable-значением (тип объявлен или является результатом [умного приведения](https://kotlinlang.ru/docs/typecasts.html#smart-casts)), операции с числами и диапазоном, который они образуют, соответствуют стандарту [IEEE 754 для арифметики с плавающей точкой](https://en.wikipedia.org/wiki/IEEE_754).

Однако для поддержки общих вариантов использования и обеспечения полного упорядочивания, когда операнды статически *не* объявлены как числа с плавающей запятой (например, `Any`, `Comparable<...>`, параметр типа), операции используют реализации `equals` и `compareTo` для `Float` и `Double`, которые не согласуются со стандартом, так что:

- `NaN` считается равным самому себе
- `NaN` считается больше, чем любой другой элемент, включая “POSITIVE_INFINITY”
- `-0.0` считается меньше, чем `0.0`

##### Целые беззнаковые числа
В дополнение к [целочисленным типам](#целочисленные-типы), в Kotlin есть следующие типы целых беззнаковых чисел:

- `UByte`: беззнаковое 8-битное целое число, в диапазоне от 0 до 255
- `UShort`: беззнаковое 16-битное целое число, в диапазоне от 0 до 65535
- `UInt`: беззнаковое 32-битное целое число, в диапазоне от 0 до 2^32^ - 1
- `ULong`: беззнаковое 64-битное целое число, в диапазоне от 0 до 2^64^ - 1

Беззнаковые типы поддерживают большинство операций своих знаковых аналогов.

> Изменение типа с беззнакового типа на его знаковый аналог (и наоборот) является *двоично несовместимым* изменением.

###### Беззнаковые массивы и диапазоны
> Беззнаковые массивы и операции над ними находятся в стадии бета-тестирования. Они могут быть несовместимо изменены в любое время.

Как и в случае с примитивами, каждому типу без знака соответствует тип массивов знаковых типов:

- `UByteArray`: массив беззнаковых `byte`
- `UShortArray`: массив беззнаковых `short`
- `UIntArray`: массив беззнаковых `int`
- `ULongArray`: массив беззнаковых `long`

Как и целочисленные массивы со знаком, такие массивы предоставляют API, аналогичный классу `Array`, без дополнительных затрат на оборачивание.

При использовании массивов без знака вы получите предупреждение, что эта функция еще не стабильна. Чтобы удалить предупреждение используйте аннотацию `@ExperimentalUnsignedTypes`. Вам решать, должны ли ваши пользователи явно соглашаться на использование вашего API, но имейте в виду, что беззнаковый массив не является стабильной функцией, поэтому API, который он использует, может быть нарушен изменениями в языке.

[Диапазоны и прогрессии](https://kotlinlang.ru/docs/ranges.html) поддерживаются для `UInt` и `ULong` классами `UIntRange,UIntProgression`, `ULongRange` и `ULongProgression`. Вместе с целочисленными беззнаковыми типами эти классы стабильны.

###### Литералы
Чтобы целые беззнаковые числа было легче использовать, в Kotlin можно помечать целочисленный литерал суффиксом, указывающим на определенный беззнаковый тип (аналогично `Float` или `Long`):

- `u` и `U` помечают беззнаковые литералы. Точный тип определяется на основе ожидаемого типа. Если ожидаемый тип не указан, компилятор будет использовать `UInt` или `ULong` в зависимости от размера литерала.

  ```kotlin
  val b: UByte = 1u  // UByte, есть ожидаемый тип
  val s: UShort = 1u // UShort, есть ожидаемый тип
  val l: ULong = 1u  // ULong, есть ожидаемый тип

  val a1 = 42u // UInt: ожидаемого типа нет, константе подходит тип UInt
  val a2 = 0xFFFF_FFFF_FFFFu // ULong: ожидаемого типа нет, тип UInt не подходит константе
  ```

- `uL` и `UL` явно помечают литерал как `unsigned long`.

  ```kotlin
  val a = 1UL // ULong, даже несмотря на то, что ожидаемого типа нет и константа вписывается в UInt
  ```

#### Логический тип
Тип `Boolean` представляет логический тип данных и принимает два значения: `true` и `false`.

При необходимости использования nullable-ссылок логические переменные оборачиваются `Boolean?`.

Встроенные действия над логическими переменными включают:

- `||` – ленивое логическое ИЛИ
- `&&` – ленивое логическое И
- `!` – отрицание

```kotlin
val myTrue: Boolean = true
val myFalse: Boolean = false
val boolNull: Boolean? = null

println(myTrue || myFalse)
println(myTrue && myFalse)
println(!myTrue)
```

> В JVM: nullable-ссылки на логические объекты заключены в рамки аналогично числам.

!!! example Example
```kotlin
fun main() {
    val testTrue = true
    val testFalse = false
    val testNull: Boolean? = null

    println(testTrue && testFalse)
    println(testTrue || testFalse)
    println(!testTrue || testFalse)
    println(!testTrue || !testFalse)

    println(2 > 5 && 9 > 0)
}
```

<details>
<summary>Output</summary>

```
false
true
false
true
false

Process finished with exit code 0
```

</details>

#### Символы
Символы в Kotlin представлены типом `Char`. Символьные литералы заключаются в одинарные кавычки: `'1'`.

Специальные символы начинаются с обратного слеша `\.` Поддерживаются следующие escape-последовательности: `\t`, `\b`, `\n`, `\r`, `\'`, `\"`, `\\` и `\$`.

Для кодирования любого другого символа используйте синтаксис escape-последовательности Юникода: `'\uFF00'`.
```kotlin
val aChar: Char = 'a'

println(aChar)
println('\n') // выводит дополнительный символ новой строки
println('\uFF00')
```

Если значение символьной переменной – цифра, её можно явно преобразовать в `Int` с помощью функции `digitToInt()`.

> В JVM: Подобно числам, символы оборачиваются при необходимости использования nullable-ссылки. При использовании обёрток тождественность (равенство по ссылке) не сохраняется.

!!! example Example
```kotlin
fun main() {
    val testChar = 'N'
    println(testChar)
    println("Новая строка\n")
    println("Еще одна новая строка")
    println()
    println("1\t2\t3\t4\t5")
    println('9'.digitToInt())
    // println("9".digitToInt()) // => Kotlin: Overload resolution ambiguity between candidates:
    println('\uFF00') // => ＀
}
```

<details>
<summary>Output</summary>

```
N
Новая строка

Еще одна новая строка

1	2	3	4	5
9
＀

Process finished with exit code 0
```

</details>

!!! error Error
```kotlin
println("9".digitToInt())
```

<details>
<summary>Output</summary>

```
Kotlin: Overload resolution ambiguity between candidates: [@InlineOnly() fun println(message: Any?): Unit, @InlineOnly() fun println(message: Boolean): Unit, @InlineOnly() fun println(message: Byte): Unit, ...]
```

</details>

#### Строки
Строки в Kotlin представлены типом `String`. Как правило, строка представляет собой последовательность символов в двойных кавычках (`"`).
```kotlin
val str = "abcd 123"
```

Строки состоят из символов, которые могут быть получены по порядковому номеру: `s[i]`. Проход по строке выполняется циклом `for`.
```kotlin
for (c in str) {
    println(c)
}
```

Строки являются неизменяемыми. После инициализации строки вы не можете изменить ее значение или присвоить ей новое. Все операции, преобразующие строки, возвращают новый объект `String`, оставляя исходную строку неизменной.
```kotlin
val str = "abcd"
println(str.uppercase()) // Создается и выводится новый объект String
println(str) // исходная строка остается прежней
```

Для объединения строк используется оператор `+`. Это работает и для объединения строк с другими типами, если первый элемент в выражении является строкой.
```kotlin
val s = "abc" + 1
println(s + "def") // abc1def
```

Обратите внимание, что в большинстве случаев использование [строковых шаблонов](#строковые-шаблоны) или обычных строк предпочтительнее объединения строк.

!!! example [Example](samples\02_Syntax\12_Symbols\src\Main.kt)
```kotlin
fun main() {
    var testString = "Строка символов"
    println(testString.uppercase())
    println(testString)
    testString = testString.uppercase()
    val newTestString = testString.uppercase()
    println(newTestString)
    testString = "Измененное значение переменной"
    println(testString + "!!!")
    println("${testString.substring(5, 9)}")
}
```

<details>
<summary>Output</summary>

```
СТРОКА СИМВОЛОВ
Строка символов
СТРОКА СИМВОЛОВ
Измененное значение переменной!!!
енно

Process finished with exit code 0

```

</details>

##### Строковые литералы
В Kotlin представлены два типа строковых литералов:

- *экранированные* строки с экранированными символами
- *обычные* строки, которые могут содержать символы новой строки и произвольный текст

Вот пример экранированной строки:
```kotlin
val s = "Hello, world!\n"
```

Экранирование выполняется общепринятым способом, а именно с помощью обратного слеша (`\`). Список поддерживаемых escape-последовательностей см. в разделе [Символы](#символы) выше.

Обычная строка выделена тройной кавычкой (`"""`), не содержит экранированных символов, но может содержать символы новой строки и любые другие символы:
```kotlin
val text = """
  for (c in "foo")
    print(c)
"""
```

Чтобы удалить пробелы в начале обычных строк, используйте функцию [`trimMargin()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-margin.html).
```kotlin
val text = """
    |Tell me and I forget.
    |Teach me and I remember.
    |Involve me and I learn.
    |(Benjamin Franklin)
    """.trimMargin()
```

По умолчанию `|` используется в качестве префикса поля, но вы можете выбрать другой символ и передать его в качестве параметра, например, `trimMargin(">")`.

!!! example Example
```kotlin
fun main() {
    val s = "Hello, world!\n"
    println("Regular escaped string: " + s)

    var text = """
        for (c in "foo"){
            print(c)
        }"""

    println(text + "\n")
    println(text.trimIndent() + "\n")

    text = """
    |Tell me and I forget.
    |Teach me and I remember.
    |Involve me and I learn.
    |(Benjamin Franklin)
    """.trimMargin()
    println(text)
}

```

<details>
<summary>Output</summary>

```
Regular escaped string: Hello, world!


        for (c in "foo"){
            print(c)
        }

for (c in "foo"){
    print(c)
}

Tell me and I forget.
Teach me and I remember.
Involve me and I learn.
(Benjamin Franklin)

Process finished with exit code 0

```

</details>

##### Строковые шаблоны
Строки могут содержать *шаблонные* выражения, т.е. участки кода, которые выполняются, а полученный результат встраивается в строку. Шаблон начинается со знака доллара (`$`) и состоит либо из простого имени (например, переменной),
```kotlin
val i = 10
println("i = $i") // выведет "i = 10"
```

либо из произвольного выражения в фигурных скобках.
```kotlin
val s = "abc"
println("$s.length is ${s.length}") // выведет "abc.length is 3"
```

Шаблоны поддерживаются как в обычных, так и в экранированных строках. При необходимости вставить символ `$` в обычную строку (такие строки не поддерживают экранирование обратным слешом) перед любым символом, который разрешен в качестве начала идентификатора, используйте следующий синтаксис:
```kotlin
val price = """
${'$'}_9.99
"""
```

#### Массивы
Массивы в Kotlin представлены классом `Array`, обладающим функциями `get` и `set` (которые обозначаются `[]` согласно соглашению о перегрузке операторов), и свойством `size`, а также несколькими полезными встроенными функциями.
```kotlin
class Array<T> private constructor() {
    val size: Int
    operator fun get(index: Int): T
    operator fun set(index: Int, value: T): Unit

    operator fun iterator(): Iterator<T>
    // ...
}
```

Для создания массива используйте функцию `arrayOf()`, которой в качестве аргумента передаются элементы массива, т.е. выполнение `arrayOf(1, 2, 3)` создаёт массив `[1, 2, 3]`. С другой стороны функция `arrayOfNulls()` может быть использована для создания массива заданного размера, заполненного значениями `null`.

Также для создания массива можно использовать фабричную функцию, которая принимает размер массива и функцию, возвращающую начальное значение каждого элемента по его индексу.
```kotlin
// создаёт массив типа Array<String> со значениями ["0", "1", "4", "9", "16"]
val asc = Array(5) { i -> (i * i).toString() }
asc.forEach { println(it) }
```

Как отмечено выше, оператор `[]` используется вместо вызовов встроенных функций `get()` и `set()`.

Обратите внимание: в отличие от Java массивы в Kotlin являются *инвариантными*. Это значит, что Kotlin запрещает нам присваивать массив `Array<String>` переменной типа `Array<Any>`, предотвращая таким образом возможный отказ во время исполнения (хотя вы можете использовать `Array<out Any>`, см. [Проекции типов](https://kotlinlang.ru/docs/generics.html#type-projections)).

!!! example Example
```kotlin
fun main() {
    var testArray = arrayOf("1", 2, true)
    testArray.forEach { print(it.toString() + "\t") }
    println("\n")
    val testArrayNum = Array(5) { i -> (i * i).toString() }
    testArrayNum.forEach { println(it) }
    println(testArrayNum.get(3))
    testArrayNum.set(0, "99")
    testArrayNum.forEach { print(it + "\t") }
}
```

<details>
<summary>Output</summary>

```
1	2	true	

0
1
4
9
16
9
99	1	4	9	16	
Process finished with exit code 0

```

</details>

##### Массивы примитивных типов
Также в Kotlin есть особые классы для представления массивов примитивных типов без дополнительных затрат на оборачивание: `ByteArray`, `ShortArray`, `IntArray` и т.д. Данные классы не наследуют класс `Array`, хотя и обладают тем же набором методов и свойств. У каждого из них есть соответствующая фабричная функция:
```kotlin
val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2]
```

```kotlin
// int массив, размером 5 со значениями [0, 0, 0, 0, 0]
val arr = IntArray(5)

// инициализация элементов массива константой
// int массив, размером 5 со значениями [42, 42, 42, 42, 42]
val arr = IntArray(5) { 42 }

// инициализация элементов массива лямбда-выражением
// int массив, размером 5 со значениями [0, 1, 2, 3, 4] (элементы инициализированы своим индексом)
var arr = IntArray(5) { it * 1 }
```

!!! example Example
```kotlin
import kotlin.math.pow

fun main() {
    val testArrayInt: IntArray = intArrayOf(1, 2, 3)
    testArrayInt[0] = testArrayInt[1] + testArrayInt[2]
    testArrayInt.forEach { print(it.toString() + "\t") }
    println()
    val testArrayInit = IntArray(5)
    testArrayInit.forEach { print(it.toString() + "\t ") }
    println()
    val testArrayConst = IntArray(5) { 79 }
    testArrayConst.forEach { print(it.toString() + "\t ") }
    println()
    var testArrayLambda = DoubleArray(9) { 2.0.pow(it) }
    testArrayLambda.forEach { print(it.toString() + "\t ") }
    println()
}
```

<details>
<summary>Output</summary>

```
5	2	3	
0	 0	 0	 0	 0	 
79	 79	 79	 79	 79	 
1.0	 2.0	 4.0	 8.0	 16.0	 32.0	 64.0	 128.0	 256.0	 

Process finished with exit code 0

```

</details>

### Условия и циклы
https://kotlinlang.ru/docs/control-flow.html

#### Условное выражение `if`
В языке Kotlin `if` является выражением, т.е. оно возвращает значение. Это позволяет отказаться от тернарного оператора (`условие ? условие истинно : условие ложно`), потому что обычному `if` вполне по силам его заменить.
```kotlin
// обычное использование
var max = a
if (a < b) max = b

// с блоком else
var max: Int
if (a > b) {
    max = a
} else {
    max = b
}

// в виде выражения
val max = if (a > b) a else b
```

“Ветви” выражения `if` могут быть блоками, т.е. содержать несколько строк кода, при этом последнее выражение является значением блока:
```kotlin
val max = if (a > b) {
    print("возвращаем a")
    a
} else {
    print("возвращаем b")
    b
}
```

Если вы используете `if` в качестве выражения (например, возвращая его значение или присваивая его переменной), то использование ветки `else` является обязательным.

!!! example Example
```kotlin
fun main() {
    var testMax = 5
    val testNew = (0..9).random()
    println("testNew: $testNew")
    if (testMax < testNew) testMax = testNew
    println(testMax)

    val testOne = (10..19).random()
    val testTwo = (10..19).random()
    println("testOne: $testOne, testTwo: $testTwo")

    if (testOne > testTwo) {
        println(testOne)
    } else {
        println(testTwo)
    }

    val testPrint = if (testOne > testTwo) {
        print("Возвращаем testOne - ")
        testOne
    } else {
        print("Возвращаем testTwo - ")
        testTwo
    }

    println(testPrint)
}
```

<details>
<summary>Output</summary>

```
testNew: 7
7
testOne: 17, testTwo: 13
17
Возвращаем testOne - 17

Process finished with exit code 0

```

</details>

#### Условное выражение `when`
`when` определяет условное выражение с несколькими “ветвями”. Оно похоже на оператор `switch`, присутствующий в C-подобных языках.
```kotlin
when (x) {
    1 -> print("x == 1")
    2 -> print("x == 2")
    else -> { // обратите внимание на блок
        print("x не равен ни 1, ни 2")
    }
}
```

`when` последовательно сравнивает свой аргумент со всеми указанными значениями, пока не выполнится какое-либо из условий ветвей.

`when` можно использовать и как выражение, и как оператор. При использовании его в виде выражения значение первой ветки, удовлетворяющей условию, становится значением всего выражения. При использовании в виде оператора значения отдельных веток отбрасываются. В точности как `if`: каждая ветвь может быть блоком и её значением является значение последнего выражения блока.

Значение ветки `else` вычисляется в том случае, когда ни одно из условий в других ветках не удовлетворено.

Если when используется как *выражение*, то ветка else является обязательной, за исключением случаев, в которых компилятор может убедиться, что ветки покрывают все возможные значения. Так происходит, например с записями [класса `enum`](https://kotlinlang.ru/docs/enum-classes.html) и с подтипами [`sealed` (изолированных) классов](https://kotlinlang.ru/docs/sealed-classes.html).
```kotlin
enum class Bit {
  ZERO, ONE
}
val numericValue = when (getRandomBit()) {
    Bit.ZERO -> 0
    Bit.ONE -> 1
    // 'else' не требуется, потому что все случаи учтены
}
```

В *операторах* `when` ветка `else` является обязательной в следующих условиях:

- `when` имеет объект типа `Boolean`, `enum`, `sealed` или их nullable-аналоги;
- ветки `when` не охватывают все возможные случаи для этого объекта.

```kotlin
enum class Color {
    RED, GREEN, BLUE
}

when (getColor()) {
    Color.RED -> println("red")
    Color.GREEN -> println("green")
    Color.BLUE -> println("blue")
    // 'else' не требуется, потому что все случаи учтены
}

when (getColor()) {
    Color.RED -> println("red") // нет веток для GREEN и BLUE
    else -> println("not red") // 'else' обязателен
}
```

Если для нескольких значений выполняется одно и то же действие, то условия можно перечислять в одной ветке через запятую.
```kotlin
when (x) {
    0, 1 -> print("x == 0 or x == 1")
    else -> print("otherwise")
}
```

Помимо констант в ветках можно использовать произвольные выражения.
```kotlin
when (x) {
    s.toInt() -> print("s encodes x")
    else -> print("s does not encode x")
}
```

Также можно проверять вхождение аргумента в [интервал](https://kotlinlang.ru/docs/ranges.html) `in` или `!in` или его наличие в коллекции:
```kotlin
when (x) {
    in 1..10 -> print("x is in the range")
    in validNumbers -> print("x is valid")
    !in 10..20 -> print("x is outside the range")
    else -> print("none of the above")
}
```

Помимо этого Kotlin позволяет с помощью `is` или `!is` проверить тип аргумента. Обратите внимание, что благодаря [умным приведениям](https://kotlinlang.ru/docs/typecasts.html#smart-casts) вы можете получить доступ к методам и свойствам типа без дополнительной проверки.
```kotlin
fun hasPrefix(x: Any) = when(x) {
    is String -> x.startsWith("prefix")
    else -> false
}
```

`when` удобно использовать вместо цепочки условий вида `if`-`else if`. При отсутствии аргумента условия работают как простые логические выражения, а тело ветки выполняется при его истинности.
```kotlin
when {
    x.isOdd() -> print("x is odd")
    y.isEven() -> print("y is even")
    else -> print("x+y is odd")
}
```

Можно получать переменную внутри `when` условия по следующему синтаксису:
```kotlin
fun Request.getBody() =
    when (val response = executeRequest()) {
        is Success -> response.body
        is HttpError -> throw HttpException(response.status)
    }
```

Такая переменная, объявленная внутри условия `when` может быть видна только внутри тела этого `when`.

!!! example Example
```kotlin
fun main() {
    val testRandom = (1..9).random()
    println("testRandom: $testRandom")
    when (testRandom) {
        1 -> println("testRandom == 1")
        2, 4, 6, 8 -> println("testRandom == 2 или 4 или 6 или 8")
        else -> { // обратите внимание на блок
            println("testRandom не равен 1 и не кратно 2")
        }
    }
    val testArrayInt = IntArray(10) { it }
    val testRandomNew = (1..30).random()
    println("testRandomNew: $testRandomNew")
    when (testRandomNew) {
        in 10..20 -> println("Значение в промежутке от 10 до 20")
        in testArrayInt -> println("Значение попадает в массив с числами от 0 до 9")
        !in 21..25 -> println("Значение больше 25")
        else -> println("Значение в промежутке от 21 до 25")
    }
    val testRem = when(testRandomNew) {
        in 1..15 -> testRandomNew
        else -> "Значение больше 15"
    }
    println(testRem)
}
```

<details>
<summary>Output</summary>

```
testRandom: 6
testRandom == 2 или 4 или 6 или 8
testRandomNew: 4
Значение попадает в массив с числами от 0 до 9
4

Process finished with exit code 0

```

</details>

#### Цикл `for`
Цикл `for` обеспечивает перебор всех значений, поставляемых итератором. Он эквивалентен циклу `foreach` в таких языках, как C#.
```kotlin
for (item in collection) print(item)
```

Телом цикла может быть блок кода.
```kotlin
for (item: Int in ints) {
    // ...
}
```

Как отмечено выше, цикл `for` позволяет проходить по всем элементам объекта, имеющего итератор, например:

- обладающего внутренней или внешней функцией `iterator()`, возвращаемый тип которой `Iterator<>`:
  - обладает внутренней или внешней функцией `next()`
  - обладает внутренней или внешней функцией `hasNext()`, возвращающей `Boolean`.

Все три указанные функции должны быть объявлены как `operator`.

Чтобы перебрать диапазон чисел, используйте выражение диапазона:
```kotlin
for (i in 1..3) {
    println(i)
}
for (i in 6 downTo 0 step 2) {
    println(i)
}
```

Цикл `for` по диапазону или массиву компилируется в основанный на индексе цикл, который не создает объект итератора.

Если при проходе по массиву или списку необходим порядковый номер элемента, используйте следующий подход:
```kotlin
for (i in array.indices) {
    println(array[i])
}
```

Также вы можете использовать библиотечную функцию `withIndex`.
```kotlin
for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}
```

!!! example Example
```kotlin
fun main() {
    val testArrayInt = IntArray(5) { it * 5 }

    for (item in testArrayInt) print(item.toString() + "\t")
    println()
    for (item in testArrayInt) {
        if (item % 3 == 0) {
            print("кратно\t")
        } else {
            print("некратно\t")
        }
    }
    println()
    for ((index, value) in testArrayInt.withIndex()) {
        println("Индекс - $index. Значение - $value")
    }
}
```

<details>
<summary>Output</summary>

```
0	5	10	15	20
кратно	некратно	некратно	кратно	некратно
Индекс - 0. Значение - 0
Индекс - 1. Значение - 5
Индекс - 2. Значение - 10
Индекс - 3. Значение - 15
Индекс - 4. Значение - 20

Process finished with exit code 0
```

</details>

#### Цикл `while`
Тело циклов `while` и `do-while` выполняется до тех пор, пока их условие выполняется. Разница между ними заключается во времени проверки условия:

- `while` проверяет условие и, если оно истинно, выполняет тело, а затем возвращается к проверке условия;
- `do-while` выполняет тело и только затем проверяет условие. Если оно выполняется, цикл повторяется. Таким образом, тело `do-while` выполняется по крайней мере один раз независимо от условия.
```kotlin
while (x > 0) {
    x--
}

do {
    val y = retrieveData()
} while (y != null) // y здесь доступно!
```

!!! example Example
```kotlin
fun main() {
    val testSize = (1..10).random()
    var testArr = IntArray(testSize)

    var i = 0
    while (i < testSize) {
        testArr[i] = (20..50).random()
        i++
    }
    testArr.forEach { print(it.toString() + "\t") }
    println()
    var j = 0
    do {
        testArr[j] = (20..50).random()
        j++
    } while (j < testSize)
    testArr.forEach { print(it.toString() + "\t") }
}
```

<details>
<summary>Output</summary>

```
21	40	40	28
45	21	50	48
Process finished with exit code 0

```

</details>

#### Break и continue в циклах
Kotlin поддерживает привычные операторы `break` и `continue` в циклах. См. [Операторы перехода](#операторы-перехода).

### Операторы перехода
https://kotlinlang.ru/docs/returns.html

В Kotlin определено три оператора перехода:

- `return` по умолчанию производит возврат из ближайшей окружающей его функции или анонимной функции;
- `break` завершает выполнение ближайшего окружающего его цикла;
- `continue` продолжает выполнение цикла со следующего его шага, без обработки оставшегося кода текущей итерации.

Все эти выражения можно использовать как часть более крупных выражений:
```kotlin
val s = person.name ?: return
```

Эти выражения имеют тип `Nothing`.

#### Метки операторов break и continue
Любое выражение в Kotlin может быть помечено меткой *label*. Метки имеют форму идентификатора, за которым следует знак `@`, например `abc@` или `fooBar@`. Для того чтобы пометить выражение, мы просто ставим метку перед ним.
```kotlin
loop@ for (i in 1..100) {
    // ...
}
```

Теперь мы можем уточнить значения операторов `break` или `continue` с помощью меток.
```kotlin
loop@ for (i in 1..100) {
    for (j in 1..100) {
        if (...) break@loop
    }
}
```

Оператор `break`, отмеченный `@loop`, переводит выполнение кода в точку сразу после цикла, отмеченного этой меткой. Оператор `continue` продолжает цикл со следующей его итерации.

#### Возврат к меткам
В Kotlin функции могут быть вложены друг в друга с помощью литералов функций, локальных функций и анонимных объектов. Подходящий `return` позволит вернуться из внешней функции. Одним из самых важных применений этой синтаксической конструкции является возврат из лямбда-выражения. Напомним, что в таких случаях, как в примере ниже, `return` возвращает из ближайшей заключающей функции — `foo`:
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return // нелокальный возврат, непосредственно к объекту вызывающему функцию foo()
        print(it)
    }
    println("эта строка не достижима")
}
```

Обратите внимание, что такой нелокальный возврат поддерживается только лямбда-выражениями, переданными [инлайн-функциям](https://kotlinlang.ru/docs/inline-functions.html). Чтобы вернуться из лямбда-выражения, к оператору стоит поставить метку и тем самым сделать уточнение для `return`.
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // локальный возврат внутри лямбды, то есть к циклу forEach
        print(it)
    }
    print(" выполнится с использованием явной метки(lit@)")
}
```

Теперь он возвращает только из лямбда-выражения. Зачастую намного более удобно использовать *неявные метки*, потому что такие метки имеют такое же имя, как и функция, к которой относится лямбда.
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return@forEach // локальный возврат внутри лямбды, то есть к циклу forEach
        print(it)
    }
    print(" выполнится с использованием неявной метки(forEach@)")
}
```

Возможно также использование [анонимной функции](https://kotlinlang.ru/docs/lambdas.html#anonymous-functions) в качестве альтернативы лямбда-выражениям. Оператор `return` возвращает из самой анонимной функции.

```
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {
        if (value == 3) return  // локальный возврат внутри анонимной функции, то есть к циклу forEach
        print(value)
    })
    print(" выполнится с использованием анонимной функции")
}

```

Обратите внимание, что использование локальных возвратов в предыдущих трех примерах аналогично использованию `continue` в обычных циклах.

Прямого эквивалента для `break` не существует, но его можно смоделировать — добавить еще одну вложенную лямбду и нелокально вернуться из нее.
```kotlin
fun foo() {
    run loop@{
        listOf(1, 2, 3, 4, 5).forEach {
            if (it == 3) return@loop // нелокальный возврат из лямбды к вызывающему run
            print(it)
        }
    }
    print(" выполнится с использованием вложенной метки")
}
```

При возвращении значения парсер отдаёт предпочтение специализированному возврату.
```kotlin
return@a 1
```

что значит “верни `1` в метке `@a`”, а не “верни выражение с меткой `(@a 1)`”.

### Диапазоны и прогрессии
https://kotlinlang.ru/docs/ranges.html

Kotlin позволяет легко создавать диапазоны значений с помощью функции `rangeTo()`, которая находится в пакете `kotlin.ranges`. У функции есть операторная форма — `..`. Обычно `rangeTo()` используется совместно с функциями `in` или `!in`.
```kotlin
if (i in 1..4) {  // эквивалентная запись 1 <= i && i <= 4
    print(i)
}
```
У диапазонов целочисленных типов (`IntRange`, `LongRange`, `CharRange`) есть дополнительная функция: они поддерживают итерацию. Эти диапазоны также являются [прогрессиями](https://en.wikipedia.org/wiki/Arithmetic_progression).

Подобные диапазоны, как правило, используются в цикле `for`.
```kotlin
fun main() {
    for (i in 1..4) print(i) // 1234
}
```

Для перебора чисел в обратном порядке используйте функцию `downTo` вместо `..`.
```kotlin
fun main() {
    for (i in 4 downTo 1) print(i) // 4321
}
```

Можно перебирать числа с произвольным шагом. Осуществляется это с помощью функции `step`.
```kotlin
fun main() {
    for (i in 1..8 step 2) print(i) // 1357
    println()
    for (i in 8 downTo 1 step 2) print(i) // 8642
}
```

Если требуется перебрать диапазон чисел, исключая его последний элемент, то используйте функцию `until`.
```kotlin
fun main() {
    for (i in 1 until 10) { // i in [1, 10), 10 будет исключён
        print(i) // 123456789
    }
}
```

#### Диапазоны
В математическом смысле <dfn title="диапазон">диапазон</dfn> — это закрытый интервал: он определяется двумя значениями и они оба являются частью диапазона. Диапазоны применимы к сопоставимым (*comparable*) типам: имея порядок, вы можете определить, находится ли произвольный экземпляр в диапазоне между двумя заданными экземплярами.

Основная операция с диапазонами — это `contains`, которая обычно используется в форме операторов `in` и `!in`.

Чтобы создать диапазон на основе ваших классов, вызовите функцию `rangeTo()` для начального значения диапазона и укажите конечное значение в качестве аргумента. Чаще всего используется операторная форма функции `rangeTo()` — `..`.
```kotlin
class Version(val major: Int, val minor: Int): Comparable<Version> {
    override fun compareTo(other: Version): Int {
        if (this.major != other.major) {
            return this.major - other.major
        }
        return this.minor - other.minor
    }
}

fun main() {
    val versionRange = Version(1, 11)..Version(1, 30)
    println(Version(0, 9) in versionRange) // false
    println(Version(1, 20) in versionRange) // true
}
```

#### Прогрессии
Как показано в приведённых выше примерах, диапазоны целочисленных типов, таких как `Int`, `Long` и `Char`, можно рассматривать как [арифметические прогрессии](https://en.wikipedia.org/wiki/Arithmetic_progression). В Kotlin есть специальные типы для определения таких прогрессий: `IntProgression`, `LongProgression` и `CharProgression`.

У прогрессий есть три основных свойства: `first`, `last` и `step`, при этом `step` не может быть нулём. `first` — это первый элемент. Последующие элементы — это предыдущий элемент плюс `step`. Итерация по прогрессии с положительным шагом (`step`) эквивалентна индексируемому циклу `for` в Java / JavaScript.
```kotlin
for (int i = first; i <= last; i += step) {
  // ...
}
```
При неявном создании прогрессии путём итерации диапазона, элементы `first` и `last` этой прогрессии являются конечными точками диапазона, а `step` равен 1.
```kotlin
fun main() {
    for (i in 1..10) print(i) // 12345678910
}
```

Чтобы прогрессии задать собственный шаг, используйте функцию `step`.
```kotlin
fun main() {
    for (i in 1..8 step 2) print(i) // 1357
}
```

Последний элемент прогрессии (`last`) рассчитывается следующим образом: * Для положительного шага: максимальное значение, но не больше конечного значения — `(last - first) % step == 0`. * Для отрицательного шага: минимальное значение, но не меньше конечного значения — `(last - first) % step == 0`.

Таким образом, элемент `last` не всегда совпадает с конечным значением диапазона.
```kotlin
fun main() {
    for (i in 1..9 step 3) print(i) // 147, last = 7
}
```

Чтобы создать прогрессию для итерации в обратном направлении, при определении диапазона используйте `downTo` вместо `..`.
```kotlin
fun main() {
    for (i in 4 downTo 1) print(i) // 4321
}
```

Прогрессии реализуют интерфейс `Iterable<N>`, где `N` — это `Int`, `Long` или `Char`, поэтому вы можете использовать их в различных [функциях коллекций](https://kotlinlang.ru/docs/collection-operations.html), таких как map, filter и т. д.
```kotlin
fun main() {
    println((1..10).filter { it % 2 == 0 }) // [2, 4, 6, 8, 10]
}
```

!!! example [Example](./samples/02_Syntax/21_Ranges/src/Main.kt)
```kotlin
fun main() {
    for (i in 1..10) print(i.toString() + "\t")
    println()

    for (i in 1 until 10) print(i.toString() + "\t")
    println()

    for (i in 10 downTo 1) print(i.toString() + "\t")
    println()

    for (i in 1..10 step 3) print(i.toString() + "\t")
    println()
}
```

<details>
<summary>Output</summary>

```
1	2	3	4	5	6	7	8	9	10
1	2	3	4	5	6	7	8	9
10	9	8	7	6	5	4	3	2	1
1	4	7	10

Process finished with exit code 0

```

</details>
