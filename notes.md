<link href="styles.css" rel="stylesheet" />

# Разработка мобильных приложений 2023-2024 (МДК 01.03)
[66d6b6e6d048d3735272200f](https://e-learn.petrocollege.ru/course/view.php?id=7179)

- [Общее](#общее)
  - [Дополнительные материалы по курсу](#дополнительные-материалы-по-курсу)
  - [Официальные бесплатные курсы от Google](#официальные-бесплатные-курсы-от-google)
  - [Примерные теоретические вопросы к экзамену](#примерные-теоретические-вопросы-к-экзамену)
  - [Примерные практические задания на экзамен](#примерные-практические-задания-на-экзамен)
- [01 Введение](#01-введение)
  - [Коротко о GitHub](#коротко-о-github)
  - [Подключение VCS к IntelliJ IDEA](#подключение-vcs-к-intellij-idea)
  - [Хекслет](#хекслет)
- [02 Синтаксис языка. Управляющие конструкции - решение задач](#02-синтаксис-языка-управляющие-конструкции---решение-задач)
  - [Основной синтаксис](#основной-синтаксис)
    - [Определение имени пакета и импорт](#определение-имени-пакета-и-импорт)
    - [Точка входа в программу](#точка-входа-в-программу)
    - [Вывод в стандартный поток (с помощью `print()` и `println()`)](#вывод-в-стандартный-поток-с-помощью-print-и-println)
    - [Чтение данных с консоли](#чтение-данных-с-консоли)
    - [Переменные. Объявление переменных](#переменные-объявление-переменных)
  - [Основные типы](#основные-типы)
    - [Числа](#числа)
      - [Целочисленные типы](#целочисленные-типы)
      - [Типы с плавающей точкой](#типы-с-плавающей-точкой)
      - [Представление чисел в JVM](#представление-чисел-в-jvm)
      - [Символьные постоянные](#символьные-постоянные)
      - [Явные преобразования](#явные-преобразования)
      - [Арифметические операции](#арифметические-операции)
        - [Деление целых чисел](#деление-целых-чисел)
        - [Побитовые операции](#побитовые-операции)
      - [Сравнение чисел с плавающей точкой](#сравнение-чисел-с-плавающей-точкой)
      - [Целые беззнаковые числа](#целые-беззнаковые-числа)
        - [Беззнаковые массивы и диапазоны](#беззнаковые-массивы-и-диапазоны)
        - [Литералы](#литералы)
    - [Логический тип](#логический-тип)
    - [Символы](#символы)
    - [Строки](#строки)
      - [Строковые литералы](#строковые-литералы)
      - [Строковые шаблоны](#строковые-шаблоны)
    - [Массивы](#массивы)
      - [Массивы примитивных типов](#массивы-примитивных-типов)
  - [Условия и циклы](#условия-и-циклы)
    - [Условное выражение `if`](#условное-выражение-if)
    - [Условное выражение `when`](#условное-выражение-when)
    - [Цикл `for`](#цикл-for)
    - [Цикл `while`](#цикл-while)
    - [Break и continue в циклах](#break-и-continue-в-циклах)
  - [Операторы перехода](#операторы-перехода)
    - [Метки операторов break и continue](#метки-операторов-break-и-continue)
    - [Возврат к меткам](#возврат-к-меткам)
  - [Диапазоны и прогрессии](#диапазоны-и-прогрессии)
    - [Диапазоны](#диапазоны)
    - [Прогрессии](#прогрессии)
  - [Основы - задачи](#основы---задачи)
- [03 Массивы, коллекции](#03-массивы-коллекции)
  - [Массивы](#массивы-1)
    - [Объявление массива с использованием библиотечного метода `arrayOf()`](#объявление-массива-с-использованием-библиотечного-метода-arrayof)
    - [Свойство `indices`](#свойство-indices)
    - [Объявление массива неустановленных ("пустых"/"нулевых") значений и его инициализация (`arrayOfNulls()`)](#объявление-массива-неустановленных-пустыхнулевых-значений-и-его-инициализация-arrayofnulls)
    - [Создание пустого массива (`emptyArray()`)](#создание-пустого-массива-emptyarray)
    - [`val` vs `var`](#val-vs-var)
    - [Генерация значений с помощью инициализатора. Конструктор `Array()`](#генерация-значений-с-помощью-инициализатора-конструктор-array)
    - [Вывод значений массива. Класс `Arrays`](#вывод-значений-массива-класс-arrays)
    - [Массивы примитивных типов](#массивы-примитивных-типов-1)
    - [Двумерные массивы](#двумерные-массивы)
    - [Многомерный массив с базовыми типами](#многомерный-массив-с-базовыми-типами)
    - [Обход (перебор элементов) массивов](#обход-перебор-элементов-массивов)
    - [Итераторы](#итераторы)
      - [Использование итератора (интерфейс)](#использование-итератора-интерфейс)
        - [Functions](#functions)
        - [Extension Functions](#extension-functions)
    - [Операции с массивами](#операции-с-массивами)
      - [Переворачивание массива](#переворачивание-массива)
        - [Перевернуть массив: `reversedArray()`](#перевернуть-массив-reversedarray)
        - [Перевернуть массив: `reverse()`](#перевернуть-массив-reverse)
      - [Сортировка элементов массива](#сортировка-элементов-массива)
      - [Перемешивание элементов массива: `shuffle()` (Kotlin 1.40)](#перемешивание-элементов-массива-shuffle-kotlin-140)
      - [Наличие элемента в массиве: `contains()`](#наличие-элемента-в-массиве-contains)
      - [Найти среднее значение чисел в массиве: `average()`](#найти-среднее-значение-чисел-в-массиве-average)
      - [Подсчитать сумму чисел в массиве: `sum()`](#подсчитать-сумму-чисел-в-массиве-sum)
      - [Найти наибольшее и наименьшее число в массиве](#найти-наибольшее-и-наименьшее-число-в-массиве)
      - [Функция `intersect()`: найти общие элементы двух массивов](#функция-intersect-найти-общие-элементы-двух-массивов)
      - [Выбрать случайную строку из массива](#выбрать-случайную-строку-из-массива)
      - [`onEach()`: Операция с каждым элементом массива по очереди (Kotlin 1.40)](#oneach-операция-с-каждым-элементом-массива-по-очереди-kotlin-140)
      - [Удалить дубликаты](#удалить-дубликаты)
  - [Коллекции](#коллекции)
    - [Виды коллекций в Kotlin](#виды-коллекций-в-kotlin)
    - [Использование коллекций](#использование-коллекций)
    - [Типы коллекций](#типы-коллекций)
    - [`Collection`](#collection)
    - [`List`](#list)
    - [`Set`](#set)
    - [`Map`](#map)
- [04 Функции](#04-функции)
  - [Функции – обязательные и необязательные параметры (значения по умолчанию)](#функции--обязательные-и-необязательные-параметры-значения-по-умолчанию)
  - [Функции – именованные параметры](#функции--именованные-параметры)
  - [Функции – изменение параметров](#функции--изменение-параметров)
  - [Функции – переменное число параметров](#функции--переменное-число-параметров)
  - [Оператор `*` — spread operator](#оператор---spread-operator)
  - [Функции – оператор `return`](#функции--оператор-return)
  - [Функции – вернули `Unit`](#функции--вернули-unit)
  - [Функции – однострочные функции](#функции--однострочные-функции)
  - [Функции – локальная функция](#функции--локальная-функция)
  - [Функции – рефакторинг кода](#функции--рефакторинг-кода)
  - [Функции – перегрузка](#функции--перегрузка)
  - [Функции – присвоение переменной](#функции--присвоение-переменной)
  - [Функции – примеры использования](#функции--примеры-использования)
  - [Функции высокого порядка](#функции-высокого-порядка)
  - [Возвращение функции из функции](#возвращение-функции-из-функции)
  - [Анонимные функции](#анонимные-функции)
  - [Анонимные функции как аргумент](#анонимные-функции-как-аргумент)
  - [Возвращение анонимной функции из функции](#возвращение-анонимной-функции-из-функции)
  - [Функции – лямбда-выражения](#функции--лямбда-выражения)
  - [Лямбда-выражения. Передача параметров](#лямбда-выражения-передача-параметров)
  - [Лямбда-выражения как аргументы функций](#лямбда-выражения-как-аргументы-функций)
  - [Ключевые особенности функций в Kotlin](#ключевые-особенности-функций-в-kotlin)
  - [Функции - задачи](#функции---задачи)
    - [1. Камень-Ножницы-Бумага (три события)](#1-камень-ножницы-бумага-три-события)
    - [2. Биграммный шифр Порты](#2-биграммный-шифр-порты)
    - [3. Программа шифрования методом Вижинера](#3-программа-шифрования-методом-вижинера)
    - [4. Программа шифрования методом омофонической замены](#4-программа-шифрования-методом-омофонической-замены)

## Общее
[66df5d7ed048d373527220f7](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-0)

### Дополнительные материалы по курсу

- [Документация по Kotlin](https://kotlinlang.org/docs/home.html)
- [Документация по Kotlin (ru)](https://kotlinlang.ru/)
- [Материал по коллекциям](https://trello.com/b/7eWLU7kG/kotlin-collections)
- [Android for Developers](https://developer.android.com/)
- [Документация по GitHub](https://docs.github.com/en)
- [Книга Pro Git (на русском)](https://git-scm.com/book/ru/v2)
- [Различные иконки](https://www.flaticon.com/)
- [Шрифты от Google](https://fonts.google.com/)
- [Material Design](https://m3.material.io/)
- [Android разработчик](https://developer.android.com/guide/index.html)
- [Android Developer Fundamentals (Version 2)](https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/index.html)
- [On-line редактор для работы с Kotlin - официальный](https://play.kotlinlang.org/)
- [On-line редактор для работы с Kotlin - работает с интерактивом](https://www.jdoodle.com/compile-kotlin-online/)

### Официальные бесплатные курсы от Google

- [Android Basics (RUS)](https://javarush.ru/quests/QUEST_GOOGLE_ANDROID)
- [Developing Android Apps - Intermediate level (ENG)](https://www.udacity.com/course/new-android-fundamentals--ud851)
- [Android app development - Advanced level (ENG)](https://www.udacity.com/course/-advanced-android-app-development--ud855)
- [Kotlin Bootcamp for Programmers (ENG)](https://www.udacity.com/course/kotlin-bootcamp-for-programmers--ud9011)
- [Developing Android Apps with Kotlin (ENG)](https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012)
- [Kotlin for Android Developers (ENG)](https://www.udacity.com/course/kotlin-for-android-developers--ud888)
- [Advanced Android with Kotlin (ENG)](https://www.udacity.com/course/advanced-android-with-kotlin--ud940)
- [Android Performance (ENG)](https://www.udacity.com/course/android-performance--ud825)
- [Material Design for Android Developers (ENG)](https://www.udacity.com/course/material-design-for-android-developers--ud862)
- [Firebase in a Weekend: Android (ENG)](https://www.udacity.com/course/firebase-in-a-weekend-by-google-android--ud0352)
- [Build Native Mobile Apps with Flutter (ENG)](https://www.udacity.com/course/build-native-mobile-apps-with-flutter--ud905)

### Примерные теоретические вопросы к экзамену
66e01520d048d3735272210c

1. Понятие мобильной разработки. История развития.

2. Инструментарий разработчика мобильных приложений

3. Использование систем контроля версий при разработке мобильных приложений

4. История языка Kotlin. Преимущества и недостатки Kotlin.

5. Типы данных, используемые в языке Kotlin

6. Структура программы на языке Kotlin. Использование условий и циклов

7. Встроенные и пользовательские функции языка Kotlin. Нефиксированное число аргументов. Перегрузка функций.

8. Массивы и их использование в языке Kotlin.

9. Immutable Collection. Mutable Collection. List и его использование в языке Kotlin.

10. Immutable Collection. Mutable Collection. Set и его использование в языке Kotlin.

11. Immutable Collection. Mutable Collection. Map и его использование в языке Kotlin.

12. ООП в Kotlin. Создание и использование классов. Свойства и методы классов.

13. ООП в Kotlin. Использование конструкторов и интерфейсов.

14. Среда разработки Android Studio. Краткий обзор базовых UI-компонентов.

15. Среда разработки Android Studio. Файловая структура проекта. Режимы Project и Android

16. Создание экрана приложения. Использование компоновщиков.

17. Обработка нажатия кнопки. Использование события onClick и параметра viewBinding

18. ToolBar и создание меню для ToolBar

19. BottomNavigationView и создание меню.

20. Activity и ее жизненный цикл. Способы создания.

21. Переход между Activity и передача данных между Activity

22. Fragment. Создание и использование

23. Передача данных между Fragment и Activity с помощью ViewModal

24. Создание базы данных с использованием Kotlin.

25. Работа с базой данных с использованием Room

26. Списки и их использование. Работа с ListView

27. Списки и их использование. Использование RecyclerView

###  Примерные практические задания на экзамен
66e015b8d048d3735272210e

1. Расположить на экране, в центре, квадрат размером 200х200 синего цвета. Внизу экрана расположить кнопку с надписью «СТАРТ». При нажатии на кнопку цвет квадрата меняется циклично в следующем порядке: синий – красный – желтый

2. Создать приложение, состоящее из двух Activity. На каждой Activity расположить по центру соответствующие надписи: «Activity 01» и «Activity 02». Также на каждой Activity расположить ниже надписей (на 100px), кнопки. Нажатием на кнопку пользователь переходит на другую Activity.

3. Создать приложение, состоящее из кнопки и текстового поля. При запуске приложения в текстовом поле стоит число 1.  При нажатии на кнопку значение в текстовом поле меняется от 1 до 10 с шагом 1. После 10-и отсчет опять начинается с 1-ы.

4. Создать приложение, состоящее из кнопки и текстового поля. При запуске приложения в текстовом поле стоит число 0.  При последовательных нажатиях на кнопку в текстовое поле выводятся последовательно нечетные числа в диапазоне [1;10]. После 10-и отсчет опять начинается с наименьшего нечетного числа.

5. Создать приложение, состоящее из кнопки и текстового поля. При запуске приложения в текстовом поле стоит число 0.  При последовательных нажатиях на кнопку в текстовое поле выводятся последовательно четные числа в диапазоне [1;10]. После 10-и отсчет опять начинается с наименьшего четного числа.

6. Создать приложение, состоящее из Activity и двух Fragment. На Fragment расположены соответственно надписи – «Фрагмент01» и «Фрагмент02». На Activity расположить кнопку, нажатие на которую будет показывать циклично Fragment01 и Fragment02.

7. Создать приложение, состоящее из двух Activity. На каждом Activity находится кнопка для перехода на другую Activity, и текстовое поле, в которое можно ввести только цифры. Пользователь вводит в поле какое-то значение и нажимает кнопку. Осуществляется переход на другую Activity при котором в поле для ввода передается введенное значение.

8. Создать простое приложение, демонстрирующее передачу данных от Activity во Fragment.

9. Создать простое приложение, демонстрирующее передачу данных от Fragment в Activity.

10. Создать простое приложение, демонстрирующее передачу данных из одного Fragment в другой Fragment.

11. Создать приложение, в котором имеется меню в ToolBar, состоящее из пунктов – Red, Green и Yellow. В центре экрана имеется квадрат, который при выборе пункта меню меняет свой цвет на соответствующий. При запуске приложения цвет квадрата Black.

12. Создать приложение, в котором имеется меню в BottomNavigationView, состоящее из пунктов – Red, Green и Yellow. В центре экрана имеется квадрат, который при выборе пункта меню меняет свой цвет на соответствующий. При запуске приложения цвет квадрата Black.

13. Вывести на экран приложения элементы массива нечетных чисел (не менее 30-и элементов) с использованием ListView и ArrayAdapter.

14. Имеется два массива – массив четных чисел и массив числительных, соответствующих этим числам. Вывести на экран приложения элементы массива четных чисел (не менее 30-и элементов) с использованием ListView и ArrayAdapter. При нажатии на элемент списка во всплывающем сообщении появляется соответствующее ему числительное.

15. Показать приложение «Рецепты», созданное с использованием ListView, и объяснить его работу (свой Adapter, изменения в Manifest и т.д.). Приложение необходимо сделать заранее по презентации до экзамена.

16. Показать приложение «Пикачу», созданное с использованием RecyclerView, и объяснить его работу (свой Adapter, ресурсы, изменения в Manifest и т.д.). Приложение необходимо сделать заранее по презентации до экзамена.

17. Создать приложение, состоящее из кнопки в центре экрана и четырех пронумерованных квадратов, расположенных по углам Activity. Квадрат с номером 1 расположен в верхнем правом углу. Далее – по часовой стрелке. При нажатии на кнопку у квадратов последовательно меняется цвет на красный. Ранее выделенный красным квадрат меняет свой цвет на цвет по умолчанию (синий).

18. Создать приложение, состоящее из кнопки в центре экрана и четырех пронумерованных квадратов, расположенных по углам Activity. Квадрат с номером 1 расположен в верхнем правом углу. Далее – по часовой стрелке. При нажатии на кнопку случайным образом выбирается квадрат и его цвет меняется на красный. Ранее выделенный красным квадрат меняет свой цвет на цвет по умолчанию (синий).

19. Создать приложение, состоящее из двух полей ввода и текстового поля, а также кнопки «РЕЗУЛЬТАТ». Пользователь вводит целые числа в поля ввода. При нажатии на кнопку в текстовом поле получаем сумму введенных чисел. Сделать так, чтобы в поля ввода можно было вводить только числовые значения.

20. Создать приложение, с помощью которого пользователь вводит в соответствующие поля только числовые значения и при нажатии на кнопку «РЕЗУЛЬТАТ» получает частное и остаток от деления первого числа на второе.

21. Создать приложение, в котором пользователь вводит в соответствующие поля два целых числа и при нажатии на кнопку «РЕЗУЛЬТАТ» между введенными числами ставится знак «<» или «>», в зависимости от введенных значений.

22. Создать приложение, в котором пользователь вводит в соответствующее поле любое число (целое или дробное). При нажатии на кнопку «РЕЗУЛЬТАТ» в другом текстовом поле отображается округленное до ближайшего большего целое число.

23. Создать приложение, которое подсчитывает в веденном слове количество гласных букв.

24. Создать приложение, которое подсчитывает в веденном слове количество согласных букв.

25. Создать приложение, в котором пользователь вводит в соответствующее поле любое число (целое или дробное). При нажатии на кнопку «РЕЗУЛЬТАТ» в другом текстовом поле отображается округленное до ближайшего нечетного большего целое число.

26. Создать приложение, в котором пользователь вводит в соответствующее поле любое число (целое или дробное). При нажатии на кнопку «РЕЗУЛЬТАТ» в другом текстовом поле отображается округленное до ближайшего большего четного целое число.

27. Создать приложение, с помощью которого пользователь вводит в соответствующее поле числовое значение и при нажатии на кнопку «РЕЗУЛЬТАТ» получает сообщение о четности или нечетности числа.

## 01 Введение
[66e0171ad048d37352722110](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-1)

### Коротко о GitHub
66e1bf5ad048d37352722148

Сервис для совместной разработки и хостинга ИТ-проектов Github был основан в апреле 2008 года программистами Крисом Ванстрасом (Chris Wanstrath), Томом Престон-Вернером (Thomas Preston-Werner) и Пи Джей Хайеттом (PJ Hyett).

![](./img/github-1.webp)

Первоначально проект предполагался как сообщество по разработке с помощью открытого исходного кода, использующего систему управления версиями Git.

В 2005 году программист Линус Торвальдс создал Git в ходе работы над ядром Linux. Разработчики начали применять эту систему в своей работе. Создание Git считалось выходом «на следующий уровень» по сравнению с другим программным обеспечением для управления версиями.

![](./img/github-2.webp)

При этом, по мнению Престон-Вернера, проблема совместной работы не исчезла — Git делала её возможной, но сложной. GitHub был призван стать решением проблемы. В дальнейшем первым слоганом платформы станет «Гит-хостинг: больше не боль в заднице» (Git hosting: No longer a pain in the ass).

Идея пришла Ванстрасу и Престону-Вернеру во время митапа Ruby-разработчиков в октябре 2007 года в Сан-Франциско. Они планировали, что будущий проект должен стать местом, где разработчики могли бы легко делиться кодом и изучать программы друг друга.

В то время Ванстрас зарабатывал консалтингом, а до этого занимался техническим развитием сайта о технологиях Cnet. В свою очередь Престон-Вернер был разработчиком в компании Powerset.

В конце 2007 года они приступили к созданию собственного проекта — по субботам разработчики устраивали мозговой штурм, а в свободное время писали код будущей платформы. Престон-Вернер взял на себя разработку пользовательского интерфейса GitHub, а Ванстрас занялся разработкой самого приложения на Ruby on Rails.

«GitHub не должен был стать стартапом или компанией. GitHub был всего лишь инструментом, который был нужен нам самим», — рассказывал в интервью Wired Ванстрас.

Престон-Вернеру в работе над GitHub также пригодился опыт создания сервиса Gravatar в 2007 году, который позволял сохранять изображения для профилей в соцсетях на отдельном сервере. В том же году разработчик продал сайт компании Automattic (владеет блог-платформой WordPress).

Молодые люди потратили «несколько сотен долларов» на покупку домена у VPS-провайдера Slicehost, регистрацию компании Logical Awesome и графику для будущего сайта.

Кроме того, разработчики приобрели в фотостоке iStockphoto права на рисунок «осьмикота» (смесь кота и осьминога) художника Саймона Оуксли, создавшего первый логотип Twitter. Выдуманное животное стало маскотом GitHub.

![](./img/github-3.webp)

Должность генерального директора компании занял Ванстрас. Первое время команда GitHub работала удаленно в кофейнях и из дома, общаясь через сервис Campfire. Собственный офис в Сан-Франциско у компании появился только в 2010 году.

В начале 2008 года разработчики запустили бета-версию платформы и разослали приглашения друзьям и знакомым. Первые участники начали пользоваться GitHub, размещая на площадке свои рабочие коды. Одним из первых проектов, который присоединился к новой платформе, стал фреймворк Ruby on Rails.

В феврале 2008 к команде основателей проекта присоединился Пи Джей Хайетт. С ним в 2007 году Ванстрас познакомился в Cnet, а затем молодые люди пытались запустить аналог Google+ под названием Famspam. Однако их стартап не стал успешным.

Публичный запуск GitHub состоялся 10 апреля 2008 года. К этому моменту проект содержал 20 тысяч репозиториев, а количество пользователей составило более двух тысяч.

«Мы действительно гордимся этим сайтом, и у нас есть так много идей на будущее. Это только начало», — написал в блоге проекта Ванстрас.

Разработчики заложили в GitHub такие возможности, как дублирование или форкинг (Forking), запросы на включение в проект изменений (Pull Requests) и слияние (Merging).

В GitHub можно скопировать любой опубликованный репозиторий в свой профиль, чтобы модифицировать его. Затем разработчик может поделиться изменениями с владельцем репозитория посредством запроса на включение. Если владельцу нравятся изменения, то он может слить их с первоначальным репозиторием.

Таким образом подход GitHub позволил любому зарегистрированному пользователю делиться, улучшать или развивать открытые проекты.

Также GitHub предоставил такие функции совместной работы, как отслеживание ошибок, запрос функций, управление задачами и вики-страницами для каждого проекта.

3 июня 2018 года Bloomberg сообщило, что Microsoft заключила соглашение о покупке GitHub. По словам одного из источников агентства, владельцы GitHub решили не выводить компанию на биржу, а продать её, так как их впечатлил глава корпорации Сатья Наделла.

На следующий день Microsoft и GitHub подтвердили сделку. Её стоимость составила $7,5 млрд.

### Подключение VCS к IntelliJ IDEA
[66e1c090d048d3735272214a](https://rutube.ru/video/private/b9a41fbd9e87579966bb398b1c1e3baf/?p=hQYXvP2kkS5ONZM9CaDxHQ)

1. Go *GitHub.com* and generate a new classical token with the following settings:

   - [x] repo
     - [x] repo:status
     - [x] repo_deployment
     - [x] public_repo
     - [x] repo:invite
     - [x] security_events
   - [ ] admin:org
     - [ ] write:org
     - [x] read:org
     - [ ] manage_runners:org
   - [x] gist

2. Copy and saved a newly generated token.
2. IntelliJ IDEA: *File* > *Settings* > *Version Control* > *GitHub*. Press "+" and choose to "Log in with Token...".
3. Add GitHub Account with the following settings:
   - Server: *github.com*
   - Token: *your generated GitHub token*
4. Replace .gitignore contents with the [following](https://github.com/JetBrains/kotlin/blob/master/.gitignore):

    <details>
    <summary><b><i>.gitignore</i></b></summary>

    ```
    .DS_Store
    .idea/shelf
    /confluence/target
    /dependencies/repo
    /android.tests.dependencies
    /dependencies/android.tests.dependencies
    /dist
    /local
    /gh-pages
    /ideaSDK
    /clionSDK
    /android-studio/sdk
    out/
    /tmp
    /intellij
    workspace.xml
    *.versionsBackup
    /idea/testData/debugger/tinyApp/classes*
    /jps-plugin/testData/kannotator
    /js/js.translator/testData/out/
    /js/js.translator/testData/out-min/
    /js/js.translator/testData/out-pir/
    .gradle/
    build/
    !**/src/**/build
    !**/test/**/build
    *.iml
    !**/testData/**/*.iml
    .idea/artifacts
    .idea/remote-targets.xml
    .idea/libraries/Gradle*.xml
    .idea/libraries/Maven*.xml
    .idea/modules
    .idea/runConfigurations/JPS_*.xml
    .idea/runConfigurations/_JPS_*.xml
    .idea/runConfigurations/PILL_*.xml
    .idea/runConfigurations/_FP_*.xml
    .idea/runConfigurations/_MT_*.xml
    .idea/libraries
    .idea/modules.xml
    .idea/gradle.xml
    .idea/compiler.xml
    .idea/inspectionProfiles/profiles_settings.xml
    .idea/.name
    .idea/jarRepositories.xml
    .idea/csv-plugin.xml
    .idea/libraries-with-intellij-classes.xml
    .idea/misc.xml
    .idea/protoeditor.xml
    .idea/uiDesigner.xml
    node_modules/
    .rpt2_cache/
    local.properties
    buildSrcTmp/
    distTmp/
    outTmp/
    /test.output
    /kotlin-native/dist
    kotlin-ide/
    .kotlin/
    .teamcity/
    ```

    </details>

5. Create new repository and branch from main.
6. Do your work, commit and push to GitHub.
7. Create pull request at GitHub.
8. Attach GitHub pull request url at the colledge system.
9. Merge branch to main after approval.

### Хекслет
[66ec3c46d048d37352722213](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345139)

Зарегистрироваться при необходимости на сайте Хекслет

Пройти курс [Введение в Git](https://ru.hexlet.io/courses/intro_to_git)

В качестве отчета приложить архив скриншота экрана главной страницы курса с открытым меню для профиля (см. пример). Преподаватель может попросить войти на указанный ресурс с компьютера колледжа для проверки достоверности указанных сведений.

## 02 Синтаксис языка. Управляющие конструкции - решение задач
[66ec3cb8d048d37352722215](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-2)

### Основной синтаксис
[66ed9ed65040133e8429e165](https://e-learn.petrocollege.ru/mod/url/view.php?id=345141) https://kotlinlang.ru/docs/basic-syntax.html

#### Определение имени пакета и импорт
Имя пакета указывается в начале исходного файла, так же как и в Java.
```kotlin
package my.demo

import java.util.*

// ...
```

Но в отличие от Java, нет необходимости, чтобы структура пакетов совпадала со структурой папок: исходные файлы могут располагаться в произвольном месте на диске.

См. [Пакеты](https://kotlinlang.ru/docs/packages.html).

#### Точка входа в программу
В Kotlin точкой входа в программу является функция `main`.
```kotlin
fun main() {
    println("Hello world!")
}
```

Другая форма `main` может принимать массив строк `String`.
```kotlin
fun main(args: Array<String>) {
    println(args.contentToString())
}
```

#### Вывод в стандартный поток (с помощью `print()` и `println()`)
`print` выводит свой аргумент в стандартный поток вывода.
```kotlin
print("Hello ")
print("world!")
```

`println` выводит свой аргумент и добавляет перевод строки, так что следующее, что вы выведите, появится на следующей строке.
```kotlin
println("Hello world!")
println(42)
```

!!! example [Example](samples/02_Syntax/02_Output/src/Main.kt)
```kotlin
fun main() {
    val testF = "1234567"
    for (i in 0..testF.length - 1) {
        println(testF[i])
    }
    println("====================")
    for (i in 0..testF.length - 1) {
        print(testF[i])
    }
}

```

<details>
<summary>Output</summary>

```
1
2
3
4
5
6
7
====================
1234567

Process finished with exit code 0
```

</details>


!!! example [Example](samples/02_Syntax/03_Output/src/Main.kt)
```kotlin
fun main() {
    print("Введите трехзначное число: ")
    val testF = readln()
    println("==============")
    println("Простой вывод значения переменной")
    println(testF)
    println("Вывод переменной как части строки")
    println("Мы ввели число - $testF")
    println("Некорректное обращение к части строки")
    println("Первый символ введенного числа - $testF[0]")
    println("Обратите внимание на фигурные скобки")
    println("Первый символ введенного числа - ${testF[0]}")
}

```

<details>
<summary>Output</summary>

```
Введите трехзначное число: 987
==============
Простой вывод значения переменной
987
Вывод переменной как части строки
Мы ввели число - 987
Некорректное обращение к части строки
Первый символ введенного числа - 987[0]
Обратите внимание на фигурные скобки
Первый символ введенного числа - 9

Process finished with exit code 0
```

</details>

#### Чтение данных с консоли

!!! example [Example](samples/02_Syntax/04_ConsoleInput/src/Main.kt)
```kotlin
fun main() {
    print("Введите строку символов: ")
    val testF = readln()
    println()

    for (i in 0..testF.length - 1) {
        print(testF[i])
    }
}
```

<details>
<summary>Output</summary>

```
Введите строку символов: Это строка символов

Это строка символов
Process finished with exit code 0

```

</details>

!!! example [Example](samples/02_Syntax/05_ConsoleIO/src/Main.kt)
```kotlin
fun main() {
    print("Введите строку символов: ")
    val testF = readln()
    println()

    for (i in testF) {
        print(i)
    }
}

```

<details>
<summary>Output</summary>

```
Введите строку символов: Чтение символов из строки

Чтение символов из строки
Process finished with exit code 0

```

</details>

#### Переменные. Объявление переменных
Неизменяемые (только для чтения) локальные переменные определяются с помощью ключевого слова `val`. Присвоить им значение можно только один раз.
```kotlin
val a: Int = 1   // Инициализация при объявлении
val b = 1        // Тип `Int` определен автоматически
val c: Int       // Указывать тип обязательно, если переменная не инициализирована сразу
c = 1            // Последующее присвоение
```

Изменяемые переменные объявляются с помощью ключевого слова `var`.
```kotlin
var x = 5 // Тип `Int` определен автоматически
x += 1
```

Вы можете объявлять глобальные переменные.
```kotlin
val PI = 3.14
var x = 0

fun incrementX() { 
    x += 1 
}
```

!!! example [Example](samples/02_Syntax/01_VariableDeclaration/src/Main.kt)
```kotlin
fun main() {
    // Неизменяемые (только для чтения)
    // локальные переменные определяются
    // с помощью ключевого слова val.
    // Присвоить им значение можно только один раз.
    val testC = 7
    println(testC) // => 7

    // testC = 9 // => Kotlin: Val cannot be reassigned

    // Изменяемые переменные объявляются
    // с помощью ключевого слова var.
    var testD = "строка символов"
    println(testD) // => строка символов

    testD = "новая строка символов"
    println(testD) // => новая строка символов
}
```

<details>
<summary>Output</summary>

```
7
строка символов
новая строка символов

Process finished with exit code 0
```

</details>

!!! error Error
```kotlin
testC = 9 // => Kotlin: Val cannot be reassigned
```

<details>
<summary>Output</summary>

```
Kotlin: Val cannot be reassigned

Process finished with exit code 0
```

</details>

### Основные типы
https://kotlinlang.ru/docs/basic-types.html

В Kotlin всё является объектом, в том смысле, что пользователь может вызвать функцию или получить доступ к свойству любой переменной. Некоторые типы являются встроенными, т.к. их реализация оптимизирована, хотя для пользователя они выглядят как обычные классы. В данном разделе описываются основные типы: числа, логические переменные, символы, строки и массивы.

#### Числа

##### Целочисленные типы
В Kotlin есть набор встроенных типов, которые представляют числа. Для целых чисел существует четыре типа с разными размерами и, следовательно, разными диапазонами значений.

| Тип |	Размер (биты) |	Минимальное значение |	Максимальное значение |
| --- | :--: | --: | -----------: |
| `Byte` |	8 |	-128 |	127 |
| `Short` |	16 |	-32768 |	32767 |
| `Int` |	32 |	-2,147,483,648 (-2^31^) |	2,147,483,647 (2^31^ - 1) |
| `Long` |	64 |	-9,223,372,036,854,775,808 (-2^63^) |	9,223,372,036,854,775,807 (2^63^ - 1) |

Все переменные, инициализированные целыми значениями, не превышающими максимальное значение `Int`, имеют предполагаемый тип `Int`. Если начальное значение превышает это значение, то тип `Long`. Чтобы явно указать тип `Long`, добавьте после значения `L`.
```kotlin
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1
```

!!! example [Example](samples/02_Syntax/06_IntegerTypes/src/Main.kt)
```kotlin
fun main() {
    var testByte: Byte = 120
    var testShort: Short = 32000
    var testInt: Int = 957_235_455
    var testLong: Long = 873_554_554_545_525
    var testLongTwo: Long = 934_347_523_555L
}

```

##### Типы с плавающей точкой
Для действительных чисел в Kotlin есть типы с плавающей точкой `Float` и `Double`. Согласно стандарту IEEE 754, типы с плавающей точкой различаются своим десятичным разрядом, то есть количеством десятичных цифр, которые они могут хранить. С точки зрения IEEE 754 `Float` является одинарно точным, а `Double` обеспечивает двойную точность.

| Тип    | Размер (биты) | Значимые биты | Биты экспоненты | Разряды |
| ------ | :-----------: | :-----------: | :-------------: | :-----: |
| `Float`  | 32            | 24            | 8               | 6-7     |
| `Double` | 64            | 53            | 11              | 15-16   |

Вы можете инициализировать переменные `Double` и `Float` числами, имеющими дробную часть. Она должна быть отделена от целой части точкой (`.`). Для переменных, инициализированных дробными числами, компилятор автоматически определяет тип `Double`.
```kotlin
val pi = 3.14 // Double
// val one: Double = 1 // Ошибка: несоответствие типов
val oneDouble = 1.0 // Double
```

Чтобы явно указать тип `Float`, добавьте после значения `f` или `F`. Если такое значение содержит более 6-7 разрядов, оно будет округлено.
```kotlin
val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float, фактическое значение 2.7182817
```

Обратите внимание, что в отличие от некоторых других языков, в Kotlin нет неявных преобразований для чисел. Например, функция с `Double` параметром может вызываться только для `Double`, но не для `Float`, `Int` или других числовых значений.
```kotlin
fun main() {
    fun printDouble(d: Double) { print(d) }

    val i = 1    
    val d = 1.0
    val f = 1.0f 

    printDouble(d)
//  printDouble(i) // Ошибка: несоответствие типов
//  printDouble(f) // Ошибка: несоответствие типов
}
```

Чтобы преобразовать числовые значения в различные типы, используйте [Явные преобразования](#явные-преобразования).


!!! example [Example](samples/02_Syntax/07_Floats/src/Main.kt)
```kotlin
fun main() {
    var testDouble: Double = 120.0
    // val one: Double = 1 // Ошибка: несоответствие типов
    // var testDoubleTwo: Double = 120 // => Kotlin: Initializer type mismatch: expected 'kotlin/Double', actual 'kotlin/Int'
    printDouble(testDouble) // => 120.0

    var testFloat: Float = 32000F
    // var testFloatTwo: Float = 32000.7 // => Kotlin: Initializer type mismatch: expected 'kotlin/Float', actual 'kotlin/Double'
    printDouble(testFloat) // => 32000.0

    val i = 1
    // printDouble(i) // Ошибка: несоответствие типов
}

fun printDouble(testPar: Float) {
    println(testPar)
}

fun printDouble(testPar: Double) {
    println(testPar)
}
```

<details>
<summary>Output</summary>

```
120.0
32000.0

Process finished with exit code 0

```

</details>

##### Представление чисел в JVM
Обычно платформа JVM хранит числа в виде примитивных типов: `int`, `double` и так далее. Если же вам необходима ссылка, которая может принимать значение `null` (например, `Int?`), то используйте обёртки. В этих случаях числа помещаются в Java классы как `Integer`, `Double` и так далее.

Обратите внимание, что использование обёрток для одного и того же числа не гарантирует равенства ссылок на них.
```kotlin
val a: Int = 100
val boxedA: Int? = a
val anotherBoxedA: Int? = a

val b: Int = 10000
val boxedB: Int? = b
val anotherBoxedB: Int? = b

println(boxedA === anotherBoxedA) // true
println(boxedB === anotherBoxedB) // false
```

Все nullable-ссылки на `a` на самом деле являются одним и тем же объектом из-за оптимизации памяти, которую JVM применяет к `Integer` между “-128” и “127”. Но `b` больше этих значений, поэтому ссылки на `b` являются разными объектами.

Однако, равенство по значению сохраняется.
```kotlin
val b: Int = 10000
println(b == b) // Prints 'true'
val boxedB: Int? = b
val anotherBoxedB: Int? = b
println(boxedB == anotherBoxedB) // Prints 'true'
```

##### Символьные постоянные
В языке Kotlin присутствуют следующие виды символьных постоянных (констант) для целых значений:

- Десятичные числа: `123`
  - Тип `Long` обозначается заглавной `L`: `123L`
- Шестнадцатеричные числа: `0x0F`
- Двоичные числа: `0b00001011`

> ВНИМАНИЕ: Восьмеричные литералы не поддерживаются.

Также Kotlin поддерживает числа с плавающей запятой:

- Тип `Double` по умолчанию: `123.5`, `123.5e10`
- Тип `Float` обозначается с помощью `f` или `F`: `123.5f`

Вы можете использовать нижние подчеркивания, чтобы сделать числовые константы более читаемыми:
```kotlin
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

!!! error [Error](samples/02_Syntax/08_NumericLiterals/src/Main.kt)
```kotlin
fun main() {
    var testInt = 123
    var testLong = 120L

    var testHex = 0x0F
    var testBinary = 0b00001011
    printDouble(testBinary) // => // Ошибка: несоответствие типов

    var testDoublePoint = 123.5
    var testDoubleE = 123.5e12

    var testFloat_f = 481.78f
    var testFloat_F = 346.49F

    val oneMillion = 1_000_000
    val creditCardNumber = 1234_5678_9012_3456L
    val socialSecurityNumber = 999_99_9999L
    val hexBytes = 0xFF_EC_DE_5E
    val bytes = 0b11010010_01101001_10010100_10010010
}

fun printDouble(testPar: Double) {
    println(testPar)
}
```

<details>
<summary>Output</summary>

```
Kotlin: Argument type mismatch: actual type is 'kotlin/Int' but 'kotlin/Double' was expected

```

</details>

##### Явные преобразования
Из-за разницы в представлениях меньшие типы не являются подтипами бОльших типов. В противном случае возникли бы сложности.
```kotlin
// Возможный код, который на самом деле не скомпилируется:
val a: Int? = 1 // "Обёрнутый" Int (java.lang.Integer)
val b: Long? = a // неявное преобразование возвращает "обёрнутый" Long (java.lang.Long)
print(b == a) // Внимание! Данное выражение выведет "false" т. к. метод equals() типа Long предполагает, что вторая часть выражения также имеет тип Long
```

Таким образом, будет утрачена не только тождественность (равенство по ссылке), но и равенство по значению.

Как следствие, неявное преобразование меньших типов в большие НЕ происходит. Это значит, что мы не можем присвоить значение типа `Byte` переменной типа `Int` без явного преобразования.
```kotlin
val b: Byte = 1 // всё хорошо, литералы проверяются статически
// val i: Int = b // ОШИБКА
val i1: Int = b.toInt()
```

Каждый численный тип поддерживает следующие преобразования:

- `toByte(): Byte`
- `toShort(): Short`
- `toInt(): Int`
- `toLong(): Long`
- `toFloat(): Float`
- `toDouble(): Double`
- `toChar(): Char`

Часто необходимости в явных преобразованиях нет, поскольку тип выводится из контекста, а арифметические действия перегружаются для подходящих преобразований.
```kotlin
val l = 1L + 3 // Long + Int => Long
```

!!! example [Example](samples/02_Syntax/09_ExplicitConversions/src/Main.kt)
```kotlin
fun main() {
    val testA = 1
    val testB: Byte = 1
    // println(testA == testB) // => Kotlin: Operator '==' cannot be applied to 'kotlin/Int' and 'kotlin/Byte'
    // val testD: Int = testB // => Kotlin: Initializer type mismatch: expected 'kotlin/Int', actual 'kotlin/Byte'

    val testH = testB.toInt()

    println(5 / 2)      // => 2
    println(5 / 2.0)    // => 2.5
    println(6.0 / 2.0)  // => 3.0

    val l = 1L + 3      // Long + Int => Long
    println(l)          // => 4
}
```

<details>
<summary>Output</summary>

```
2
2.5
3.0
4

Process finished with exit code 0

```

</details>

!!! error Error
```kotlin
fun main() {
    val testA = 1
    val testB: Byte = 1
    println(testA == testB)
}
```

<details>
<summary>Output</summary>

```
Kotlin: Operator '==' cannot be applied to 'kotlin/Int' and 'kotlin/Byte'

```

</details>

!!! error Error
```kotlin
fun main() {
    val testA = 1
    val testB: Byte = 1
    val testD: Int = testB // => Kotlin: Initializer type mismatch: expected 'kotlin/Int', actual 'kotlin/Byte'
}

```

<details>
<summary>Output</summary>

```
Kotlin: Initializer type mismatch: expected 'kotlin/Int', actual 'kotlin/Byte'

```

</details>

##### Арифметические операции
Котлин поддерживает стандартный набор арифметических операций над числами: `+`, `-`, `*`, `/`, `%`. Они объявляются членами соответствующих классов.
```kotlin
println(1 + 2)
println(2_500_000_000L - 1L)
println(3.14 * 2.71)
println(10.0 / 3)
```

Вы также можете переопределить эти операторы для пользовательских классов. См. [Перегрузка операторов](https://kotlinlang.ru/docs/operator-overloading.html) для деталей.

!!! example [Example](samples/02_Syntax/10_ArithmeticOperations/src/Main.kt)
```kotlin
fun main() {
    println(78 + 96)
    println(158 - 9)
    println(3.14 * 51)
    println(854 / 32)
    println(9 % 4)

    for (i in 2..9) {
        print("$i ")
    }
    println()
    println(2 in -3..9)
    println(-12 !in -3..9)
}
```

<details>
<summary>Output</summary>

```
174
149
160.14000000000001
26
1
2 3 4 5 6 7 8 9 
true
true

Process finished with exit code 0
```

</details>

###### Деление целых чисел
Деление целых чисел всегда возвращает целое число. Любая дробная часть отбрасывается.
```kotlin
val x = 5 / 2
// println(x == 2.5) // ОШИБКА: Оператор '==' не может быть применен к 'Int' и 'Double'
println(x == 2) // true
```

Это справедливо для деления любых двух целочисленных типов.
```kotlin
val x = 5L / 2
println(x == 2L) // true
```

Чтобы вернуть тип с плавающей точкой, явно преобразуйте один из аргументов в тип с плавающей точкой.
```kotlin
val x = 5 / 2.toDouble()
println(x == 2.5) // true
```

###### Побитовые операции
Kotlin поддерживает обычный набор *побитовых операций* над целыми числами. Они работают на двоичном уровне непосредственно с битовыми представлениями чисел. Побитовые операции представлены функциями, которые могут быть вызваны в инфиксной форме. Они могут быть применены только к `Int` и `Long`.
```kotlin
val x = (1 shl 2) and 0x000FF000
```

Ниже приведён полный список битовых операций:

- `shl(bits)` – сдвиг влево с учётом знака (`<<` в Java)
- `shr(bits)` – сдвиг вправо с учётом знака (`>>` в Java)
- `ushr(bits)` – сдвиг вправо без учёта знака (`>>>` в Java)
- `and(bits)` – побитовое И
- `or(bits)` – побитовое ИЛИ
- `xor(bits)` – побитовое исключающее ИЛИ
- `inv()` – побитовое отрицание

##### Сравнение чисел с плавающей точкой
В этом разделе обсуждаются следующие операции над числами с плавающей запятой:

- Проверки на равенство: `a == b` и `a != b`
- Операторы сравнения: `a < b`, `a > b`, `a <= b`, `a >= b`
- Создание диапазона и проверка диапазона: `a..b`, `x in a..b`, `x !in a..b`

Когда статически известно, что операнды `a` и `b` являются `Float` или `Double` или их аналогами с nullable-значением (тип объявлен или является результатом [умного приведения](https://kotlinlang.ru/docs/typecasts.html#smart-casts)), операции с числами и диапазоном, который они образуют, соответствуют стандарту [IEEE 754 для арифметики с плавающей точкой](https://en.wikipedia.org/wiki/IEEE_754).

Однако для поддержки общих вариантов использования и обеспечения полного упорядочивания, когда операнды статически *не* объявлены как числа с плавающей запятой (например, `Any`, `Comparable<...>`, параметр типа), операции используют реализации `equals` и `compareTo` для `Float` и `Double`, которые не согласуются со стандартом, так что:

- `NaN` считается равным самому себе
- `NaN` считается больше, чем любой другой элемент, включая “POSITIVE_INFINITY”
- `-0.0` считается меньше, чем `0.0`

##### Целые беззнаковые числа
В дополнение к [целочисленным типам](#целочисленные-типы), в Kotlin есть следующие типы целых беззнаковых чисел:

- `UByte`: беззнаковое 8-битное целое число, в диапазоне от 0 до 255
- `UShort`: беззнаковое 16-битное целое число, в диапазоне от 0 до 65535
- `UInt`: беззнаковое 32-битное целое число, в диапазоне от 0 до 2^32^ - 1
- `ULong`: беззнаковое 64-битное целое число, в диапазоне от 0 до 2^64^ - 1

Беззнаковые типы поддерживают большинство операций своих знаковых аналогов.

> Изменение типа с беззнакового типа на его знаковый аналог (и наоборот) является *двоично несовместимым* изменением.

###### Беззнаковые массивы и диапазоны
> Беззнаковые массивы и операции над ними находятся в стадии бета-тестирования. Они могут быть несовместимо изменены в любое время.

Как и в случае с примитивами, каждому типу без знака соответствует тип массивов знаковых типов:

- `UByteArray`: массив беззнаковых `byte`
- `UShortArray`: массив беззнаковых `short`
- `UIntArray`: массив беззнаковых `int`
- `ULongArray`: массив беззнаковых `long`

Как и целочисленные массивы со знаком, такие массивы предоставляют API, аналогичный классу `Array`, без дополнительных затрат на оборачивание.

При использовании массивов без знака вы получите предупреждение, что эта функция еще не стабильна. Чтобы удалить предупреждение используйте аннотацию `@ExperimentalUnsignedTypes`. Вам решать, должны ли ваши пользователи явно соглашаться на использование вашего API, но имейте в виду, что беззнаковый массив не является стабильной функцией, поэтому API, который он использует, может быть нарушен изменениями в языке.

[Диапазоны и прогрессии](#диапазоны-и-прогрессии) поддерживаются для `UInt` и `ULong` классами `UIntRange,UIntProgression`, `ULongRange` и `ULongProgression`. Вместе с целочисленными беззнаковыми типами эти классы стабильны.

###### Литералы
Чтобы целые беззнаковые числа было легче использовать, в Kotlin можно помечать целочисленный литерал суффиксом, указывающим на определенный беззнаковый тип (аналогично `Float` или `Long`):

- `u` и `U` помечают беззнаковые литералы. Точный тип определяется на основе ожидаемого типа. Если ожидаемый тип не указан, компилятор будет использовать `UInt` или `ULong` в зависимости от размера литерала.

  ```kotlin
  val b: UByte = 1u  // UByte, есть ожидаемый тип
  val s: UShort = 1u // UShort, есть ожидаемый тип
  val l: ULong = 1u  // ULong, есть ожидаемый тип

  val a1 = 42u // UInt: ожидаемого типа нет, константе подходит тип UInt
  val a2 = 0xFFFF_FFFF_FFFFu // ULong: ожидаемого типа нет, тип UInt не подходит константе
  ```

- `uL` и `UL` явно помечают литерал как `unsigned long`.

  ```kotlin
  val a = 1UL // ULong, даже несмотря на то, что ожидаемого типа нет и константа вписывается в UInt
  ```

#### Логический тип
Тип `Boolean` представляет логический тип данных и принимает два значения: `true` и `false`.

При необходимости использования nullable-ссылок логические переменные оборачиваются `Boolean?`.

Встроенные действия над логическими переменными включают:

- `||` – ленивое логическое ИЛИ
- `&&` – ленивое логическое И
- `!` – отрицание

```kotlin
val myTrue: Boolean = true
val myFalse: Boolean = false
val boolNull: Boolean? = null

println(myTrue || myFalse)
println(myTrue && myFalse)
println(!myTrue)
```

> В JVM: nullable-ссылки на логические объекты заключены в рамки аналогично числам.

!!! example [Example](samples/02_Syntax/11_LogicalOperations/src/Main.kt)
```kotlin
fun main() {
    val testTrue = true
    val testFalse = false
    val testNull: Boolean? = null

    println(testTrue && testFalse)
    println(testTrue || testFalse)
    println(!testTrue || testFalse)
    println(!testTrue || !testFalse)

    println(2 > 5 && 9 > 0)
}
```

<details>
<summary>Output</summary>

```
false
true
false
true
false

Process finished with exit code 0
```

</details>

#### Символы
Символы в Kotlin представлены типом `Char`. Символьные литералы заключаются в одинарные кавычки: `'1'`.

Специальные символы начинаются с обратного слеша `\.` Поддерживаются следующие escape-последовательности: `\t`, `\b`, `\n`, `\r`, `\'`, `\"`, `\\` и `\$`.

Для кодирования любого другого символа используйте синтаксис escape-последовательности Юникода: `'\uFF00'`.
```kotlin
val aChar: Char = 'a'

println(aChar)
println('\n') // выводит дополнительный символ новой строки
println('\uFF00')
```

Если значение символьной переменной – цифра, её можно явно преобразовать в `Int` с помощью функции `digitToInt()`.

> В JVM: Подобно числам, символы оборачиваются при необходимости использования nullable-ссылки. При использовании обёрток тождественность (равенство по ссылке) не сохраняется.

!!! example [Example](samples/02_Syntax/12_Symbols/src/Main.kt)
```kotlin
fun main() {
    val testChar = 'N'
    println(testChar)
    println("Новая строка\n")
    println("Еще одна новая строка")
    println()
    println("1\t2\t3\t4\t5")
    println('9'.digitToInt())
    // println("9".digitToInt()) // => Kotlin: Overload resolution ambiguity between candidates:
    println('\uFF00') // => ＀
}
```

<details>
<summary>Output</summary>

```
N
Новая строка

Еще одна новая строка

1	2	3	4	5
9
＀

Process finished with exit code 0
```

</details>

!!! error Error
```kotlin
println("9".digitToInt())
```

<details>
<summary>Output</summary>

```
Kotlin: Overload resolution ambiguity between candidates: [@InlineOnly() fun println(message: Any?): Unit, @InlineOnly() fun println(message: Boolean): Unit, @InlineOnly() fun println(message: Byte): Unit, ...]
```

</details>

#### Строки
Строки в Kotlin представлены типом `String`. Как правило, строка представляет собой последовательность символов в двойных кавычках (`"`).
```kotlin
val str = "abcd 123"
```

Строки состоят из символов, которые могут быть получены по порядковому номеру: `s[i]`. Проход по строке выполняется циклом `for`.
```kotlin
for (c in str) {
    println(c)
}
```

Строки являются неизменяемыми. После инициализации строки вы не можете изменить ее значение или присвоить ей новое. Все операции, преобразующие строки, возвращают новый объект `String`, оставляя исходную строку неизменной.
```kotlin
val str = "abcd"
println(str.uppercase()) // Создается и выводится новый объект String
println(str) // исходная строка остается прежней
```

Для объединения строк используется оператор `+`. Это работает и для объединения строк с другими типами, если первый элемент в выражении является строкой.
```kotlin
val s = "abc" + 1
println(s + "def") // abc1def
```

Обратите внимание, что в большинстве случаев использование [строковых шаблонов](#строковые-шаблоны) или обычных строк предпочтительнее объединения строк.

!!! example [Example](samples/02_Syntax/13_Strings/src/Main.kt)
```kotlin
fun main() {
    var testString = "Строка символов"
    println(testString.uppercase())
    println(testString)
    testString = testString.uppercase()
    val newTestString = testString.uppercase()
    println(newTestString)
    testString = "Измененное значение переменной"
    println(testString + "!!!")
    println("${testString.substring(5, 9)}")
}
```

<details>
<summary>Output</summary>

```
СТРОКА СИМВОЛОВ
Строка символов
СТРОКА СИМВОЛОВ
Измененное значение переменной!!!
енно

Process finished with exit code 0

```

</details>

##### Строковые литералы
В Kotlin представлены два типа строковых литералов:

- *экранированные* строки с экранированными символами
- *обычные* строки, которые могут содержать символы новой строки и произвольный текст

Вот пример экранированной строки:
```kotlin
val s = "Hello, world!\n"
```

Экранирование выполняется общепринятым способом, а именно с помощью обратного слеша (`\`). Список поддерживаемых escape-последовательностей см. в разделе [Символы](#символы) выше.

Обычная строка выделена тройной кавычкой (`"""`), не содержит экранированных символов, но может содержать символы новой строки и любые другие символы:
```kotlin
val text = """
  for (c in "foo")
    print(c)
"""
```

Чтобы удалить пробелы в начале обычных строк, используйте функцию [`trimMargin()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-margin.html).
```kotlin
val text = """
    |Tell me and I forget.
    |Teach me and I remember.
    |Involve me and I learn.
    |(Benjamin Franklin)
    """.trimMargin()
```

По умолчанию `|` используется в качестве префикса поля, но вы можете выбрать другой символ и передать его в качестве параметра, например, `trimMargin(">")`.

!!! example [Example](samples/02_Syntax/14_StringLiterals/src/Main.kt)
```kotlin
fun main() {
    val s = "Hello, world!\n"
    println("Regular escaped string: " + s)

    var text = """
        for (c in "foo"){
            print(c)
        }"""

    println(text + "\n")
    println(text.trimIndent() + "\n")

    text = """
    |Tell me and I forget.
    |Teach me and I remember.
    |Involve me and I learn.
    |(Benjamin Franklin)
    """.trimMargin()
    println(text)
}

```

<details>
<summary>Output</summary>

```
Regular escaped string: Hello, world!


        for (c in "foo"){
            print(c)
        }

for (c in "foo"){
    print(c)
}

Tell me and I forget.
Teach me and I remember.
Involve me and I learn.
(Benjamin Franklin)

Process finished with exit code 0

```

</details>

##### Строковые шаблоны
Строки могут содержать *шаблонные* выражения, т.е. участки кода, которые выполняются, а полученный результат встраивается в строку. Шаблон начинается со знака доллара (`$`) и состоит либо из простого имени (например, переменной),
```kotlin
val i = 10
println("i = $i") // выведет "i = 10"
```

либо из произвольного выражения в фигурных скобках.
```kotlin
val s = "abc"
println("$s.length is ${s.length}") // выведет "abc.length is 3"
```

Шаблоны поддерживаются как в обычных, так и в экранированных строках. При необходимости вставить символ `$` в обычную строку (такие строки не поддерживают экранирование обратным слешом) перед любым символом, который разрешен в качестве начала идентификатора, используйте следующий синтаксис:
```kotlin
val price = """
${'$'}_9.99
"""
```

#### Массивы
Массивы в Kotlin представлены классом `Array`, обладающим функциями `get` и `set` (которые обозначаются `[]` согласно соглашению о перегрузке операторов), и свойством `size`, а также несколькими полезными встроенными функциями.
```kotlin
class Array<T> private constructor() {
    val size: Int
    operator fun get(index: Int): T
    operator fun set(index: Int, value: T): Unit

    operator fun iterator(): Iterator<T>
    // ...
}
```

Для создания массива используйте функцию `arrayOf()`, которой в качестве аргумента передаются элементы массива, т.е. выполнение `arrayOf(1, 2, 3)` создаёт массив `[1, 2, 3]`. С другой стороны функция `arrayOfNulls()` может быть использована для создания массива заданного размера, заполненного значениями `null`.

Также для создания массива можно использовать фабричную функцию, которая принимает размер массива и функцию, возвращающую начальное значение каждого элемента по его индексу.
```kotlin
// создаёт массив типа Array<String> со значениями ["0", "1", "4", "9", "16"]
val asc = Array(5) { i -> (i * i).toString() }
asc.forEach { println(it) }
```

Как отмечено выше, оператор `[]` используется вместо вызовов встроенных функций `get()` и `set()`.

Обратите внимание: в отличие от Java массивы в Kotlin являются *инвариантными*. Это значит, что Kotlin запрещает нам присваивать массив `Array<String>` переменной типа `Array<Any>`, предотвращая таким образом возможный отказ во время исполнения (хотя вы можете использовать `Array<out Any>`, см. [Проекции типов](https://kotlinlang.ru/docs/generics.html#type-projections)).

!!! example [Example](samples/02_Syntax/15_Arrays/src/Main.kt)
```kotlin
fun main() {
    var testArray = arrayOf("1", 2, true)
    testArray.forEach { print(it.toString() + "\t") }
    println("\n")
    val testArrayNum = Array(5) { i -> (i * i).toString() }
    testArrayNum.forEach { println(it) }
    println(testArrayNum.get(3))
    testArrayNum.set(0, "99")
    testArrayNum.forEach { print(it + "\t") }
}
```

<details>
<summary>Output</summary>

```
1	2	true	

0
1
4
9
16
9
99	1	4	9	16	
Process finished with exit code 0

```

</details>

##### Массивы примитивных типов
Также в Kotlin есть особые классы для представления массивов примитивных типов без дополнительных затрат на оборачивание: `ByteArray`, `ShortArray`, `IntArray` и т.д. Данные классы не наследуют класс `Array`, хотя и обладают тем же набором методов и свойств. У каждого из них есть соответствующая фабричная функция:
```kotlin
val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2]
```

```kotlin
// int массив, размером 5 со значениями [0, 0, 0, 0, 0]
val arr = IntArray(5)

// инициализация элементов массива константой
// int массив, размером 5 со значениями [42, 42, 42, 42, 42]
val arr = IntArray(5) { 42 }

// инициализация элементов массива лямбда-выражением
// int массив, размером 5 со значениями [0, 1, 2, 3, 4] (элементы инициализированы своим индексом)
var arr = IntArray(5) { it * 1 }
```

!!! example [Example](samples/02_Syntax/16_PrimitivesArrays/src/Main.kt)
```kotlin
import kotlin.math.pow

fun main() {
    val testArrayInt: IntArray = intArrayOf(1, 2, 3)
    testArrayInt[0] = testArrayInt[1] + testArrayInt[2]
    testArrayInt.forEach { print(it.toString() + "\t") }
    println()
    val testArrayInit = IntArray(5)
    testArrayInit.forEach { print(it.toString() + "\t ") }
    println()
    val testArrayConst = IntArray(5) { 79 }
    testArrayConst.forEach { print(it.toString() + "\t ") }
    println()
    var testArrayLambda = DoubleArray(9) { 2.0.pow(it) }
    testArrayLambda.forEach { print(it.toString() + "\t ") }
    println()
}
```

<details>
<summary>Output</summary>

```
5	2	3	
0	 0	 0	 0	 0	 
79	 79	 79	 79	 79	 
1.0	 2.0	 4.0	 8.0	 16.0	 32.0	 64.0	 128.0	 256.0	 

Process finished with exit code 0

```

</details>

### Условия и циклы
https://kotlinlang.ru/docs/control-flow.html

#### Условное выражение `if`
В языке Kotlin `if` является выражением, т.е. оно возвращает значение. Это позволяет отказаться от тернарного оператора (`условие ? условие истинно : условие ложно`), потому что обычному `if` вполне по силам его заменить.
```kotlin
// обычное использование
var max = a
if (a < b) max = b

// с блоком else
var max: Int
if (a > b) {
    max = a
} else {
    max = b
}

// в виде выражения
val max = if (a > b) a else b
```

“Ветви” выражения `if` могут быть блоками, т.е. содержать несколько строк кода, при этом последнее выражение является значением блока:
```kotlin
val max = if (a > b) {
    print("возвращаем a")
    a
} else {
    print("возвращаем b")
    b
}
```

Если вы используете `if` в качестве выражения (например, возвращая его значение или присваивая его переменной), то использование ветки `else` является обязательным.

!!! example [Example](samples/02_Syntax/17_If/src/Main.kt)
```kotlin
fun main() {
    var testMax = 5
    val testNew = (0..9).random()
    println("testNew: $testNew")
    if (testMax < testNew) testMax = testNew
    println(testMax)

    val testOne = (10..19).random()
    val testTwo = (10..19).random()
    println("testOne: $testOne, testTwo: $testTwo")

    if (testOne > testTwo) {
        println(testOne)
    } else {
        println(testTwo)
    }

    val testPrint = if (testOne > testTwo) {
        print("Возвращаем testOne - ")
        testOne
    } else {
        print("Возвращаем testTwo - ")
        testTwo
    }

    println(testPrint)
}
```

<details>
<summary>Output</summary>

```
testNew: 7
7
testOne: 17, testTwo: 13
17
Возвращаем testOne - 17

Process finished with exit code 0

```

</details>

#### Условное выражение `when`
`when` определяет условное выражение с несколькими “ветвями”. Оно похоже на оператор `switch`, присутствующий в C-подобных языках.
```kotlin
when (x) {
    1 -> print("x == 1")
    2 -> print("x == 2")
    else -> { // обратите внимание на блок
        print("x не равен ни 1, ни 2")
    }
}
```

`when` последовательно сравнивает свой аргумент со всеми указанными значениями, пока не выполнится какое-либо из условий ветвей.

`when` можно использовать и как выражение, и как оператор. При использовании его в виде выражения значение первой ветки, удовлетворяющей условию, становится значением всего выражения. При использовании в виде оператора значения отдельных веток отбрасываются. В точности как `if`: каждая ветвь может быть блоком и её значением является значение последнего выражения блока.

Значение ветки `else` вычисляется в том случае, когда ни одно из условий в других ветках не удовлетворено.

Если when используется как *выражение*, то ветка else является обязательной, за исключением случаев, в которых компилятор может убедиться, что ветки покрывают все возможные значения. Так происходит, например с записями [класса `enum`](https://kotlinlang.ru/docs/enum-classes.html) и с подтипами [`sealed` (изолированных) классов](https://kotlinlang.ru/docs/sealed-classes.html).
```kotlin
enum class Bit {
  ZERO, ONE
}
val numericValue = when (getRandomBit()) {
    Bit.ZERO -> 0
    Bit.ONE -> 1
    // 'else' не требуется, потому что все случаи учтены
}
```

В *операторах* `when` ветка `else` является обязательной в следующих условиях:

- `when` имеет объект типа `Boolean`, `enum`, `sealed` или их nullable-аналоги;
- ветки `when` не охватывают все возможные случаи для этого объекта.

```kotlin
enum class Color {
    RED, GREEN, BLUE
}

when (getColor()) {
    Color.RED -> println("red")
    Color.GREEN -> println("green")
    Color.BLUE -> println("blue")
    // 'else' не требуется, потому что все случаи учтены
}

when (getColor()) {
    Color.RED -> println("red") // нет веток для GREEN и BLUE
    else -> println("not red") // 'else' обязателен
}
```

Если для нескольких значений выполняется одно и то же действие, то условия можно перечислять в одной ветке через запятую.
```kotlin
when (x) {
    0, 1 -> print("x == 0 or x == 1")
    else -> print("otherwise")
}
```

Помимо констант в ветках можно использовать произвольные выражения.
```kotlin
when (x) {
    s.toInt() -> print("s encodes x")
    else -> print("s does not encode x")
}
```

Также можно проверять вхождение аргумента в [интервал](#диапазоны-и-прогрессии) `in` или `!in` или его наличие в коллекции:
```kotlin
when (x) {
    in 1..10 -> print("x is in the range")
    in validNumbers -> print("x is valid")
    !in 10..20 -> print("x is outside the range")
    else -> print("none of the above")
}
```

Помимо этого Kotlin позволяет с помощью `is` или `!is` проверить тип аргумента. Обратите внимание, что благодаря [умным приведениям](https://kotlinlang.ru/docs/typecasts.html#smart-casts) вы можете получить доступ к методам и свойствам типа без дополнительной проверки.
```kotlin
fun hasPrefix(x: Any) = when(x) {
    is String -> x.startsWith("prefix")
    else -> false
}
```

`when` удобно использовать вместо цепочки условий вида `if`-`else if`. При отсутствии аргумента условия работают как простые логические выражения, а тело ветки выполняется при его истинности.
```kotlin
when {
    x.isOdd() -> print("x is odd")
    y.isEven() -> print("y is even")
    else -> print("x+y is odd")
}
```

Можно получать переменную внутри `when` условия по следующему синтаксису:
```kotlin
fun Request.getBody() =
    when (val response = executeRequest()) {
        is Success -> response.body
        is HttpError -> throw HttpException(response.status)
    }
```

Такая переменная, объявленная внутри условия `when` может быть видна только внутри тела этого `when`.

!!! example [Example](samples/02_Syntax/18_When/src/Main.kt)
```kotlin
fun main() {
    val testRandom = (1..9).random()
    println("testRandom: $testRandom")
    when (testRandom) {
        1 -> println("testRandom == 1")
        2, 4, 6, 8 -> println("testRandom == 2 или 4 или 6 или 8")
        else -> { // обратите внимание на блок
            println("testRandom не равен 1 и не кратно 2")
        }
    }
    val testArrayInt = IntArray(10) { it }
    val testRandomNew = (1..30).random()
    println("testRandomNew: $testRandomNew")
    when (testRandomNew) {
        in 10..20 -> println("Значение в промежутке от 10 до 20")
        in testArrayInt -> println("Значение попадает в массив с числами от 0 до 9")
        !in 21..25 -> println("Значение больше 25")
        else -> println("Значение в промежутке от 21 до 25")
    }
    val testRem = when(testRandomNew) {
        in 1..15 -> testRandomNew
        else -> "Значение больше 15"
    }
    println(testRem)
}
```

<details>
<summary>Output</summary>

```
testRandom: 6
testRandom == 2 или 4 или 6 или 8
testRandomNew: 4
Значение попадает в массив с числами от 0 до 9
4

Process finished with exit code 0

```

</details>

#### Цикл `for`
Цикл `for` обеспечивает перебор всех значений, поставляемых итератором. Он эквивалентен циклу `foreach` в таких языках, как C#.
```kotlin
for (item in collection) print(item)
```

Телом цикла может быть блок кода.
```kotlin
for (item: Int in ints) {
    // ...
}
```

Как отмечено выше, цикл `for` позволяет проходить по всем элементам объекта, имеющего итератор, например:

- обладающего внутренней или внешней функцией `iterator()`, возвращаемый тип которой `Iterator<>`:
  - обладает внутренней или внешней функцией `next()`
  - обладает внутренней или внешней функцией `hasNext()`, возвращающей `Boolean`.

Все три указанные функции должны быть объявлены как `operator`.

Чтобы перебрать диапазон чисел, используйте выражение диапазона:
```kotlin
for (i in 1..3) {
    println(i)
}
for (i in 6 downTo 0 step 2) {
    println(i)
}
```

Цикл `for` по диапазону или массиву компилируется в основанный на индексе цикл, который не создает объект итератора.

Если при проходе по массиву или списку необходим порядковый номер элемента, используйте следующий подход:
```kotlin
for (i in array.indices) {
    println(array[i])
}
```

Также вы можете использовать библиотечную функцию `withIndex`.
```kotlin
for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}
```

!!! example [Example](samples/02_Syntax/20_For/src/Main.kt)
```kotlin
fun main() {
    val testArrayInt = IntArray(5) { it * 5 }

    for (item in testArrayInt) print(item.toString() + "\t")
    println()
    for (item in testArrayInt) {
        if (item % 3 == 0) {
            print("кратно\t")
        } else {
            print("некратно\t")
        }
    }
    println()
    for ((index, value) in testArrayInt.withIndex()) {
        println("Индекс - $index. Значение - $value")
    }
}
```

<details>
<summary>Output</summary>

```
0	5	10	15	20
кратно	некратно	некратно	кратно	некратно
Индекс - 0. Значение - 0
Индекс - 1. Значение - 5
Индекс - 2. Значение - 10
Индекс - 3. Значение - 15
Индекс - 4. Значение - 20

Process finished with exit code 0
```

</details>

#### Цикл `while`
Тело циклов `while` и `do-while` выполняется до тех пор, пока их условие выполняется. Разница между ними заключается во времени проверки условия:

- `while` проверяет условие и, если оно истинно, выполняет тело, а затем возвращается к проверке условия;
- `do-while` выполняет тело и только затем проверяет условие. Если оно выполняется, цикл повторяется. Таким образом, тело `do-while` выполняется по крайней мере один раз независимо от условия.
```kotlin
while (x > 0) {
    x--
}

do {
    val y = retrieveData()
} while (y != null) // y здесь доступно!
```

!!! example [Example](samples/02_Syntax/19_While/src/Main.kt)
```kotlin
fun main() {
    val testSize = (1..10).random()
    var testArr = IntArray(testSize)

    var i = 0
    while (i < testSize) {
        testArr[i] = (20..50).random()
        i++
    }
    testArr.forEach { print(it.toString() + "\t") }
    println()
    var j = 0
    do {
        testArr[j] = (20..50).random()
        j++
    } while (j < testSize)
    testArr.forEach { print(it.toString() + "\t") }
}
```

<details>
<summary>Output</summary>

```
21	40	40	28
45	21	50	48
Process finished with exit code 0

```

</details>

#### Break и continue в циклах
Kotlin поддерживает привычные операторы `break` и `continue` в циклах. См. [Операторы перехода](#операторы-перехода).

### Операторы перехода
https://kotlinlang.ru/docs/returns.html

В Kotlin определено три оператора перехода:

- `return` по умолчанию производит возврат из ближайшей окружающей его функции или анонимной функции;
- `break` завершает выполнение ближайшего окружающего его цикла;
- `continue` продолжает выполнение цикла со следующего его шага, без обработки оставшегося кода текущей итерации.

Все эти выражения можно использовать как часть более крупных выражений:
```kotlin
val s = person.name ?: return
```

Эти выражения имеют тип `Nothing`.

#### Метки операторов break и continue
Любое выражение в Kotlin может быть помечено меткой *label*. Метки имеют форму идентификатора, за которым следует знак `@`, например `abc@` или `fooBar@`. Для того чтобы пометить выражение, мы просто ставим метку перед ним.
```kotlin
loop@ for (i in 1..100) {
    // ...
}
```

Теперь мы можем уточнить значения операторов `break` или `continue` с помощью меток.
```kotlin
loop@ for (i in 1..100) {
    for (j in 1..100) {
        if (...) break@loop
    }
}
```

Оператор `break`, отмеченный `@loop`, переводит выполнение кода в точку сразу после цикла, отмеченного этой меткой. Оператор `continue` продолжает цикл со следующей его итерации.

#### Возврат к меткам
В Kotlin функции могут быть вложены друг в друга с помощью литералов функций, локальных функций и анонимных объектов. Подходящий `return` позволит вернуться из внешней функции. Одним из самых важных применений этой синтаксической конструкции является возврат из лямбда-выражения. Напомним, что в таких случаях, как в примере ниже, `return` возвращает из ближайшей заключающей функции — `foo`:
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return // нелокальный возврат, непосредственно к объекту вызывающему функцию foo()
        print(it)
    }
    println("эта строка не достижима")
}
```

Обратите внимание, что такой нелокальный возврат поддерживается только лямбда-выражениями, переданными [инлайн-функциям](https://kotlinlang.ru/docs/inline-functions.html). Чтобы вернуться из лямбда-выражения, к оператору стоит поставить метку и тем самым сделать уточнение для `return`.
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // локальный возврат внутри лямбды, то есть к циклу forEach
        print(it)
    }
    print(" выполнится с использованием явной метки(lit@)")
}
```

Теперь он возвращает только из лямбда-выражения. Зачастую намного более удобно использовать *неявные метки*, потому что такие метки имеют такое же имя, как и функция, к которой относится лямбда.
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return@forEach // локальный возврат внутри лямбды, то есть к циклу forEach
        print(it)
    }
    print(" выполнится с использованием неявной метки(forEach@)")
}
```

Возможно также использование [анонимной функции](https://kotlinlang.ru/docs/lambdas.html#anonymous-functions) в качестве альтернативы лямбда-выражениям. Оператор `return` возвращает из самой анонимной функции.

```
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {
        if (value == 3) return  // локальный возврат внутри анонимной функции, то есть к циклу forEach
        print(value)
    })
    print(" выполнится с использованием анонимной функции")
}

```

Обратите внимание, что использование локальных возвратов в предыдущих трех примерах аналогично использованию `continue` в обычных циклах.

Прямого эквивалента для `break` не существует, но его можно смоделировать — добавить еще одну вложенную лямбду и нелокально вернуться из нее.
```kotlin
fun foo() {
    run loop@{
        listOf(1, 2, 3, 4, 5).forEach {
            if (it == 3) return@loop // нелокальный возврат из лямбды к вызывающему run
            print(it)
        }
    }
    print(" выполнится с использованием вложенной метки")
}
```

При возвращении значения парсер отдаёт предпочтение специализированному возврату.
```kotlin
return@a 1
```

что значит “верни `1` в метке `@a`”, а не “верни выражение с меткой `(@a 1)`”.

### Диапазоны и прогрессии
https://kotlinlang.ru/docs/ranges.html

Kotlin позволяет легко создавать диапазоны значений с помощью функции `rangeTo()`, которая находится в пакете `kotlin.ranges`. У функции есть операторная форма — `..`. Обычно `rangeTo()` используется совместно с функциями `in` или `!in`.
```kotlin
if (i in 1..4) {  // эквивалентная запись 1 <= i && i <= 4
    print(i)
}
```
У диапазонов целочисленных типов (`IntRange`, `LongRange`, `CharRange`) есть дополнительная функция: они поддерживают итерацию. Эти диапазоны также являются [прогрессиями](https://en.wikipedia.org/wiki/Arithmetic_progression).

Подобные диапазоны, как правило, используются в цикле `for`.
```kotlin
fun main() {
    for (i in 1..4) print(i) // 1234
}
```

Для перебора чисел в обратном порядке используйте функцию `downTo` вместо `..`.
```kotlin
fun main() {
    for (i in 4 downTo 1) print(i) // 4321
}
```

Можно перебирать числа с произвольным шагом. Осуществляется это с помощью функции `step`.
```kotlin
fun main() {
    for (i in 1..8 step 2) print(i) // 1357
    println()
    for (i in 8 downTo 1 step 2) print(i) // 8642
}
```

Если требуется перебрать диапазон чисел, исключая его последний элемент, то используйте функцию `until`.
```kotlin
fun main() {
    for (i in 1 until 10) { // i in [1, 10), 10 будет исключён
        print(i) // 123456789
    }
}
```

#### Диапазоны
В математическом смысле <dfn title="диапазон">диапазон</dfn> — это закрытый интервал: он определяется двумя значениями и они оба являются частью диапазона. Диапазоны применимы к сопоставимым (*comparable*) типам: имея порядок, вы можете определить, находится ли произвольный экземпляр в диапазоне между двумя заданными экземплярами.

Основная операция с диапазонами — это `contains`, которая обычно используется в форме операторов `in` и `!in`.

Чтобы создать диапазон на основе ваших классов, вызовите функцию `rangeTo()` для начального значения диапазона и укажите конечное значение в качестве аргумента. Чаще всего используется операторная форма функции `rangeTo()` — `..`.
```kotlin
class Version(val major: Int, val minor: Int): Comparable<Version> {
    override fun compareTo(other: Version): Int {
        if (this.major != other.major) {
            return this.major - other.major
        }
        return this.minor - other.minor
    }
}

fun main() {
    val versionRange = Version(1, 11)..Version(1, 30)
    println(Version(0, 9) in versionRange) // false
    println(Version(1, 20) in versionRange) // true
}
```

#### Прогрессии
Как показано в приведённых выше примерах, диапазоны целочисленных типов, таких как `Int`, `Long` и `Char`, можно рассматривать как [арифметические прогрессии](https://en.wikipedia.org/wiki/Arithmetic_progression). В Kotlin есть специальные типы для определения таких прогрессий: `IntProgression`, `LongProgression` и `CharProgression`.

У прогрессий есть три основных свойства: `first`, `last` и `step`, при этом `step` не может быть нулём. `first` — это первый элемент. Последующие элементы — это предыдущий элемент плюс `step`. Итерация по прогрессии с положительным шагом (`step`) эквивалентна индексируемому циклу `for` в Java / JavaScript.
```kotlin
for (int i = first; i <= last; i += step) {
  // ...
}
```
При неявном создании прогрессии путём итерации диапазона, элементы `first` и `last` этой прогрессии являются конечными точками диапазона, а `step` равен 1.
```kotlin
fun main() {
    for (i in 1..10) print(i) // 12345678910
}
```

Чтобы прогрессии задать собственный шаг, используйте функцию `step`.
```kotlin
fun main() {
    for (i in 1..8 step 2) print(i) // 1357
}
```

Последний элемент прогрессии (`last`) рассчитывается следующим образом: * Для положительного шага: максимальное значение, но не больше конечного значения — `(last - first) % step == 0`. * Для отрицательного шага: минимальное значение, но не меньше конечного значения — `(last - first) % step == 0`.

Таким образом, элемент `last` не всегда совпадает с конечным значением диапазона.
```kotlin
fun main() {
    for (i in 1..9 step 3) print(i) // 147, last = 7
}
```

Чтобы создать прогрессию для итерации в обратном направлении, при определении диапазона используйте `downTo` вместо `..`.
```kotlin
fun main() {
    for (i in 4 downTo 1) print(i) // 4321
}
```

Прогрессии реализуют интерфейс `Iterable<N>`, где `N` — это `Int`, `Long` или `Char`, поэтому вы можете использовать их в различных [функциях коллекций](https://kotlinlang.ru/docs/collection-operations.html), таких как map, filter и т. д.
```kotlin
fun main() {
    println((1..10).filter { it % 2 == 0 }) // [2, 4, 6, 8, 10]
}
```

!!! example [Example](./samples/02_Syntax/21_Ranges/src/Main.kt)
```kotlin
fun main() {
    for (i in 1..10) print(i.toString() + "\t")
    println()

    for (i in 1 until 10) print(i.toString() + "\t")
    println()

    for (i in 10 downTo 1) print(i.toString() + "\t")
    println()

    for (i in 1..10 step 3) print(i.toString() + "\t")
    println()
}
```

<details>
<summary>Output</summary>

```
1	2	3	4	5	6	7	8	9	10
1	2	3	4	5	6	7	8	9
10	9	8	7	6	5	4	3	2	1
1	4	7	10

Process finished with exit code 0

```

</details>

### Основы - задачи
[66f12d265040133e8429e1c4](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345142)

Во всех приведенных ниже задачах предусмотреть возможные ошибки пользователей при вводе данных и осуществить их обработку. Например, в задаче 4 пользователь может ввести не только числа. Или их будет больше двух, или же символов операции будет более одного.

Также, во всех задачах, пользователь должен получать подсказку, что ему необходимо ввести или сделать. То есть для задачи 5 в консоли должно быть примерно следующее (см. рис.)

1. Задача 1.

    Создать приложение, которое подсчитывает количество подряд идущих одинаковых символов во введенной строке. На вход подается, например, строка `AAADSSSRRTTHAAAA`. На выходе получаем `A3DS3R2T2HA4`. То есть, если количество подряд идущих символов меньше двух, то мы не пишем единицу

2. Задача 2.

    Создать приложение, которое подсчитывает количество различных символов во введенной строке. Символы в ответе расположить в алфавитном порядке. Например, дана строка `AASADDSS`. На выходе получаем:
    ```
    A - 3
    D - 2
    S - 3
    ```

3. Задача 3.

    Создать приложение, которое преобразует введенное пользователем натуральное число из 10-ичной системы в двоичную.

4. Задача 4.

    Создать приложение, с помощью которого пользователь, введя два числа и символ операции, узнает результат. Символами операции могут быть: `/` — деление, `*` — умножение, `+` — сложение, `-` — вычитание. Числа могут быть вещественными. Числа и знак операции разделяются между собой одним пробелом. Ввод производится в формате — `ЧИСЛО1 ЧИСЛО2 ОПЕРАЦИЯ`

5. Задача 5.

    Создать приложение, с помощью которого пользователь, введя целое число $n$ и основание степени $x$ узнает, существует ли целочисленный показатель степени $y$ для которого выполняется равенство $x^y = n$. В случае, если показатель существует – вычислить его и вывести. В противном случае вывести текст – «Целочисленный показатель не существует».

6. Задача 6.

    Создать приложение, в котором пользователь вводит две различных цифры. На выходе приложение выдает, если это возможно, из введенных цифр, нечетное число. Результат выводится в консоль. При невозможности создать нечетное число выводится сообщение – «Создать нечетное число невозможно». Каждое число вводится на отдельной строке

Решение предоставить в виде ссылки на GitHub.

## 03 Массивы, коллекции
[66f429275040133e8429e1fb](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-3)

### Массивы
Массивы в Kotlin представлены классом `Array`, обладающим функциями `get` и `set` (которые обозначаются `[]` согласно соглашению о перегрузке операторов), и свойством `size`, а также несколькими полезными встроенными функциями.
```kotlin
class Array<T> private constructor() {
    val size: Int
    operator fun get(index: Int): T
    operator fun set(index: Int, value: T): Unit

    operator fun iterator(): Iterator<T>
    // ...
}
```

Как отмечено выше, оператор `[]` используется вместо вызовов встроенных функций `get()` и `set()`.

Обратите внимание: в отличие от Java массивы в Kotlin являются *инвариантными*. Это значит, что Kotlin запрещает нам присваивать массив `Array<String>` переменной типа `Array<Any>`, предотвращая таким образом возможный отказ во время исполнения (хотя вы можете использовать `Array<out Any>`, см. [Проекции типов](https://kotlinlang.ru/docs/generics.html#type-projections)).

!!! example [Example](samples/02_Syntax/15_Arrays/src/Main.kt)
```kotlin
fun main() {
    var testArray = arrayOf("1", 2, true)
    testArray.forEach { print(it.toString() + "\t") }
    println("\n")
    val testArrayNum = Array(5) { i -> (i * i).toString() }
    testArrayNum.forEach { println(it) }
    println(testArrayNum.get(3))
    testArrayNum.set(0, "99")
    testArrayNum.forEach { print(it + "\t") }
}
```

Массив можно создать двумя способами — через конструктор `Array()` или через методы `arrayOf()`, `arrayOfNulls()`, `emptyArray()`.

#### Объявление массива с использованием библиотечного метода `arrayOf()`
Для создания массива используйте функцию `arrayOf()`, которой в качестве аргумента передаются элементы массива, т.е. выполнение `arrayOf(1, 2, 3)` создаёт массив `[1, 2, 3]`.

Создадим массив и получим значение третьего элемента.
```kotlin
val myArray = arrayOf(1, 2, 3, 4, 5)
println(myArray[2])
```

Узнать длину массива можно при помощи свойства .
```kotlin**`size`**
println(myArray.size) // 5
```

А что случится, если мы добавим в массив строки?

```kotlin
val myArray = arrayOf(1, 2, 3, 4, 5, "зайчик", "вышел", "погулять")
println(myArray[5])
```

Ничего страшного, у нас получился массив смешанного типа. Всё работает, ничего не ломается.

Если мы хотим строгого поведения и не хотим смешивать разные типы, то используем обобщения.

```kotlin
val myArray = arrayOf<Int>(1, 2, 3, 4, 5) // только числа Integer
```

Таким образом, в Kotlin имеются "классические" массивы, когда в одном массиве могут быть данные только одного типа, и в массив нельзя добавлять элементы, как в список.[^younglinux]

[^younglinux]: [Массивы в Kotlin](https://younglinux.info/kotlin/array)

Объявление массива в Kotlin:
```kotlin
val имя: Array<тип>
```

Массивы обычно объявляют с помощью `val`, но это не значит, что нельзя изменять значения элементов массива. Это лишь значит, что неизменяемой переменной нельзя присвоить другой массив. Однако необходимость в подобном действии возникает редко.

Существует также синонимы метода, когда уже в имени содержится подсказка: `intArrayOf()`, `charArrayOf()`, `booleanArrayOf()`, `longArrayOf()`, `shortArrayOf()`, `byteArrayOf()`.

Перепишем пример.

```kotlin
val myArray = intArrayOf(1, 2, 3, 4, 5)
```

Пройтись по элементам массива и узнать значение индекса можно с помощью метода **`withIndex()`**:

```kotlin
val numbersArray = intArrayOf(1, 2, 3, 4, 5)
for ((index, value) in numbersArray.withIndex()) {
    println("Значение индекса $index равно $value")
}
```

!!! example [Example](./samples/03_Arrays/01_ArrayOf/src/Main.kt)
```kotlin
fun main() {
    val arrNum: Array<Int>
    arrNum = arrayOf(12, 25, 37, 84, 95)    // преобразует перечисляемые значения в целочисленный массив

    val arrTest = arrayOf(4,7, 9.65, 7.82)  // получаем массив указанного типа
    val arrD: Array<Double> = arrayOf(65.98, 32.81, 83.96, 73.65)

    val testN = arrNum[1]                   // присваиваем значение
    val testU = arrNum.get(4)               // элементу массива

    arrNum[0] = 56                          // получаем значение
    arrNum.set(3, 97)                       // элемента массива
}
```

<details>
<summary><em>Output</em></summary>

```
1	2	true

0
1
4
9
16
9
99	1	4	9	16

```

</details>

#### Свойство `indices`
https://developer.alexanderklimov.ru/android/kotlin/array.php

У массива есть свойство **`indices`** и мы можем переписать пример по другому.

```kotlin
val numbers = intArrayOf(1, 2, 3, 4, 5)
for (index in numbers.indices) {
    println("Значение индекса $index равно ${numbers[index]}")
}
```

Свойство возвращает интервал (`Range`), который содержит все индексы массива. Это позволяет не выйти за пределы массива и избежать ошибки `ArrayIndexOutOfBoundsException`.

Но у свойства есть очень интересная особенность. Взгляните на код:

```kotlin
val numbers = intArrayOf(1, 2, 3, 4, 5)
for(index in numbers.indices - 2) {
    println(numbers[index])
}

// 1 2 4 5
```

Из интервала индексов массива мы убрали третий элемент (отсчёт от 0). И теперь при выводе элементов массива мы не увидим числа 3.

Можно сложить два массива.

```kotlin
val numbers = intArrayOf(1, 2, 3)
val numbers3 = intArrayOf(4, 5, 6)
val foo2 = numbers3 + numbers
println(foo2[5]) // 3
```

#### Объявление массива неустановленных ("пустых"/"нулевых") значений и его инициализация (`arrayOfNulls()`)
Для создания массива заданного размера, заполненного значениями `null`, можно использовать отдельную функцию `arrayOfNulls()`.

```kotlin
val array = arrayOfNulls<Number>(5)
```

Создадим массив с тремя элементами.

```kotlin
val array = arrayOfNulls(3) // [null, null, null]
// равносильно
// arrayOf(null, null, null)
```

Присвоим значения пустым элементам.

```kotlin
var arr2 = arrayOfNulls<String>(2)
arr2.set(0, "1")
arr2.set(1, "2")

// или
arr2[0] = "1"
arr2[1] = "2"

// получить значения
println(arr2[0]) // или arr2.get(0)
println(arr2[1])
```

После создания экземпляра мы можем получить доступ к полям массива и установить их. Есть несколько способов сделать это, но наиболее распространенным является использование свойства `indices`. Это свойство возвращает диапазон допустимых индексов для массива. Мы можем использовать диапазон для доступа и установки значений массива в цикле `for`.

!!! example [Example](samples/03_Arrays/03_ArrayOfNulls/src/Main.kt)
```kotlin
import kotlin.math.pow

fun main() {
    val arrNum = arrayOfNulls<Number>(6)

    arrNum.forEach { print(it.toString() + "\t") }

    println()

    for (i in arrNum.indices) {
        print("before: ${arrNum[i]}, ")
        arrNum[i] = i * i
        print("after: ${arrNum[i]}\n")
    }

    for (i in 0..arrNum.size - 1) {
        arrNum[i] = i.toDouble().pow(i)
    }

    arrNum.forEach { print(it.toString() + "\t") }
}

```

<details>
<summary><em>Output</em></summary>

```
null	null	null	null	null	null
before: null, after: 0
before: null, after: 1
before: null, after: 4
before: null, after: 9
before: null, after: 16
before: null, after: 25
1.0	1.0	4.0	27.0	256.0	3125.0
```

</details>

#### Создание пустого массива (`emptyArray()`)
Создадим пустой массив и заполним его данными.

```kotlin
var arr = emptyArray<String>()
arr += "1"
arr += "2"
arr += "3"
arr += "4"
arr += "5"
```

#### `val` vs `var`
https://developer.alexanderklimov.ru/android/kotlin/array.php

Нужно уяснить разницу между **`var`** и **`val`** при работе с массивами.

```kotlin
// Создали новый массив
var myArray = arrayOf(1, 2, 3)

// Это совершенно новый массив
myArray = arrayOf(4, 5)
```

Фактически мы уничтожили первый массив и создали вместо него второй массив.

Если мы попытаем написать такой же код с использованием `val`, то компилятор запретит такое действие.

```kotlin
// Создали новый массив
val myArray = arrayOf(1, 2, 3)

// Нельзя. Компилятор не пропустит
myArray = arrayOf(4, 5)
```

Но при этом вы можете менять значения элементов массива, созданного через `val`.

```kotlin
val myArray = arrayOf(1, 2)
myArray[0] = 3 // меняем первый элемент массива
myArray[1] = 4 // меняем второй элемент массива
```

#### Генерация значений с помощью инициализатора. Конструктор `Array()`
Также для создания массива можно использовать фабричную функцию, которая принимает размер массива и функцию, возвращающую начальное значение каждого элемента по его индексу.
```kotlin
// создаёт массив типа Array<String> со значениями ["0", "1", "4", "9", "16"]
val asc = Array(5) { i -> (i * i).toString() }
asc.forEach { println(it) }
```

При использовании конструктора нужно указать размер массива в первом параметре и лямбда-выражение во втором.

```kotlin
val myArray = Array(5, { i -> i * 2 })
println(myArray[3])
```

Мы задали пять элементов и каждый элемент в цикле умножаем на 2. В итоге получим массив чисел 0, 2, 4, 6, 8.

Создадим массив строк от "A" до "Z"

```kotlin
val letters = Array<String>(26) { i -> ('A' + i).toString() }
println(letters.joinToString(""))
```

Лямбда-выражение принимает индекс элемента массива и возвращает значение, которое будет помещено в массив с этим индексом. Значение вычисляется путём сложения индекса с кодом символа и преобразованием результата в строку.

Можно опустить тип массива и написать `Array(26)`, компилятор самостоятельно определит нужный тип.

Есть отдельные классы для каждого примитивного типа — `IntArray`, `ByteArray`, `CharArray` и т.д.

```kotlin
val zeros = IntArray(3) // первый способ
val zeros = intArrayOf(0, 0, 0) // второй способ при помощи фабричного метода
println(zeros.joinToString())
```

Можно использовать лямбда-выражение.

```kotlin
val intArray = IntArray(4){i -> i + i}
println(intArray.joinToString())
```

!!! example Example
```kotlin
import kotlin.math.pow
import kotlin.math.sqrt

fun main() {
    val arrGenerate = IntArray(7) { i -> i }
    arrGenerate.forEach { print(it.toString() + "\t") }
    println()

    val arrGenerateFloat = FloatArray(10) { i -> sqrt(i.toFloat()) }
    arrGenerateFloat.forEach { print(it.toString() + "\t") }
    println()

    val arrGenerateDouble = DoubleArray(11) { i -> i.toDouble().pow(1/(i+1).toDouble()) }
    arrGenerateDouble.forEach { print("%.2f".format(it) + "\t") }
    println()

    val arrGenerateStr = Array(3) { i -> "Элемент $i = ${i * i}" }
    arrGenerateStr.forEach { print(it.toString() + "\t") }
    println()

    println(8.0.pow(1 / 3))
    println(8.0.pow(1 / 3.0))
}
```

<details>
<summary><em>Output</em></summary>

```
0	1	2	3	4	5	6
0.0	1.0	1.4142135	1.7320508	2.0	2.236068	2.4494898	2.6457512	2.828427	3.0
0.00	1.00	1.26	1.32	1.32	1.31	1.29	1.28	1.26	1.25	1.23
Элемент 0 = 0	Элемент 1 = 1	Элемент 2 = 4
1.0
2.0
```

</details>

> `println(8.0.pow(1 / 3))` выводит 1, поскольку результатом операции `1 / 3` является `0` как следствие операций с целочисленными типами, а любое число в нулевой степени даёт 1.

#### Вывод значений массива. Класс `Arrays`
Для вывода значений массива используйте класс **`Arrays`** с методом `toString()`, который вернёт результат в удобном и читаемом виде. Сейчас в Kotlin появилась функция **`contentToString()`**, которая является предпочтительным вариантом.

```kotlin
println(Arrays.toString(arr)) // старый способ
println(arr.contentToString()) // рекомендуемый способ
```

#### Массивы примитивных типов
Kotlin автоматически упаковывает примитивные значения в соответствующие им классы-оболочки объектов, что будет иметь пагубные последствия для производительности. Чтобы избежать этих накладных расходов, в Котлине предусмотрена широкая поддержка примитивных массивов.

Так, в Kotlin есть особые классы для представления массивов примитивных типов без дополнительных затрат на оборачивание: `ByteArray`, `ShortArray`, `IntArray` и т.д. Данные классы не наследуют класс `Array`, хотя и обладают тем же набором методов и свойств. У каждого из них есть соответствующая фабричная функция:
```kotlin
val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2]
```

```kotlin
// int массив, размером 5 со значениями [0, 0, 0, 0, 0]
val arr = IntArray(5)

// инициализация элементов массива константой
// int массив, размером 5 со значениями [42, 42, 42, 42, 42]
val arr = IntArray(5) { 42 }

// инициализация элементов массива лямбда-выражением
// int массив, размером 5 со значениями [0, 1, 2, 3, 4] (элементы инициализированы своим индексом)
var arr = IntArray(5) { it * 1 }
```

!!! example [Example](samples/02_Syntax/16_PrimitivesArrays/src/Main.kt)
```kotlin
import kotlin.math.pow

fun main() {
    val testArrayInt: IntArray = intArrayOf(1, 2, 3)
    testArrayInt[0] = testArrayInt[1] + testArrayInt[2]
    testArrayInt.forEach { print(it.toString() + "\t") }
    println()
    val testArrayInit = IntArray(5)
    testArrayInit.forEach { print(it.toString() + "\t ") }
    println()
    val testArrayConst = IntArray(5) { 79 }
    testArrayConst.forEach { print(it.toString() + "\t ") }
    println()
    var testArrayLambda = DoubleArray(9) { 2.0.pow(it) }
    testArrayLambda.forEach { print(it.toString() + "\t ") }
    println()
}
```

> Существуют специальные методы `arrayOf` для следующих типов: `double`, `float`, `long`, `int`, `char`, `short`, `byte`, `boolean`.

Мы можем легко инициализировать примитивный массив `int`, используя специальный метод `arrayOf`:

```kotlin
val integers = intArrayOf(1, 2, 3, 4)
```

!!! example [Example](samples/03_Arrays/02_PrimitivesArrays/src/Main.kt)
```kotlin
fun main() {
    val arrInt = intArrayOf(9, 6, 3, 6, 1)
    val arrDouble = doubleArrayOf(3.7, 3.4, 9.1)
    val arrLogic = booleanArrayOf(true, true, false)
    val arrFloatOne = floatArrayOf(2F, 5.78F, 78.91F, 105F)
    // val arrFloatTwo = floatArrayOf(2, 5.78, 78.91, 105) // => Kotlin: Argument type mismatch
    val arrChar = charArrayOf('E', 'G', 'k', 'p', 'Z')
    val arrLongOne = longArrayOf(78L, 62L, 100_456_891L)
    val arrLongTwo = longArrayOf(78, 62, 100_456_891)
    val arrByte = byteArrayOf(-23, 127, 17, -98)
    val arrShort = shortArrayOf(-32000, 4500, 491, -9837)
}
```

!!! error Error
```kotlin
val arrFloatTwo = floatArrayOf(2, 5.78, 78.91, 105)
```

<details>
<summary><em>Output</em></summary>

```
Kotlin: Argument type mismatch: actual type is 'kotlin/Int' but 'kotlin/Float' was expected
```

</details>

#### Двумерные массивы
https://developer.alexanderklimov.ru/android/kotlin/array.php

Часто одного массива недостаточно. В некоторых случаях удобно использовать двумерные массивы. Визуально их легко представить в виде сетки. Типичный пример — зал в кинотеатре. Чтобы найти нужно место в большом зале, нам нужно знать ряд и место.

<dfn title="двумерный массив">Двумерный массив</dfn> — это массив, который содержит другие массивы. Создадим двумерный массив 5х5 и заполним его нулями.

```kotlin
// Создаём двумерный массив
var cinema = arrayOf<Array<Int>>()

// заполняем нулями
for (i in 0..4) {
    var array = arrayOf<Int>()
    for (j in 0..4) {
        array += 0
    }
    cinema += array
}

// выводим данные массива
for (array in cinema) {
    for (value in array) {
        print("$value ")
    }
    println()
}
// Результат
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
```

Сейчас в кинотеатре пусто. Первый зритель берёт билет в центре зала.

```kotlin
// центр зала
cinema[2][2] = 1

// три места во втором ряду
for (i in 1..3) {
    cinema[3][i] = 1
}

// весь первый ряд
for (i in 0..4) {
    cinema[4][i] = 1
}

// выводим данные массива
for (array in cinema) {
    for (value in array) {
        print("$value ")
    }
    println()
}

// Результат
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 1 1 1 0
1 1 1 1 1
```

!!! example Example
```kotlin
fun main() {
    val arrOneDimens: Array<Int> = Array(10) { (0..255).random() }
    arrOneDimens.forEach { print(it.toString() + "\t") }
    println()

    val arrTwoDimens: Array<Array<Int>> = Array(10) {
        Array(10) {
            (0..255).random()
        }
    }

    for (i in 0..9) {
        for (j in 0..9) {
            print(arrTwoDimens[i][j].toString() + "\t\t")
        }
        println()
    }
}
```

<details>
<summary><em>Output</em></summary>

```
23	181	59	133	173	58	176	55	7	202
126		95		7		107		94		229		152		237		73		232
177		236		242		168		142		65		84		92		84		201
187		63		112		134		22		240		160		0		87		157
71		88		43		28		147		6		153		113		79		206
79		43		4		145		121		196		255		99		125		126
76		119		195		211		114		193		116		16		216		21
35		88		138		56		216		218		80		246		31		196
57		29		126		21		105		18		29		180		133		238
121		229		89		84		108		201		20		191		24		146
203		236		161		122		34		38		95		133		136		209
```

</details>

#### Многомерный массив с базовыми типами
https://developer.alexanderklimov.ru/android/kotlin/array.php

По такому же принципу строится трёхмерный массив. На этот раз его можно представить не в виде сетки, а в виде куба. В этом случае сетки идут как бы друг за другом, образуя слои.

```kotlin
var rubikCube = arrayOf<Array<Array<Int>>>()
for (i in 0..2) {
    var piece = arrayOf<Array<Int>>()
    for (j in 0..2) {
        var array = arrayOf<Int>()
        for (k in 0..2) {
            array += 0
        }
        piece += array
    }
    rubikCube += piece
}

// второй слой, третий ряд, первое место
rubikCube[1][2][0] = 1
println(Arrays.deepToString(rubikCube))

// Результат
0, 0, 0 | 0, 0, 0 | 0, 0, 0
0, 0, 0 | 0, 0, 0 | 0, 0, 0
0, 0, 0 | 1, 0, 0 | 0, 0, 0
```

Если нам приходится обрабатывать многомерный массив базовых типов Kotlin, мы можем полагаться на различные примитивные библиотечные функции и дополнительные классы. Фактически, Kotlin определяет дополнительные классы, как `IntArray`, `BooleanArray`, `LongArray` и т.д., а также библиотечные функции для создания экземпляров этих типов.

В качестве примера давайте посмотрим, как можно определить простой двумерный массив целых чисел, используя методы `arrayOf` и `intArrayOf`.

Используя `arrayOfNulls`, можно инициализировать массив нулевыми значениями. Таким образом, с помощью этого метода можно инициализировать каждую строку разным размером массива.

!!! example Example
```kotlin
fun main() {
    val arrOne: Array<IntArray> = arrayOf(
        intArrayOf(2, 7, 8, 1),
        intArrayOf(5, 2, 9, 3),
    )

    val arrTwo = arrayOfNulls<Array<Int>>(2)
    arrTwo[0] = Array(3) {0}
    arrTwo[1] = Array(2) {1}
}
```

#### Обход (перебор элементов) массивов
https://developer.alexanderklimov.ru/android/kotlin/array.php

Обычный перебор через **`for`**.

```kotlin
val arr = arrayOf(1, 2, 3, 4, 5)

for (i in arr) {
    println("Значение элемента равно $i")
}
```

Можно одной строкой через **`forEach`**.

```kotlin
arr.forEach { i -> println("Значение элемента равно $i") }
```

Если нужна информация не только о значении элемента, но и его индексе, то используем **`forEachIndexed`**.

```kotlin
arr.forEachIndexed { index, element ->
    println("$index : $element")
}

// Результат
0 : 1
1 : 2
2 : 3
3 : 4
4 : 5
```

`forEachIndexed` дает нам и индекс, и значение по этому индексу в массиве.

!!! example [Example](samples/03_Arrays/08_IterationOverArray/src/Main.kt)

```kotlin
fun main() {
    val arrOne = IntArray(10) { i -> i * 3 }

    arrOne.forEach { item -> print(item.toString() + "\t") }
    println()

    arrOne.forEachIndexed { index, item -> println("Элемент с индексом $index равен $item") }
}

```


<details>
<summary><em>Output</em></summary>

```
0	3	6	9	12	15	18	21	24	27
Элемент с индексом 0 равен 0
Элемент с индексом 1 равен 3
Элемент с индексом 2 равен 6
Элемент с индексом 3 равен 9
Элемент с индексом 4 равен 12
Элемент с индексом 5 равен 15
Элемент с индексом 6 равен 18
Элемент с индексом 7 равен 21
Элемент с индексом 8 равен 24
Элемент с индексом 9 равен 27
```

</details>

#### Итераторы
https://kotlinlang.ru/docs/iterators.html

Для обхода элементов коллекции стандартная библиотека Kotlin поддерживает механизм <dfn title="итератор">итераторов</dfn> — объектов, которые предоставляют доступ к элементам последовательно, не раскрывая базовую структуру коллекции. Итераторы полезны, когда вам нужно обработать все элементы коллекции один за другим, например, вывести в лог их значения или обновить.

##### Использование итератора (интерфейс)
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/

```kotlin
interface Iterator<out T>
(Common source) (Native source)
```

###### Functions
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/#functions

- `hasNext`

    Returns true if the iteration has more elements.

    ```kotlin
    abstract operator fun hasNext(): Boolean
    ```

- `next`

    Returns the next element in the iteration.
    ```kotlin
    abstract operator fun next(): T
    ```

###### Extension Functions
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/#extension-functions

- `asSequence`

    Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.
    ```kotlin
    fun <T> Iterator<T>.asSequence(): Sequence<T>
    ```

- `forEach`

    Performs the given operation on each element of this Iterator.
    ```kotlin
    fun <T> Iterator<T>.forEach(operation: (T) -> Unit)
    ```

- `iterator`

    Returns the given iterator itself. This allows to use an instance of iterator in a `for` loop.
    ```kotlin
    operator fun <T> Iterator<T>.iterator(): Iterator<T>
    ```

- `withIndex`

    Returns an Iterator that wraps each element produced by the original iterator into an IndexedValue containing the index of that element and the element itself.
    ```kotlin
    fun <T> Iterator<T>.withIndex(): Iterator<IndexedValue<T>>
    ```

Итераторы доступны всем наследникам интерфейса `Iterable<T>`, включая `Set` и `List`, путём вызова функции `iterator()`.

При получении итератора он сначала указывает на первый элемент коллекции; вызов функции `next()` возвращает этот элемент и перемещает позицию итератора на следующий элемент, если такой существует.

Как только итератор проходит через последний элемент, его больше нельзя использовать для извлечения элементов; его также нельзя вернуть в предыдущее положение. Чтобы снова перебрать коллекцию, нужно создать новый итератор.
```kotlin
fun main() {
    val numbers = listOf("one", "two", "three", "four")
    val numbersIterator = numbers.iterator()
    while (numbersIterator.hasNext()) {
        println(numbersIterator.next())
    }
}

// В логе будет:
// one
// two
// three
// four
```

Другой способ перебрать `Iterable` коллекцию — это всем известный цикл `for`. При использовании `for` вы неявно получаете итератор. Поэтому, приведённый ниже код эквивалентен предыдущему примеру:
```kotlin
fun main() {
    val numbers = listOf("one", "two", "three", "four")
    for (item in numbers) {
        println(item)
    }
}

// В логе будет:
// one
// two
// three
// four
```

!!! example [Example](samples/03_Arrays/07_ArrayIteration/src/Main.kt)

```kotlin
fun main() {
    val arrOne = IntArray(10) { i -> i * 3 }

    for (item in arrOne) {
        print(item.toString() + "\t")
    }
    println()

    var iter = arrOne.iterator()
    while (iter.hasNext()) {
        val item = iter.next()
        print(item.toString() + "\t")
    }
}

```


<details>
<summary><em>Output</em></summary>

```
0	3	6	9	12	15	18	21	24	27
0	3	6	9	12	15	18	21	24	27
```

</details>

Также, есть полезная функция `forEach()`, которая позволяет автоматически перебирать коллекцию и выполнять заданный код для каждого элемента. Перепишем пример выше:
```kotlin
fun main() {
    val numbers = listOf("one", "two", "three", "four")
    numbers.forEach {
        println(it)
    }
}

// В логе будет:
// one
// two
// three
// four
```

#### Операции с массивами

##### Переворачивание массива

###### Перевернуть массив: `reversedArray()`
Для операции создадим дополнительную переменную для нового массива с перевёрнутыми значениями. Оригинал останется без изменений.

```kotlin
val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
var reversedArray = numbers.reversedArray()

println(Arrays.toString(reversedArray))
```

###### Перевернуть массив: `reverse()`
Если оригинал массива нам точно не понадобится, то мы можем перевернуть его без создания нового массива.

```kotlin
val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
numbers.reverse()

println(Arrays.toString(numbers))
```

!!! example [Example](samples/03_Arrays/09_Reverse/src/Main.kt)

```kotlin
fun main() {
    val arrOne = IntArray(10) { i -> i * 3 }
    arrOne.forEach { i -> print(i.toString() + "\t") }
    println()
    arrOne.reverse()
    arrOne.forEach { i -> print(i.toString() + "\t") }
    println()
    arrOne.reversed()
    arrOne.forEach { i -> print(i.toString() + "\t") }
    println()
    val arrTwo = arrOne.reversed()
    arrTwo.forEach { i -> print(i.toString() + "\t") }
    println()
    arrOne.reverse(3, 6)
    arrOne.forEach { i -> print(i.toString() + "\t") }
    // arrTwo.reverse(3, 6) // => Kotlin: Unresolved reference: reverse
    // Reversed возвращает тип List, у которого отсутствует метод reverse, т.е.
    // val arrTwo: List<Int> = arrOne.reversed()
}

```


<details>
<summary><em>Output</em></summary>

```
0	3	6	9	12	15	18	21	24	27
27	24	21	18	15	12	9	6	3	0
27	24	21	18	15	12	9	6	3	0
0	3	6	9	12	15	18	21	24	27
27	24	21	12	15	18	9	6	3	0
```

</details>

Стоит обратить внимание на тип `arrTwo`. Метод `reversed` возвращает тип `List`, у которого отсутствует метод `reverse`, т.е. присвоение в примере ниже эквивалентно `val arrTwo: List<Int> = arrOne.reversed()`. Поэтому попытка обращения к несуществующему методу вызовет ошибку `Unresolved reference`.

!!! error Error

```kotlin
fun main() {
    val arrOne = IntArray(10) { i -> i * 3 }
    val arrTwo = arrOne.reversed()
    arrTwo.reverse(3, 6)
}

```

<details>
<summary><em>Output</em></summary>

```
Kotlin: Unresolved reference: reverse
```

</details>

##### Сортировка элементов массива
В Kotlin очень просто сортировать элементы.

Вызываем метод **`sort()`**. Мы меняем существующий массив, а не создаём новый.

```kotlin
val numbers: IntArray = intArrayOf(7, 5, 8, 4, 9, 6, 1, 3, 2)
numbers.sort()

// println(Arrays.toString(numbers)) // старый способ
println("Sorted array: ${numbers.contentToString()}")
```

Сортировать можно не весь массив, а только определённый диапазон. Указываем начало и размер диапазона. Допустим, нам нужно отсортировать только первые три элемента из предыдущего примера.

```kotlin
numbers.sort(0, 3)

// 5, 7, 8, 4, 9, 6, 1, 3, 2
```

Сортировка в обратном порядке от наибольшего значения к наименьшему.

```kotlin
numbers.sortDescending()
```

!!! example [Example](samples/03_Arrays/10_Sorting/src/Main.kt)

```kotlin
fun main() {
    var arrOne = intArrayOf(7, 9, 1, 15, 8, 1, 24, 5, 78)
    arrOne.sort()
    arrOne.forEach { print(it.toString() + "\t") }
    println()
    arrOne = intArrayOf(7, 9, 1, 15, 8, 1, 24, 5, 78)
    arrOne.sort(4)
    arrOne.forEach { print(it.toString() + "\t") }
    println()
    arrOne = intArrayOf(7, 9, 1, 15, 8, 1, 24, 5, 78)
    arrOne.sort(3, 6)
    arrOne.forEach { print(it.toString() + "\t") }
}

```

<details>
<summary><em>Output</em></summary>

```
1	1	5	7	8	9	15	24	78
7	9	1	15	1	5	8	24	78
7	9	1	1	8	15	24	5	78
```

</details>

Если нужно сохранить исходный массив, то вызываем другие функции, которые создадут новый массив.

```kotlin
val numbers: IntArray = intArrayOf(7, 5, 8, 4, 9, 6, 1, 3, 2)
val sortedNumbers: IntArray = numbers.sortedArray() // новый сортированный массив
val descendingSortedNumber: IntArray = numbers.sortedArrayDescending() // новый сортированный массив в обратном порядке

println("Original array ${numbers.contentToString()}:Sorted array ${sortedNumbers
        .contentToString()}")
// Original array [7, 5, 8, 4, 9, 6, 1, 3, 2]:Sorted array [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Для сортировки объектов указываем компаратор и условие сравнения. Например, мы хотим сравнить котов по их возрастам.

```kotlin
val cats = arrayOf(Cat("Барсик", 8), Cat("Мурзик", 4), Cat("Васька", 9))
// массив до сортировки
cats.forEach { println(it) }

// сортируем по возрасту
cats.sortWith(Comparator { c1: Cat, c2: Cat -> c1.age - c2.age })
cats.forEach { println(it) }


data class Cat(val name: String, val age: Int)
```

Вместо компаратора можно использовать функцию **`sortBy()`** с указанием условия. Сравним теперь котов не по возрасту, а по их именам.

```kotlin
val cats = arrayOf(Cat("Барсик", 8), Cat("Мурзик", 4), Cat("Васька", 9))
cats.forEach { println(it) }
cats.sortBy { cat -> cat.name }
cats.forEach { println(it) }


data class Cat(val name: String, val age: Int)
```

##### Перемешивание элементов массива: `shuffle()` (Kotlin 1.40)
Перемешать элементы массива в случайном порядке можно при помощи метода `shuffle()`.

```kotlin
val numbers = arrayOf(1, 2, 3, 4, 5)
numbers.shuffle()
println(numbers.contentToString())
```

!!! example [Example](samples/03_Arrays/11_Shuffle/src/Main.kt)

```kotlin
import kotlin.random.Random

fun main() {
    var arrOne = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
    arrOne.shuffle()
    arrOne.forEach { print(it.toString() + "\t") }
    println()
    arrOne = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
    arrOne.shuffle(Random(2))
    arrOne.forEach { print(it.toString() + "\t") }
    println()
    arrOne = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
    arrOne.shuffle(Random(2)) // => The same seed number gives the same sequence
    arrOne.forEach { print(it.toString() + "\t") }
    println()
    arrOne = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
    arrOne.shuffle(Random(5))
    arrOne.forEach { print(it.toString() + "\t") }
}

```

<details>
<summary><em>Output</em></summary>

```
1	6	13	10	8	3	4	7	14	9	11	2	5	15	12
4	15	7	6	11	2	9	3	1	10	14	12	13	8	5
4	15	7	6	11	2	9	3	1	10	14	12	13	8	5
4	2	10	11	14	13	3	6	8	15	5	7	9	1	12
```

</details>

##### Наличие элемента в массиве: `contains()`
Если элемент содержится в массиве, то метод **`contains()`** возвращает `true`.

```kotlin
val array = arrayOf(1, 2, 3, 4, 5)
val isContains = array.contains(9)
println(isContains) // false
```

##### Найти среднее значение чисел в массиве: `average()`
Используем функцию **`average()`**. Возвращается `Double`.

```kotlin
val array = arrayOf(1, 3, 5)
println(array.average()) // 3.0
```

##### Подсчитать сумму чисел в массиве: `sum()`

```kotlin
val array = arrayOf(1, 2, 3, 4, 5)
println(array.sum()) // 15
```

##### Найти наибольшее и наименьшее число в массиве
В цикле сравниваем каждое число с эталоном, которые вначале принимает значение первого элемента. Если следующее число массива больше эталона, то берём его значение. В итоге после перебора получим наибольшее число в массиве.

```kotlin
val numbers: IntArray = intArrayOf(4, 9, 3, 2, 6)
var largestElement = numbers[0]

for (number in numbers){
    if(largestElement < number)
        largestElement = number
}

println("Наибольшее число в массиве: $largestElement")
```

Но можно не писать свой код, а вызвать готовые функции **`min()`** и **`max()`**.

```kotlin
println(numbers.min())
println(numbers.max())
```

##### Функция `intersect()`: найти общие элементы двух массивов
Есть два массива с числами. Нужно сравнить их и найти у них общие числа. Поможет нам функция **`intersect()`**

```kotlin
val firstArray = arrayOf(1, 2, 3, 4, 5)
val secondArray = arrayOf(3, 5, 6, 7, 8)

val intersectedArray = firstArray.intersect(secondArray.toList()).toIntArray()
println(Arrays.toString(intersectedArray))

//[3, 5]
```

##### Выбрать случайную строку из массива
Имеется массив строк. Сначала вычисляем размер массива. Затем генерируем случайное число в диапазоне от 0 до (почти) 1, которое умножаем на количество элементов в массиве. После этого результат преобразуется в целое число вызовом `toInt()`. Получается выражение типа `0.811948208873101 * 5 = 4`. В Kotlin есть свой класс `Random`, поэтому случайное число можно получить другим способом.

```kotlin
val cats = arrayOf("Барсик", "Мурзик", "Васька", "Рыжик", "Персик")
val arraySize = cats.size

// Java-style
val rand = (Math.random() * arraySize).toInt()
val name = "${cats[rand]}}"
println(name)

// Kotlin-style
val rand = Random.nextInt(arraySize)
val name = "${cats[rand]}"
println(name)
```

По этому принципу можно создать игру "Камень, Ножницы, Бумага".

```kotlin
private fun getChoice(optionsParam: Array<String>) =
    optionsParam[Random.nextInt(optionsParam.size)]

val options = arrayOf("Камень", "Ножницы", "Бумага")
val choice = getChoice(options)
println(choice)
```

##### `onEach()`: Операция с каждым элементом массива по очереди (Kotlin 1.40)
В коллекциях мы можем пройтись по всем элементам и что-то с каждым сделать. Теперь такое возможно и с элементами массива. Пройдёмся по всем числам массива, удвоим каждое число и конвертируем в строку.

```kotlin
var str = ""
val numbers = arrayOf(1, 2, 3, 4, 5)
numbers.onEach {str += it * 2}
println(str)
```

##### Удалить дубликаты
Удалить дубликаты можно несколькими способами. Например, через **`toSet()`**

```kotlin
val myArray = arrayOf(1, 1, 2, 3, 4, 5, 5, 4, 3, 2)

println(myArray.toSet().joinToString())
```

Мы получим множество, которое не допускает дубликатов. Порядок элементов сохраняется. Обратно в массив можно преобразовать через `toIntArray()` или схожие функции.

Аналогично можно использовать **`toHashSet()`**, получив `HashSet`, который тоже не допускает дубликатов, но не гарантирует очерёдность элементов.

Другой вариант — **`toMutableSet()`**. Порядок сохранится.

Самый простой вариант — вызвать функцию **`distinct()`**, который вернёт новый массив без дубликатов.

```kotlin
val myArray = arrayOf(1, 1, 2, 3, 4, 5, 5, 4, 3, 2)
println(myArray.joinToString())

val newArray = myArray.distinct()
println(newArray.joinToString())
```

### Коллекции
https://kotlinlang.ru/docs/collections-overview.html

Стандартная библиотека Kotlin предоставляет большой набор инструментов для работы с <dfn title="коллекция">коллекциями</dfn> — группами с переменным количеством элементов (или нулём элементов), которые используются для решения какой-либо задачи.

Коллекции — это общая концепция для большинства языков программирования, поэтому если вы знакомы с коллекциями, например, в Java или Python, то можете пропустить данное введение и перейти к разделам с более подробным описанием.

Обычно в коллекции находится несколько объектов одного типа (но также коллекция может быть пустой). Эти объекты называются <dfn title="элемент коллекции">элементами</dfn> или <dfn title="item collection">items</dfn>. Например, все студенты одного факультета образуют коллекцию, которую можно использовать для расчёта их среднего возраста.

#### Виды коллекций в Kotlin
* <dfn title="List">List</dfn> (<dfn title="список">список</dfn>) — упорядоченная коллекция, в которой к элементам можно обращаться по индексам — целым числам, отражающим положение элементов в коллекции. Идентичные элементы (дубликаты) могут встречаться в списке более одного раза. Примером списка является предложение: это группа слов, их порядок важен, и они могут повторяться.
* <dfn title="Set">Set</dfn> (<dfn title="множество">множество</dfn>) - коллекция уникальных элементов. Отражает математическую абстракцию множества: группа объектов без повторов. Как правило, порядок расположения элементов здесь не имеет значения. Примером множества является алфавит.
* <dfn title="Map">Map</dfn> (<dfn title="словарь">словарь</dfn>, <dfn title="ассоциативный список">ассоциативный список</dfn>) — набор из пар “ключ-значение”. Ключи уникальны и каждый из них соответствует ровно одному значению. Значения могут иметь дубликаты. Ассоциативные списки полезны для хранения логических связей между объектами, например, ID сотрудников и их должностей.

Kotlin позволяет управлять коллекциями независимо от того, какой именно тип объектов в них хранится: будь то `String`, `Int` или какой-то собственный класс, общие принципы работы с коллекцией всегда неизменны. Стандартная библиотека Kotlin предоставляет общие интерфейсы, классы и функции для создания, заполнения и управления коллекциями любого типа.

Интерфейсы коллекций и связанные с ними функции находятся в пакете `kotlin.collections`. Давайте рассмотрим его содержимое.

#### Использование коллекций
- `List` — **когда важен порядок**

    `List` хранит и отслеживает позицию элементов. Она знает, в какой позиции списка находится тот или иной элемент, и несколько элементов могут содержать ссылки на один объект.

- `Set` — **когда важна уникальность**

    `Set` не разрешает дубликаты и не отслеживает порядок, в котором хранятся значения. Коллекция не может содержать несколько элементов, ссылающихся на один и тот же объект, или несколько элементов, ссылающихся на два объекта, которые считаются равными.

- `Map` — **когда важен поиск по ключу**

    `Map` использует пары «ключ-значение». Этот тип коллекции знает, какое значение связано с заданным ключом. Два ключа могут ссылаться на один объект, но дубликаты ключей невозможны. Хотя ключи обычно представляют собой строковые имена (например, для составления списков свойств в формате «имя-значение»), ключом также может быть произвольный объект.

#### Типы коллекций
Стандартная библиотека Kotlin предоставляет реализации для основных типов коллекций: `Set`, `List`, `Map`. Есть два вида интерфейсов, предоставляющих каждый из этих типов:
* *неизменяемый* (*read-only*) — предоставляет операции, которые дают доступ к элементам коллекции.
* *изменяемый* (*mutable*) — расширяет предыдущий интерфейс и дополнительно даёт доступ к операциям добавления, удаления и обновления элементов коллекции.

Обратите внимание, что изменяемую коллекцию не требуется объявлять с помощью ключевого слова `var`. Связано это с тем, что изменения вносятся в изначальные объекты коллекции без изменения ссылки на саму коллекцию. Но если вы объявите коллекцию с помощью `val` и попытаетесь ее перезаписать, то получите ошибку компиляции.
```kotlin
fun main() {
    val numbers = mutableListOf("one", "two", "three", "four")
    numbers.add("five") // this is OK
    //numbers = mutableListOf("six", "seven") // compilation error
}
```

Неизменяемые типы коллекций [ковариантны](https://kotlinlang.ru/docs/generics.html). Это означает, что если класс `Rectangle` наследуется от `Shape`, вы можете использовать `List<Rectangle>` там, где требуется `List<Shape>`. Другими словами, типы коллекций имеют такое же отношение подтипов, что и типы элементов. `Map`-ы ковариантны по типу значения, но не по типу ключа.

В свою очередь, изменяемые коллекции не являются ковариантными; в противном случае это привело бы к сбоям во время выполнения. Если `MutableList<Rectangle>` был подтипом `MutableList<Shape>`, вы могли добавить в него других наследников `Shape` (например, `Circle`), таким образом нарушая изначальный тип коллекции — `Rectangle`.

!!! info [Ковариантность и контравариантность](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B8_%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))

    **Ковариа́нтность** и **контравариа́нтность** в программировании — способы переноса наследования типов на производные от них типы — контейнеры, обобщённые типы, делегаты и т. п. Термины произошли от аналогичных понятий теории категорий «ковариантный» и «контравариантный функтор».

    <dfn title="ковариантность">Ковариантностью</dfn> называется сохранение иерархии наследования исходных типов в производных типах в том же порядке. Так, если класс `Cat` наследуется от класса `Animal`, то естественно полагать, что перечисление `IEnumerable<Cat>` будет потомком перечисления `IEnumerable<Animal>`. Действительно, «список из пяти кошек» — это частный случай «списка из пяти животных». В таком случае говорят, что тип (в данном случае обобщённый интерфейс) `IEnumerable<T>` *ковариантен* своему параметру-типу `T`.

    <dfn title="контравариантность">Контравариантностью</dfn> называется обращение иерархии исходных типов на противоположную в производных типах. Так, если класс `String` наследуется от класса `Object`, а делегат `Action<T>` определён как метод, принимающий объект типа `T`, то `Action<Object>` наследуется от делегата `Action<String>`, а не наоборот. Действительно, если «все строки — объекты», то «всякий метод, оперирующий произвольными объектами, может выполнить операцию над строкой», но не наоборот. В таком случае говорят, что тип (в данном случае обобщённый делегат) `Action<T>` контравариантен своему параметру-типу `T`.

    Отсутствие наследования между производными типами называется <dfn title="инвариантность">инвариантностью</dfn>.

    Контравариантность позволяет корректно устанавливать тип при *создании подтипов* (subtyping), то есть, установить множество функций, позволяющее заменить другое множество функций в любом контексте. В свою очередь, ковариантность характеризует *специализацию кода*, то есть замену старого кода новым в определённых случаях. Таким образом, ковариантность и контравариантность являются независимыми механизмами типобезопасности, не исключающими друг друга, и могут и должны применяться в объектно-ориентированных языках программирования.


Ниже представлена ​​схема интерфейсов коллекций Kotlin:

![](./img/collections-diagram.png)

#### `Collection`
`Collection<T>` является корнем в иерархии коллекций. Этот интерфейс представляет собой обычное поведение неизменяемой коллекции: операции типа `size`, `get` и т. д. Collection наследуется от интерфейса `Iterable<T>`, который определяет операции для итерации элементов. Вы можете использовать `Collection` как параметр функции, которая может работать с разными типами коллекций. Для более конкретных случаев следует использовать наследников `Collection`: `List` и `Set`.
```kotlin
fun printAll(strings: Collection<String>) {
        for(s in strings) print("$s ")
        println()
    }

fun main() {
    val stringList = listOf("one", "two", "one")
    printAll(stringList) // one two one

    val stringSet = setOf("one", "two", "three")
    printAll(stringSet) // one two three
}
```

`MutableCollection<T>` — это `Collection` с операциями записи, такими как `add` и `remove`.

```kotlin
fun List<String>.getShortWordsTo(shortWords: MutableList<String>, maxLength: Int) {
    this.filterTo(shortWords) { it.length <= maxLength }
    // throwing away the articles
    val articles = setOf("a", "A", "an", "An", "the", "The")
    shortWords -= articles
}

fun main() {
    val words = "A long time ago in a galaxy far far away".split(" ")
    val shortWords = mutableListOf<String>()
    words.getShortWordsTo(shortWords, 3)
    println(shortWords) // [ago, in, far, far]
}
```

#### `List`
`List<T>` хранит элементы в определённом порядке и обеспечивает к ним доступ по индексу. Индексы начинаются с нуля (0 — индекс первого элемента) и идут до `lastIndex`, который равен (`list.size - 1`).
```kotlin
fun main() {
    val numbers = listOf("one", "two", "three", "four")
    println("Number of elements: ${numbers.size}") // 4
    println("Third element: ${numbers.get(2)}") // three
    println("Fourth element: ${numbers[3]}") // four
    println("Index of element \"two\" ${numbers.indexOf("two")}") // 1
}
```

!!! example [Объявление коллекции `List`](samples/03_Arrays/12_List/src/Main.kt)

```kotlin
fun main() {
    val testListStr = listOf("один", "два", "три", 97)
    val testListNum = listOf(3, 7, 9)
    val testListSum: List<Int>

    testListSum = testListNum + listOf(6, 8, 2)

    println(testListStr)
    println(testListNum)
    println(testListSum)
}
```

<details>
<summary><em>Output</em></summary>

```
[один, два, три, 97]
[3, 7, 9]
[3, 7, 9, 6, 8, 2]
```

</details>

В неизменяемых коллекциях нельзя менять количество элементов и изменять значение элементов. Это сделано с целью защиты данных.

!!! error Попытка измененить значение

```kotlin
fun main() {
    val testListStr = listOf("один", "два", "три", 97)
    val testListNum = listOf(3, 7, 9)
    val testListSum: List<Int>

    testListSum = testListNum + listOf(6, 8, 2)

    println(testListStr[2])
    testListNum[2] = 78 // => Error: No set method providing array access
}

```

<details>
<summary><em>Output</em></summary>

```
Kotlin: No set method providing array access
```

</details>

Нельзя к массиву с элементами одного типа прибавлять массив с элементами другого типа.

!!! error `List` с разными типами

```kotlin
fun main() {
    val testListStr = listOf("один", "два", "три", 97)
    val testListNum = listOf(3, 7, 9)
    val testListSum: List<Int>

    testListSum = testListNum + listOf(6.0, 8, 2) // => Error: Assignment type mismatch
}

```

<details>
<summary><em>Output</em></summary>

    Kotlin: Assignment type mismatch: actual type is 'kotlin/collections/List<it(kotlin/Number & kotlin/Comparable<*>)>' but 'kotlin/collections/List<kotlin/Int>' was expected


</details>

Элементы списка (в том числе `null`) могут дублироваться: список может содержать любое количество одинаковых объектов. Два списка считаются равными, если они имеют одинаковый размер и их элементы в одних и тех позициях [структурно равны](https://kotlinlang.ru/docs/equality.html).
```kotlin
data class Person(var name: String, var age: Int)

fun main() {
    val bob = Person("Bob", 31)
    val people = listOf(Person("Adam", 20), bob, bob)
    val people2 = listOf(Person("Adam", 20), Person("Bob", 31), bob)
    println(people == people2) // true
    bob.age = 32
    println(people == people2) // false
}
```

`MutableList<T>` — это `List` с операциями записи, специфичными для списка, например, для добавления или удаления элемента в определённой позиции.
```kotlin
fun main() {
    val numbers = mutableListOf(1, 2, 3, 4)
    numbers.add(5)
    numbers.removeAt(1)
    numbers[0] = 0
    numbers.shuffle()
    println(numbers) // [4, 0, 3, 5]
}
```

!!! example [Работа с `MutableList`](samples/03_Arrays/13_MutableList/src/Main.kt)

```kotlin
fun main() {
    val testListNum = mutableListOf(3, 9, 7, 9)
    println(testListNum)

    testListNum.add(798) // Добавили элемент в конец List
    println(testListNum)

    testListNum.add(0, 641) // Добавили элемент на место с индексом
    testListNum.forEach { println(it.toString() + "\t") }
    println(testListNum)

    testListNum.removeAt(0) // Удалили элемент по индексу
    testListNum.remove(9) // Удалили первое вхождение элемента со значением
    println(testListNum)
}

```

<details>
<summary><em>Output</em></summary>

```
[3, 9, 7, 9]
[3, 9, 7, 9, 798]
641
3
9
7
9
798
[641, 3, 9, 7, 9, 798]
[3, 7, 9, 798]
```

</details>

Как видите, в некоторых аспектах списки очень похожи на массивы. Однако есть одно важное отличие: размер массива определяется при инициализации и никогда не изменяется; в свою очередь список не имеет предопределённого размера; размер списка может быть изменён в результате операций записи: добавления, обновления или удаления элементов.

По умолчанию в Kotlin реализацией `List` является `ArrayList`, который можно рассматривать как массив с изменяемым размером.

!!! example [`mutableListOf` и `ArrayList`](samples/03_Arrays/14_ArrayList/src/Main.kt)

```kotlin
fun main() {
    val testListNum = mutableListOf<Int>() // Вызываем метод
    testListNum.add(97)
    testListNum.add(85)
    testListNum.add(17)
    println(testListNum)

    val testArrList = ArrayList<String>() // Вызываем конструктор класса
    testArrList.add("один")
    testArrList.add("два")
    testArrList.add("три")
    println(testArrList)
}

```

<details>
<summary><em>Output</em></summary>

```
[97, 85, 17]
[один, два, три]
```

</details>

Как видно из примера выше, в обоих случаях получаем `ArrayList`, который можно использовать для получения динамических массивов.

#### `Set`
`Set<T>` хранит уникальные элементы; их порядок обычно не определён. `null` также является уникальным элементом: `Set` может содержать только один `null`. Два множества равны, если они имеют одинаковый размер и для каждого элемента множества есть равный элемент в другом множестве.
```kotlin
fun main() {
    val numbers = setOf(1, 2, 3, 4)
    println("Number of elements: ${numbers.size}") // Number of elements: 4
    if (numbers.contains(1)) println("1 is in the set")

    val numbersBackwards = setOf(4, 3, 2, 1)
    println("The sets are equal: ${numbers == numbersBackwards}") // true
}
```

!!! example [Неизменяемый `Set`](samples/03_Arrays/15_Set/src/Main.kt)

```kotlin
fun main() {
    val testSetNum = setOf(1, 4, 8, 5, 4)
    println(testSetNum)
    val testSetTwo: Set<Int>
    testSetTwo = setOf(2, 4, 9, 3, 5)
    for (item in testSetNum) {
        print(testSetTwo.contains(item).toString() + "\t")
    }
    println()

    println(testSetNum.intersect(testSetTwo))       // пересечение наборов
    val testNewSet = testSetNum.union(testSetTwo)   // объединение
    println(testNewSet)
    val testPlusSet = testSetNum.plus(789)
    println(testPlusSet)
}

```

<details>
<summary><em>Output</em></summary>

```
[1, 4, 8, 5]
false	true	false	true
[4, 5]
[1, 4, 8, 5, 2, 9, 3]
[1, 4, 8, 5, 789]
```

</details>

`MutableSet` — это `Set` с операциями записи из `MutableCollection`.

!!! example [Изменяемый `Set`](samples/03_Arrays/16_MutableSet/src/Main.kt)

```kotlin
fun main() {
    val testSetNum = mutableSetOf(1, 9, 6, 4, 7)
    val testSetTwo: MutableSet<Int> = mutableSetOf()
    for (i in 9..16) {
        testSetTwo.add(i * (105..145).random())
    }
    println(testSetNum)
    println(testSetTwo)
    testSetNum.remove(1)
    println(testSetNum)
    println(testSetNum.dropWhile { it > 6 })
}

```

<details>
<summary><em>Output</em></summary>

```
[1, 9, 6, 4, 7]
[1080, 1130, 1408, 1332, 1482, 1638, 1935, 2064]
[9, 6, 4, 7]
[6, 4, 7]
```

</details>

По умолчанию реализацией `Set` является `LinkedHashSet`, который сохраняет порядок вставки элементов. Следовательно, функции, которые зависят от порядка элементов, такие как `first()` или `last()`, возвращают предсказуемые результаты для таких множеств.
```kotlin
fun main() {
    val numbers = setOf(1, 2, 3, 4)  // по умолчанию LinkedHashSet
    val numbersBackwards = setOf(4, 3, 2, 1)

    println(numbers.first() == numbersBackwards.first()) // false
    println(numbers.first() == numbersBackwards.last()) // true
}
```

Альтернативная реализация — `HashSet` — не сохраняет порядок элементов, поэтому при вызове функций `first()` или `last()` вернётся непредсказуемый результат. Однако `HashSet` требует меньше памяти для хранения того же количества элементов.

Можно преобразовывать изменяемые коллекции в неизменяемые и наоборот:

!!! example [Конверсия](samples/03_Arrays/17_Conversion/src/Main.kt)

```kotlin
fun main() {
    val testSetNum = mutableSetOf(1, 9, 6, 4, 7)
    println(testSetNum)
    testSetNum.add(47)
    println(testSetNum)
    val testNoMutableSet = testSetNum.toSet() // Можно преобразовывать изменяемые коллекции в неизменяемые и наоборот
    testSetNum.add(59)
    println(testNoMutableSet)
    // testNoMutableSet.add(39) // Нельзя добавить элемент, так как мы вернули неизменяемую коллекцию
    println(testSetNum)
}

```

<details>
<summary><em>Output</em></summary>

```
[1, 9, 6, 4, 7]
[1, 9, 6, 4, 7, 47]
[1, 9, 6, 4, 7, 47]
[1, 9, 6, 4, 7, 47, 59]
```

</details>

#### `Map`
`Map<K, V>` не является наследником интерфейса `Collection`; однако это один из типов коллекций в Kotlin. `Map` хранит пары “ключ-значение” (или *entries*); ключи уникальны, но разные ключи могут иметь одинаковые значения. Интерфейс `Map` предоставляет такие функции, как доступ к значению по ключу, поиск ключей и значений и т. д.
```kotlin
fun main() {
    val numbersMap = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key4" to 1)

    println("All keys: ${numbersMap.keys}") // [key1, key2, key3, key4]
    println("All values: ${numbersMap.values}") // [1, 2, 3, 1]
    if ("key2" in numbersMap) println("Value by key \"key2\": ${numbersMap["key2"]}")
    if (1 in numbersMap.values) println("The value 1 is in the map")
    if (numbersMap.containsValue(1)) println("The value 1 is in the map") // аналогичен предыдущему условию
}
```

Две `Map`-ы, содержащие равные пары, равны независимо от порядка пар.
```kotlin
fun main() {
    val numbersMap = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key4" to 1)
    val anotherMap = mapOf("key2" to 2, "key1" to 1, "key4" to 1, "key3" to 3)

    println("The maps are equal: ${numbersMap == anotherMap}") // The maps are equal: true
}
```

!!! example [Словари `Map`](samples/03_Arrays/18_Map/src/Main.kt)

```kotlin
fun main() {
    val num = mapOf(1 to "one", 2 to "two", 3 to "three", 4 to "three")
    val k = num.keys
    val v = num.values
    val e = num.entries

    println(k)
    println(v)
    println(e)

    for ((i, j) in e)
        println("The $i is $j!")
}

```

<details>
<summary><em>Output</em></summary>

```
[1, 2, 3, 4]
[one, two, three, three]
[1=one, 2=two, 3=three, 4=three]
The 1 is one!
The 2 is two!
The 3 is three!
The 4 is three!
```

</details>

`MutableMap` — это `Map` с операциями записи, например, можно добавить новую пару “ключ-значение” или обновить значение, связанное с указанным ключом.
```kotlin
fun main() {
    val numbersMap = mutableMapOf("one" to 1, "two" to 2)
    numbersMap.put("three", 3)
    numbersMap["one"] = 11

    println(numbersMap) // {one=11, two=2, three=3}
}
```

По умолчанию реализацией `Map` является `LinkedHashMap` — сохраняет порядок элементов. Альтернативная реализация — `HashMap` — не сохраняет порядок элементов.

!!! example [Изменяемый `Map`](samples/03_Arrays/19_MutableMap/src/Main.kt)

```kotlin
fun main() {
    val num = mutableMapOf(1 to "один", 2 to "два", 3 to "три", 4 to "три")
    num.remove(3)
    println(num)
    num[1] = "восемь"
    num[55] = "пятьдесят пять"
    println(num)
    num.putAll(setOf(6 to "шесть", 9 to "девять"))
    num.putAll(mapOf(16 to "десять и шесть", 29 to "двадцать и девять"))
    println(num)
}

```

<details>
<summary><em>Output</em></summary>

```
{1=один, 2=два, 4=три}
{1=восемь, 2=два, 4=три, 55=пятьдесят пять}
{1=восемь, 2=два, 4=три, 55=пятьдесят пять, 6=шесть, 9=девять, 16=десять и шесть, 29=двадцать и девять}
```

</details>

## 04 Функции
[67117e5d5040133e8429e4e5](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-4)

<dfn title="функция">Функция</dfn> — это группа взаимосвязанных блоков кода, которая выполняет определенную задачу. Функция используется для разбиения программы на разные вспомогательные модули. Это упрощает повторное использование кода и делает программу более управляемой.

[Source](samples/04_Functions/01_NoFun/src/Main.kt)

![Function refactoring](./img/fun-refactor-1.png "refactor")

[Source](samples/04_Functions/02_Fun/src/Main.kt)

![Function refactoring](./img/fun-refactor-2.png "refactor")

![Function refactoring](./img/fun-refactor-3.png "refactor")

![Function refactoring](./img/fun-refactor-4.png "refactor")

![Function refactoring](./img/fun-refactor-5.png "refactor")

![Function refactoring](./img/fun-refactor-7.png "refactor")

В Kotlin функциями называют не только обычные функции, определенные за пределами класса, но и те, что находятся внутри класса, и которые в других языках принято называть методами. В Kotlin функции, определенные внутри классов, называют функциями-членами. Кроме них есть функции-расширения, которые как и функции-члены относятся к классам, но определены за их пределами как и обычные функции. Вместе функции-члены и функции-расширения можно считать методами класса.

Обычные функции и функции-расширения определяются за пределами класса. Их отличие заключается в наличии имени класса в нотации через точку перед именем функции-расширения.

Все функции по умолчанию, то есть без модификатора видимости, являются `public`. Их можно использовать отовсюду. Если функция верхнего уровня (не находится внутри класса) объявлена с модификатором private, ее можно использоватьтолько в данном файле.

![Function declaration](./img/fun-declaration-1.png "declaration")

![Function declaration](./img/fun-declaration-2.png "declaration")

По умолчанию функция получает глобальную видимость (public) — это означает, что все остальные функции (даже функции, объявленные в других файлах проекта) могут использовать эту функцию. Другими словами, если вы не указали модификатор, будет считаться, что используется модификатор "public".

Параметры определяют имена и типы входных данных, необходимых функции для решения задачи. Функции могут требовать от нуля до нескольких и более параметров. Их количество зависит от того, для какой задачи они были спроектированы.

Обратите внимание, что параметры функции всегда доступны только для чтения, то есть в теле функции они не могут менять свои значения. Другими словами, в теле функции параметры — это `val`, а не `var`.

Ключевое слово `return` указывает компилятору, что функция завершила работу и готова передать выходные данные.

Для вызова функции нужно указать ее имя и данные, соответствующие параметрам, как определено в заголовке.

Функции можно определять в файле вне других функций или классов, сами по себе, как например, определяется функция `main`. Такие функции еще называют функциями верхнего уровня (top-level functions).

В Kotlin функции объявляются с помощью ключевого слова `fun`.

Существует два типафункций в зависимости от того, доступнали она в стандартной библиотеке илиопределена пользователем.

- Стандартная библиотечная функция
- Определяемая пользователем функция

!!! example [Использование стандартных библиотечных функций](samples/04_Functions/03_FunTypes/src/Main.kt)

*Пример использования стандартных библиотечных функций `sqrt()` и `log()`.*

```kotlin
import kotlin.math.log
import kotlin.math.sqrt

fun main() {
    val number = 81
    println(sqrt(number.toFloat()))

    val base = 10
    println(log(1000F, base.toFloat()))
}
```

<details>
<summary><em>Output</em></summary>

```
9.0
3.0
```

</details>

**Определяемая пользователем функция** — это функция, которая создается пользователем. Определяемая пользователем функция принимает параметры, выполняет действие и возвращает результат этого действия в виде значения.

Функции Kotlin объявляются с использованием ключевого слова `fun`. Например:

!!! example [Example](samples/04_Functions/04_UserFun/src/Main.kt)

```kotlin
fun main() {
    println(prediction("Афанасий", 45))
}

private fun prediction(name: String, age: Int): String {
    return if (name.count() > 7 && age % 5 == 0) {
        "Все будет ОЧЕНЬ хорошо"
    } else {
        "Все будет отлично"
    }
}

```

<details>
<summary><em>Output</em></summary>

```
Все будет ОЧЕНЬ хорошо
```

</details>

Функции также принимают параметры в качестве аргументов и возвращают значение. Функции Kotlin определяются с использованием нотации Pascal, т.е. `имя:тип` (имя параметра и его тип). Параметры в функции разделяются запятыми.

Если функция не возвращает никакого значения, то ее возвращаемый тип равен `Unit`. Необязательно указывать возвращаемый тип определения функции, который не возвращает никакого значения.

![Function params](./img/fun_01.png "Function params")

### Функции – обязательные и необязательные параметры (значения по умолчанию)
Мы можем определить какие-то параметры функции как необязательные и установить для них значения по умолчанию.

Необязательные параметры обязательно идут в конце списка параметров.

!!! example [Example](samples/04_Functions/05_OptionalParams/src/Main.kt)

```kotlin
fun main() {
    println(sumThree(15, 25, 44))
    println(sumThree(16, 18))
}

fun sumThree(koefA: Int, koefB: Int, koefC: Int = 5): String {
    return "$koefA + $koefB + $koefC = ${koefA + koefB + koefC}"
}

```

<details>
<summary><em>Output</em></summary>

```
15 + 25 + 44 = 84
16 + 18 + 5 = 39
```

</details>

### Функции – именованные параметры
Используя именованные аргументы, мы можем переопределить порядок их передачи параметрам.

Часть аргументов могут передаваться параметрам по позиции. Но если какой-то аргумент передан по имени, то остальные аргументы после него также должны передаваться по имени соответствующих параметров.

Если до обязательного параметра функции идут необязательные параметры, то для обязательного параметра значение передается по имени.

!!! example [Example](samples/04_Functions/06_NamedParams/src/Main.kt)

```kotlin
fun main() {
    println(sumThree(koefC = 15, koefA = 25, koefB = 44))
    println(sumThree(16, koefB = 18))
    println(sumThree(16, koefC = 18, koefB = 75))
    println(myIncrease(koefB = 73, koefC = 64))
}

fun sumThree(koefA: Int, koefB: Int, koefC: Int = 5): String {
    return "$koefA + $koefB + $koefC = ${koefA + koefB + koefC}"
}

fun myIncrease(koefA: Int = 42, koefB: Int, koefC: Int): String {
    return "$koefA + $koefB + $koefC = ${koefA + koefB + koefC}"
}

```

<details>
<summary><em>Output</em></summary>

```
25 + 44 + 15 = 84
16 + 18 + 5 = 39
16 + 75 + 18 = 109
42 + 73 + 64 = 179
```

</details>

### Функции – изменение параметров
По умолчанию все параметры функции равносильны `val`-переменным, поэтому их значение нельзя изменить.

Однако если параметр представляет какой-то сложный объект, то можно изменять отдельные значения в этом объекте.

Изменение элемента массива внутри функции приведет к тому, что также будет изменено значение элемента в том массиве, который передается в качестве аргумента в функцию, так как этот один и тот же массив.

!!! example [Example](samples/04_Functions/07_MutableParams/src/Main.kt)

```kotlin
fun main() {
    val testArr = intArrayOf(9, 7, 6)
    doubleArray(testArr)
    println()
    testArr.forEach { print(it.toString() + "\t") }
}

fun doubleArray(numArr: IntArray) {
    for (i in 0..numArr.size - 1) {
        numArr[i] = numArr[i] * 2
    }
    print("Печать из функции\t")
    numArr.forEach { print(it.toString() + "\t") }
}

```

<details>
<summary><em>Output</em></summary>

```
Печать из функции	18	14	12
18	14	12
```

</details>

### Функции – переменное число параметров
Функция может принимать переменное количество параметров одного типа. Для определения таких параметров применяется ключевое слово `vararg`.

В самой функции мы можем работать с параметром как с последовательностью.

Только один параметр может быть помечен как `vararg`.

!!! example [Example](samples/04_Functions/08_Vararg/src/Main.kt)

```kotlin
fun main() {
    prnStr("Иван", "Петр", "Афанасий", "Владимир", "Дмитрий")
    println()
    prnStr("C++", "Kotlin", "Golang")
    println()
    print(prnSum(1, 9, 5, 16, 73))
}

fun prnStr(vararg name: String) {
    for (item in name) {
        print(item + "\t")
    }
}

fun prnSum(vararg itemNum: Int):Int {
    var result = 0
    for (item in itemNum) result += item
    return result
}

```

<details>
<summary><em>Output</em></summary>

```
Иван	Петр	Афанасий	Владимир	Дмитрий
C++	Kotlin	Golang
104
```

</details>

Если функция принимает несколько параметров, то обычно `vararg`-параметр является последним.

!!! example [Example](samples/04_Functions/09_Vararg/src/Main.kt)

```kotlin
fun main() {
    if(myCount(7, "Иван", "Петр", "Сергей")) {
        println("Людей больше, чем мест")
    }
    else {
        println("Мест хватает для всех")
    }
}

fun myCount(counts: Int, vararg users: String) = if (counts > users.size) {
    false
} else {
    true
}

```

<details>
<summary><em>Output</em></summary>

```
Мест хватает для всех
```

</details>

Однако это необязательно, и, если после `vararg`-параметра идут еще какие-нибудь параметры, то при вызове функции значения этим параметрам передаются через именованные аргументы.

!!! example [Example](samples/04_Functions/10-Vararg/src/Main.kt.kt)

```kotlin
fun main() {
    if(myCount("Иван", "Петр", "Сергей", counts = 2)) {
        println("Людей больше, чем мест")
    }
    else {
        println("Мест хватает для всех")
    }
}

fun myCount(vararg users: String, counts: Int) = if (counts > users.size) {
    false
} else {
    true
}

```

<details>
<summary><em>Output</em></summary>

```
Людей больше, чем мест
```

</details>

### Оператор `*` — spread operator
Оператор `*` (spread operator) (не стоит путать со знаком умножения) позволяет передать параметру в качестве значения элементы из массива.

Обратите внимание на звездочку перед `nums` при вызове функции:
```kotlin
myCount(5, *testArr)
```

Без применения данного оператора мы столкнулись бы с ошибкой, поскольку параметры функции представляют не массив, а неопределенное количество значений типа `Int`.

!!! example [Example](samples/04_Functions/11_SpreadOperator/src/Main.kt)

```kotlin
fun main() {
    val testArr = intArrayOf(8, 9, 6, 7, 3, 4)
    println(myCount(5, *testArr))
}

fun myCount(koef: Int, vararg numbers: Int): Int {
    var summa = 0
    for (item in numbers) summa += item * koef
    return summa
}

```

<details>
<summary><em>Output</em></summary>

```
185
```

</details>

### Функции – оператор `return`

![Return operator](./img/fun_02.png "Return operator")

### Функции – вернули `Unit`
Если функция возвращает значение `Unit`, мы также можем использовать оператор `return` для возврата из функции.

![Unit type](./img/fun_03.png "Unit type")

### Функции – однострочные функции
Однострочные функции (single expression function) используют сокращенный синтаксис определения функции в виде одного выражения. Эта форма позволяет опустить возвращаемый тип и оператор `return`.

После списка параметров не указывается возвращаемый тип. Возвращаемый тип будет выводится компилятором. Далее через оператор присвоения `=` определяется тело функции в виде одного выражения.

!!! example [Example](samples/04_Functions/12_SingleExpressionFun/src/Main.kt)

```kotlin
import java.lang.Math.pow
import kotlin.math.pow

fun main() {
    val testBasis = 7.0
    val testDegree = 4.0
    println(nthDegreeRoot(testBasis, testDegree))
    println(nthDegreeRootKotlin(testBasis, testDegree))
}

fun nthDegreeRoot(basis: Double, degree: Double) = pow(pow(basis, degree), 1 /2.0)

fun nthDegreeRootKotlin(basis: Double, degree: Double) = basis.pow(degree).pow(1 / 2.0)

```

<details>
<summary><em>Output</em></summary>

```
49.0
49.0
```

</details>

### Функции – локальная функция
Одни функции могут быть определены внутри других функций. Внутренние или вложенные функции еще называют локальными.

Локальные функции могут определять действия, которые используются только в рамках какой-то конкретной функции и нигде больше не применяются.

![Local function](./img/fun_04.png "Local function")

### Функции – рефакторинг кода

![Function refactoring](./img/fun_05.png "Function refactoring")

### Функции – перегрузка
Каждый раз при вызове функции должно быть понятно, какая функция будет выполняться.

Обычно это достигается через разницу в списке параметров:
- разное количество параметров;
- разные типы у параметров;
- разный порядок параметров.

Одного возвращаемого типа недостаточно для различия двух функций. Т.е. если одна функция возвращает Int, а другая возвращает строку — этого будет недостаточно, чтобы компилятор понял, какую из них вызвать, ведь тип у параметров один и тот же.

!!! example [Example](samples/04_Functions/13_Overloading/src/Main.kt)

```kotlin
fun main() {
    println("7 < 9 < 16 => " + ascSequence(7, 9, 16))
    println("7.8 < 7.81 < 16.85 => " + ascSequence(7.8, 7.81, 16.85))
    println("7.8f < 7.81f < 16.85f => " + ascSequence(7.8f, 7.81f, 16.85f))
    println("87 < 69.3F < 56.15 => " + ascSequence(87, 69.3F, 56.15))
}

fun ascSequence(a: Int, b: Int, c: Int) = b in (a + 1)..c

fun ascSequence(a: Double, b: Double, c: Double) = a < b && b < c

fun ascSequence(a: Float, b: Float, c: Float) = a < b && b < c

fun ascSequence(a: Int, b: Float, c: Double) = a < b && b < c

```

<details>
<summary><em>Output</em></summary>

```
7 < 9 < 16 => true
7.8 < 7.81 < 16.85 => true
7.8f < 7.81f < 16.85f => true
87 < 69.3F < 56.15 => false
```

</details>

> Почему перегруженные функции для типов `Double`, `Float` и смешанных нельзя записать так же, как функцию для типа `Int`?
>
> Тело функции для типа `Int` можно записать как проверку диапазона в силу дискретности проверяемых значений. Если записать остальные функции так же, то при равенстве некоторых из входящих параметров функция будет выдавать неверный результат.

### Функции – присвоение переменной
Переменная может представлять функцию. С помощью типа функции можно определить, какие именно функции переменная может представлять.

Чтобы передать функцию, перед названием функции ставится оператор `::`.

Затем через имя переменной фактически можно обращаться к функции.

!!! example [Example](samples/04_Functions/14_AssigningToVar/src/Main.kt)

```kotlin
fun main() {
    val operationFun: (Int, Int) -> Int
    val testA = (100..999).random()
    val testB = (100..999).random()
    if (testA < testB) {
        operationFun = ::addFun
    } else {
        operationFun = ::myDiff
    }
    print("$testA $testB => ")
    printResult(operationFun(testA, testB))
}

fun myDiff(a: Int, b: Int) = a - b

fun addFun(a: Int, b: Int) = a + b

fun printResult(function: Int) {
    println(function)
}

```

<details>
<summary><em>Output</em></summary>

```
870 767 => 103
```

</details>

### Функции – примеры использования
Примеры использования функции как переменной или в качестве параметра для другой функции.

!!! example [Example](samples/04_Functions/15_UsageExamples/src/Main.kt)

```kotlin
fun main() {
    val operationFun = ::myFun
    printResult(operationFun, 5, 67)
    printResult(::addFun, 72, 28)
    println(myDiff(addFun(67, 45), 67))
}

fun myDiff(a: Int, b: Int) = a - b

fun addFun(a: Int, b: Int) = a + b

fun myFun(a: Int, b: Int) = a * b

fun printResult(function: (Int, Int) -> Int, a: Int, b: Int) {
    println(function(a, b))
}

```

<details>
<summary><em>Output</em></summary>

```
335
100
45
```

</details>

### Функции высокого порядка
Функции высокого порядка (high order function) — это функции, которые либо принимают функцию в качестве параметра, либо возвращают функцию, либо и то, и другое.

![High order function](./img/fun_06.png "High order function")

!!! example [Example](samples/04_Functions/16_HighOrderFun/src/Main.kt)

```kotlin
fun main() {
    printResult(::addFun, 72, 28)
    prnRes(::myFun)
}

fun addFun(a: Int, b: Int) = a + b

fun myFun() {
    println("Вы распечатали строку")
}

fun printResult(function: (Int, Int) -> Int, a: Int, b: Int) {
    println(function(a, b))
}

fun prnRes(function: () -> Unit) {
    function()
}

```

<details>
<summary><em>Output</em></summary>

```
100
Вы распечатали строку
```

</details>

### Возвращение функции из функции
В более редких случаях может потребоваться возвратить функцию из другой функции. В этом случае для функции в качестве возвращаемого типа устанавливается тип другой функции. А в теле функции возвращается лямбда выражение.

!!! example [Example](samples/04_Functions/17_ReturnFun/src/Main.kt)

```kotlin
fun main() {
    val actionOne = selectAction(1)
    println(actionOne(15, 95))
    val actionTwo = selectAction(2)
    println(actionTwo(43, 67))
}

fun selectAction(key: Int): (Int, Int) -> Int {
    return when (key) {
        1 -> ::sumFun
        2 -> ::subtractionFun
        else -> ::emptyFun
    }
}

fun sumFun(a: Int, b: Int) = a + b

fun subtractionFun(a: Int, b: Int) = a - b

fun emptyFun(a: Int, b: Int) = 0

```

<details>
<summary><em>Output</em></summary>

```
110
-24
```

</details>

### Анонимные функции
Анонимные функции выглядят как обычные за тем исключением, что они не имеют имени.

!!! example [Example](samples/04_Functions/18_AnonymousFun/src/Main.kt)

```kotlin
fun main() {
    val message = fun() = println("Hello, World!!!")
    message()

    val sumFun = fun(x: Int, y: Int) = x + y
    println(sumFun(18, 37))
}

```

<details>
<summary><em>Output</em></summary>

```
Hello, World!!!
55
```

</details>

### Анонимные функции как аргумент
Анонимную функцию можно передавать в функцию, если параметр соответствует типу этой функции.

!!! example [Example](samples/04_Functions/19_AnonymousFunAsArg/src/Main.kt)

```kotlin
fun main() {
    doOperation(9, 5, fun(x: Int, y: Int): Int = x + y)
    doOperation(9, 5, fun(x: Int, y: Int): Int = x - y)

    val action = fun(x: Int, y: Int): Int = x * y
    doOperation(9, 5, action)
}

fun doOperation(x: Int, y: Int, op: (Int, Int) -> Int) {
    val result = op(x, y)
    println(result)
}

```

<details>
<summary><em>Output</em></summary>

```
14
4
45
```

</details>

### Возвращение анонимной функции из функции
Фунция может возвращать анонимную функцию в качестве результата.

!!! example [Example](samples/04_Functions/20_ReturnAnonymousFun/src/Main.kt)

```kotlin
fun main() {
    val action1 = selectAction(1)
    val result1 = action1(4, 5)
    println(result1)
    val action2 = selectAction(2)
    println(action2(4, 5))
    val action3 = selectAction(3)
    println(action3(4, 5))
    val action = selectAction(9)
    println(action(4, 5))
}

fun selectAction(key: Int): (Int, Int) -> Int {
    return when (key) {
        1 -> fun(x: Int, y: Int): Int = x + y
        2 -> fun(x: Int, y: Int): Int = x - y
        3 -> fun(x: Int, y: Int): Int = x * y
        else -> fun(_: Int, _: Int): Int = 0
    }
}

```

<details>
<summary><em>Output</em></summary>

```
9
-1
20
0
```

</details>

### Функции – лямбда-выражения
Лямбда-выражения представляют небольшие кусочки кода, которые выполняют некоторые действия. Фактически лямбды преставляют сокращенную запись функций. При этом лямбды, как и обычные и анонимные функции, могут передаваться в качестве значений переменным и параметрам функции.

![Lambda statement](./img/fun_07.png "Lambda statement")

### Лямбда-выражения. Передача параметров
Лямбды как и функции могут принимать параметры. Для передачи параметров используется стрелка `->`. Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки.

![Lambda params](./img/fun_08.png "Lambda params")

### Лямбда-выражения как аргументы функций

![Lambda as arg](./img/fun_09.png "Lambda as arg")

### Ключевые особенности функций в Kotlin
- Функция используется для определения задачи, которую можно выполнять столько раз, сколько потребуется без необходимости повторно писать код;
- Функции могут принимать ноль или более параметров и, при необходимости, возвращать значение;
- Для ясности при вызове функции можно использовать именованные аргументы;
- Указание значений функций по умолчанию может упростить работу и сократить объем кода;
- Функции могут обладать одним и тем же названием с разными параметрами. Это называется перегрузкой;
- Можно назначать функции переменным и передавать их другим функциям;
- У функций может быть специальный возвращаемый тип `Nothing`, который сообщает Kotlin, что эта функция никогда не завершится;
- Стремитесь создавать функции с четкими и понятными названиями;
- Одна функция должна выполнять ОДНУ задачу которая соответствует её названию.

### Функции - задачи
[675197445040133e8429e7a7](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345146)

**Обязательно выполняется задача 1 и одна из задач на шифрование сообщения**

#### 1. Камень-Ножницы-Бумага (три события)
Создать консольную игру "Камень-Ножницы-Бумага" (три события). На консоль выводится выбор компьютера (случайное значение) и выбор игрока. Для ускорения ввода выбора игрока можно условиться, что, например, 1 — это камень, 2 — ножницы, 3 — бумага. Выполненное задание представить в виде ссылки на GitHub

Победитель определяется по следующим правилам:

- Бумага побеждает камень («бумага обёртывает камень»).
- Камень побеждает ножницы («камень затупляет или ломает ножницы»).
- Ножницы побеждают бумагу («ножницы разрезают бумагу»).

Если игроки показали одинаковый знак, то засчитывается ничья и игра переигрывается.

[Решение](src/04_Functions/Task_01/src)

#### 2. Биграммный шифр Порты
Создать программу, для шифровки и расшифровки сообщений. Программа запрашивает исходное сообщение, вспомогательный символ и спрашивает — использовать типовую таблицу или генерировать случайную. Типовая таблица предоставлена на экране. При генерации случайной таблицы каждой паре букв сопоставляется случайное число от 1 до 999. Числа в таблице не повторяются. Каждое число состоит из трех знаков. Если число меньше 100, то оно дописывается до трех знаков путем добавления нулей перед числом.

В результате работы на консоль выводится исходное сообщение разбитое по парам букв с пробелами между парами, зашифрованное сообщение состоящее из цифр разбитых в группы по три цифры и пробела между группами и шифровальная таблица. Группа цифр из зашифрованного сообщения пишется под соответствующей парой символов исходного сообщения.

Шифр Порты, представленный им в виде таблицы, является первым известным биграммным шифром. Размер его таблицы составлял 20 х 20 ячеек; наверху горизонтально и слева вертикально записывался стандартный алфавит (в нем не было букв J, К, U, W, X и Z). В ячейках таблицы могли быть записаны **любые числа, буквы или символы** — сам Джованни Порта пользовался символами — **при условии, что содержимое ни одной из ячеек не повторялось**. Применительно к русскому языку таблица шифрозамен может выглядеть следующим образом.

| А     | Б   | В   | Г   | Д   | Е (Ё) | Ж   | 3   | И (Й) | К   | Л   | М   | Н   | О   | П   | Р   | С   | Т   | У   | Ф   | X   | Ц   | Ч   | Ш   | Щ   | Ъ   | Ы   | Ь   | Э   | Ю   | Я   |     |
| ----- | --- | --- | --- | --- | ----- | --- | --- | ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| А     | 1   | 2   | 3   | 4   | 5     | 6   | 7   | 8     | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  | 19  | 20  | 21  | 22  | 23  | 24  | 25  | 26  | 27  | 28  | 29  | 30  | 31  |
| Б     | 32  | 33  | 34  | 35  | 36    | 37  | 38  | 39    | 40  | 41  | 42  | 43  | 44  | 45  | 46  | 47  | 48  | 49  | 50  | 51  | 52  | 53  | 54  | 55  | 56  | 57  | 58  | 59  | 60  | 61  | 62  |
| В     | 63  | 64  | 65  | 66  | 67    | 68  | 69  | 70    | 71  | 72  | 73  | 74  | 75  | 76  | 77  | 78  | 79  | 80  | 81  | 82  | 83  | 84  | 85  | 86  | 87  | 88  | 89  | 90  | 91  | 92  | 93  |
| Г     | 94  | 95  | 96  | 97  | 98    | 99  | 100 | 101   | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 123 | 124 |
| Д     | 125 | 126 | 127 | 128 | 129   | 130 | 131 | 132   | 133 | 134 | 135 | 136 | 137 | 138 | 139 | 140 | 141 | 142 | 143 | 144 | 145 | 146 | 147 | 148 | 149 | 150 | 151 | 152 | 153 | 154 | 155 |
| Е (Ё) | 156 | 157 | 158 | 159 | 160   | 161 | 162 | 163   | 164 | 165 | 166 | 167 | 168 | 169 | 170 | 171 | 172 | 173 | 174 | 175 | 176 | 177 | 178 | 179 | 180 | 181 | 182 | 183 | 184 | 185 | 186 |
| Ж     | 187 | 188 | 189 | 190 | 191   | 192 | 193 | 194   | 195 | 196 | 197 | 198 | 199 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214 | 215 | 216 | 217 |
| 3     | 218 | 219 | 220 | 221 | 222   | 223 | 224 | 225   | 226 | 227 | 228 | 229 | 230 | 231 | 232 | 233 | 234 | 235 | 236 | 237 | 238 | 239 | 240 | 241 | 242 | 243 | 244 | 245 | 246 | 247 | 248 |
| И (Й) | 249 | 250 | 251 | 252 | 253   | 254 | 255 | 256   | 257 | 258 | 259 | 260 | 261 | 262 | 263 | 264 | 265 | 266 | 267 | 268 | 269 | 270 | 271 | 272 | 273 | 274 | 275 | 276 | 277 | 278 | 279 |
| К     | 280 | 281 | 282 | 283 | 284   | 285 | 286 | 287   | 288 | 289 | 290 | 291 | 292 | 293 | 294 | 295 | 296 | 297 | 298 | 299 | 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | 309 | 310 |
| Л     | 311 | 312 | 313 | 314 | 315   | 316 | 317 | 318   | 319 | 320 | 321 | 322 | 323 | 324 | 325 | 326 | 327 | 328 | 329 | 330 | 331 | 332 | 333 | 334 | 335 | 336 | 337 | 338 | 339 | 340 | 341 |
| М     | 342 | 343 | 344 | 345 | 346   | 347 | 348 | 349   | 350 | 351 | 352 | 353 | 354 | 355 | 356 | 357 | 358 | 359 | 360 | 361 | 362 | 363 | 364 | 365 | 366 | 367 | 368 | 369 | 370 | 371 | 372 |
| Н     | 373 | 374 | 375 | 376 | 377   | 378 | 379 | 380   | 381 | 382 | 383 | 384 | 385 | 386 | 387 | 388 | 389 | 390 | 391 | 392 | 393 | 394 | 395 | 396 | 397 | 398 | 399 | 400 | 401 | 402 | 403 |
| О     | 404 | 405 | 406 | 407 | 408   | 409 | 410 | 411   | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 425 | 426 | 427 | 428 | 429 | 430 | 431 | 432 | 433 | 434 |
| П     | 435 | 436 | 437 | 438 | 439   | 440 | 441 | 442   | 443 | 444 | 445 | 446 | 447 | 448 | 449 | 450 | 451 | 452 | 453 | 454 | 455 | 456 | 457 | 458 | 459 | 460 | 461 | 462 | 463 | 464 | 465 |
| Р     | 466 | 467 | 468 | 469 | 470   | 471 | 472 | 473   | 474 | 475 | 476 | 477 | 478 | 479 | 480 | 481 | 482 | 483 | 484 | 485 | 486 | 487 | 488 | 489 | 490 | 491 | 492 | 493 | 494 | 495 | 496 |
| С     | 497 | 498 | 499 | 500 | 501   | 502 | 503 | 504   | 505 | 506 | 507 | 508 | 509 | 510 | 511 | 512 | 513 | 514 | 515 | 516 | 517 | 518 | 519 | 520 | 521 | 522 | 523 | 524 | 525 | 526 | 527 |
| Т     | 528 | 529 | 530 | 531 | 532   | 533 | 534 | 535   | 536 | 537 | 538 | 539 | 540 | 541 | 542 | 543 | 544 | 545 | 546 | 547 | 548 | 549 | 550 | 551 | 552 | 553 | 554 | 555 | 556 | 557 | 558 |
| У     | 559 | 560 | 561 | 562 | 563   | 564 | 565 | 566   | 567 | 568 | 569 | 570 | 571 | 572 | 573 | 574 | 575 | 576 | 577 | 578 | 579 | 580 | 581 | 582 | 583 | 584 | 585 | 586 | 587 | 588 | 589 |
| Ф     | 590 | 591 | 592 | 593 | 594   | 595 | 596 | 597   | 598 | 599 | 600 | 601 | 602 | 603 | 604 | 605 | 606 | 607 | 608 | 609 | 610 | 611 | 612 | 613 | 614 | 615 | 616 | 617 | 618 | 619 | 620 |
| X     | 621 | 622 | 623 | 624 | 625   | 626 | 627 | 628   | 629 | 630 | 631 | 632 | 633 | 634 | 635 | 636 | 637 | 638 | 639 | 640 | 641 | 642 | 643 | 644 | 645 | 646 | 647 | 648 | 649 | 650 | 651 |
| Ц     | 652 | 653 | 654 | 655 | 656   | 657 | 658 | 659   | 660 | 661 | 662 | 663 | 664 | 665 | 666 | 667 | 668 | 669 | 670 | 671 | 672 | 673 | 674 | 675 | 676 | 677 | 678 | 679 | 680 | 681 | 682 |
| Ч     | 683 | 684 | 685 | 686 | 687   | 688 | 689 | 690   | 691 | 692 | 693 | 694 | 695 | 696 | 697 | 698 | 699 | 700 | 701 | 702 | 703 | 704 | 705 | 706 | 707 | 708 | 709 | 710 | 711 | 712 | 713 |
| Ш     | 714 | 715 | 716 | 717 | 718   | 719 | 720 | 721   | 722 | 723 | 724 | 725 | 726 | 727 | 728 | 729 | 730 | 731 | 732 | 733 | 734 | 735 | 736 | 737 | 738 | 739 | 740 | 741 | 742 | 743 | 744 |
| Щ     | 745 | 746 | 747 | 748 | 749   | 750 | 751 | 752   | 753 | 754 | 755 | 756 | 757 | 758 | 759 | 760 | 761 | 762 | 763 | 764 | 765 | 766 | 767 | 768 | 769 | 770 | 771 | 772 | 773 | 774 | 775 |
| Ъ     | 776 | 777 | 778 | 779 | 780   | 781 | 782 | 783   | 784 | 785 | 786 | 787 | 788 | 789 | 790 | 791 | 792 | 793 | 794 | 795 | 796 | 797 | 798 | 799 | 800 | 801 | 802 | 803 | 804 | 805 | 806 |
| Ы     | 807 | 80S | 809 | 810 | 811   | 812 | 813 | 814   | 815 | 816 | 817 | 818 | 819 | 820 | 821 | 822 | 823 | 824 | 825 | 826 | 827 | 828 | 829 | 830 | 831 | 832 | 833 | 834 | 835 | 836 | 837 |
| Ь     | 838 | 839 | 840 | 841 | 842   | 843 | 844 | 845   | 846 | 847 | 848 | 849 | 850 | 851 | 852 | 853 | 854 | 855 | 856 | 857 | 858 | 859 | 860 | 861 | 862 | 863 | 864 | 865 | 866 | 867 | 868 |
| Э     | 869 | 870 | 871 | 872 | 873   | 874 | 875 | 876   | 877 | 878 | 879 | 880 | 881 | 882 | 883 | 884 | 885 | 886 | 887 | 888 | 889 | 890 | 891 | 892 | 893 | 894 | 895 | 896 | 897 | 898 | 899 |
| Ю     | 900 | 901 | 902 | 903 | 904   | 905 | 906 | 907   | 908 | 909 | 910 | 911 | 912 | 913 | 914 | 915 | 916 | 917 | 918 | 919 | 920 | 921 | 922 | 923 | 924 | 925 | 926 | 927 | 928 | 929 | 930 |
| Я     | 931 | 932 | 933 | 934 | 935   | 936 | 937 | 938   | 939 | 940 | 941 | 942 | 943 | 944 | 945 | 946 | 947 | 948 | 949 | 950 | 951 | 952 | 953 | 954 | 955 | 956 | 957 | 958 | 959 | 960 | 961 |

Шифрование выполняется парами букв исходного сообщения. Первая буква пары указывает на строку шифрозамены, вторая — на столбец. В случае нечетного количества букв в исходном сообщении к нему добавляется вспомогательный символ («пустой знак»). Например, исходное сообщение «АБ РА МО В», зашифрованное — «002 466 355 093». В качестве вспомогательного символа использована буква «Я».

[Решение](src/04_Functions/Task_02/src)

#### 3. Программа шифрования методом Вижинера
Написать программу, реализующую шифровку и расшифровку сообщения с помощью шифра Виженера. Программа запрашивает исходное сообщение, ключ и спрашивает, использовать типовую таблицу или генерировать случайную. Типовая таблица предоставлена на экране.

В результате работы на консоль выводится исходное сообщение, под ним ключ (повторяющийся столько раз, сколько это необходимо). Третьей строкой выводится зашифрованное сообщение. Буквы должны находиться друг под другом согласно порядкового номера (первая буква ключа под первой буквой исходного сообщения. Под ними же первая буква зашифрованного сообщения и т.д.). Также выводится шифровальная таблица.

Случайная шифровальная таблица получается путем случайного перемешивания символов первой строки. Все последующие строки сдвигаются относительно первой строки. Вторая строка — на одну ячейку, третья строка — на две ячейки и т.д.  Для усложнения задачи можно каждую последующую строку сдвигать на случайную величину относительно первой строки, с условием, что величина сдвига для каждой строки различна (не повторяется).

Шифр Виженера состоит из последовательности нескольких шифров Цезаря с различными значениями сдвига. Для зашифровывания может использоваться таблица алфавитов, называемая tabula recta или квадрат (таблица) Виженера. Применительно к русскому алфавиту таблица Виженера составляется из строк по 33 символов (начальная строка может быть перемешана), причём каждая следующая строка сдвигается на несколько позиций. Таким образом, в таблице получается 33 различных шифров Цезаря. На каждом этапе шифрования используются различные алфавиты, выбираемые в зависимости от символа ключевого слова.

| А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я |   |
| - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
| А | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я |
| Б | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А |
| В | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б |
| Г | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В |
| Д | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г |
| Е | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д |
| Ё | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е |
| Ж | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё |
| З | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж |
| И | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З |
| Й | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И |
| К | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й |
| Л | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К |
| М | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л |
| Н | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М |
| О | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н |
| П | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О |
| Р | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П |
| С | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р |
| Т | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С |
| У | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т |
| Ф | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У |
| Х | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф |
| Ц | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х |
| Ч | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц |
| Ш | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч |
| Щ | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш |
| Ъ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ |
| Ы | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ |
| Ь | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы |
| Э | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь |
| Ю | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э |
| Я | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю |

Например, предположим, что исходный текст и ключ имеют следующий вид:

- Текст: `ШИФРВИЖЕНЕР`
- Ключ:  `КОД`

Чтобы зашифровать текст необходимо записать ключевое слово «КОД» циклически до тех пор, пока его длина не будет соответствовать длине исходного текста.

- Текст: `ШИФРВИЖЕНЕР`
- Ключ:  `КОДКОДКОДКО`
- Итог:  `ГЧШЫРМСУСПЯ`

Первый символ исходного текста ("Ш") зашифрован последовательностью К, которая является первым символом ключа. Первый символ зашифрованного текста ("К") находится на пересечении строки К и столбца Ш в таблице Виженера. Точно так же для второго символа исходного текста используется второй символ ключа; то есть второй символ зашифрованного текста ("И") получается на пересечении строки О и столбца И. Остальная часть исходного текста шифруется подобным способом.

[Решение](src/04_Functions/Task_03/src)

#### 4. Программа шифрования методом омофонической замены
Написать программу, реализующую шифровку и расшифровку сообщения методом омофонической замены. На входе программа запрашивает исходное сообщение. В результате работы программа выводит на консоль исходное сообщение, зашифрованное сообщение состоящее из цифр разбитых в группы по три цифры и пробела между группами и шифровальную таблицу. Шифровальную таблицу допускается выводить на консоль в виде строк, где каждая строка состоит из символа алфавита и соответствующего набора чисел разделенных пробелами. Каждое число состоит из трех знаков. Если число меньше 100, то оно дописывается до трех знаков путем добавления нулей перед числом.

Шифровальная таблица составляется путем сопоставления букве алфавита набора случайных неповторяющихся чисел от 0 до 999. Количество случайных чисел для каждой буквы алфавита равно коэффициенту вероятности умноженному на 1000. Числа также не повторяются для всей таблицы. Можно использовать типовую таблицу — то есть для символа 'А' используются строки от "000" до "068", так как вероятность появления символа 'А' равна 0.069. Для символа 'Б' используются строки от "069" до "081" и т.д. Для символа 'Я' используются строки от "837" до "853". Для символа ПРОБЕЛ используются строки от "854" до "999".

Каждая буква шифруется набором из трех цифр. Если букве сопоставляется число, состоящее менее, чем из трех знаков, то перед числом дописываются нули. Если одна и та же буква повторяется в исходном сообщении несколько раз, то для ее замены используются разные и не повторяющиеся числа из соответствующего набора. В случае, если количество повторений буквы больше, чем чисел в наборе, то возможно повторное использование чисел из соответствующего набора, но до тех пор, пока набор не исчерпает себя и т.д.

Для дешифровки можно использовать типовую таблицу в которой строки из чисел расположены по порядку. Естественно, что шифруем тогда тоже с использованием типовой таблицы.

Шифрование методом омофонической замены известно с 15 века.

Симеоне де Крема в 1401 году впервые использовал таблицы омофонов для равномерной частотности гласных букв при помощи многозначной замены.

Леон Баттиста Альберти в своей книге «Трактат о шифрах», опубликованной в 1466 году, описал шифр замены, в котором одной букве сопоставляется несколько элементов.

В 1401 г. Симеоне де Крема стал использовать таблицы омофонов для сокрытия частоты появления гласных букв в тексте при помощи более чем одной шифрозамены. Такие шифры позже стали называться шифрами многозначной замены или омофонами. Они получили развитие в XV веке. В книге «Трактат о шифрах» Леона Баттисты Альберти (итальянский ученый, архитектор, теоретик искусства, секретарь папы Климентия XII), опубликованной в 1466 г., приводится описание шифра замены, в котором каждой букве ставится в соответствие несколько эквивалентов, число которых пропорционально частоте встречаемости буквы в открытом тексте. Так, если ориентироваться на то число шифрозамен для буквы О должно составлять 94, для буквы Е — 71 и т.д. При этом каждая шифрозамена должна состоять из 3 цифр и их общее количество равно 1000. На рис. представлен фрагмент таблицы шифрозамен.

При шифровании символ исходного сообщения заменяется на любую шифрозамену из своего столбца. Если символ встречается повторно, то, как правило, используют разные шифрозамены. Например, исходное сообщение «АБРАМОВ» после шифрования может выглядеть «357 990 374 678 037 828 175».

*Вероятность появления букв русского алфавита*
| Буква | Вероятность | Буква | Вероятность | Буква | Вероятность | Буква | Вероятность |
| ----- | ----------- | ----- | ----------- | ----- | ----------- | ----- | ----------- |
| А     | 0,069       | И     | 0,064       | Р     | 0,042       | Ш     | 0,006       |
| Б     | 0,013       | Й     | 0,010       | С     | 0,046       | Щ     | 0,004       |
| В     | 0,038       | К     | 0,029       | Т     | 0,054       | Ъ     | 0,001       |
| Г     | 0,014       | Л     | 0,039       | У     | 0,023       | Ы     | 0,015       |
| Д     | 0,024       | М     | 0,027       | Ф     | 0,003       | Ь     | 0,013       |
| Е,Ё   | 0,071       | Н     | 0,057       | Х     | 0,008       | Э     | 0,002       |
| Ж     | 0,007       | О     | 0,094       | Ц     | 0,005       | Ю     | 0,005       |
| З     | 0,016       | П     | 0,026       | Ч     | 0,012       | Я     | 0,017       |

(*) (В таблице представлены результаты частотного анализа художественных и научно-технических текстов общим объёмом более 1 млн символов. При этих же условиях вероятность «пробела» составляет 0,146.)

Так как вероятность встретить самую редкую букву примерно равна одной тысячной, шифрование методом омофонической замены открытого текста можно осуществить по таблице шифрозамен, где каждая шифрозамена состоит из 3 цифр и их общее количество равно 1000. В таком случае для самого редкого элемента понадобится ровно один символ.

Пример такой таблицы представлен ниже.

| №  | А   | Б   | В   | … | Е   | … | О   | П   | Р   | … | Э   | Ю   | Я   |
| -- | --- | --- | --- | - | --- | - | --- | --- | --- | - | --- | --- | --- |
| 1  | 12  | 128 | 325 | … | 37  | … | 64  | 58  | 265 | … | 501 | 64  | 106 |
| 2  | 659 | 556 | 26  | … | 700 | … | 149 | 73  | 333 | … | 248 | 749 | 98  |
| …  | …   | …   | …   | … | …   | … | …   | …   | …   | … |     | …   | …   |
| 17 | 111 |     | 61  | … | 144 | … | 903 | 656 | 476 | … |     |     | 453 |
| …  | …   |     | …   | … | …   | … | …   | …   | …   | … |     |     |     |
| 38 | 366 |     | 804 | … | …   | … | 123 |     | 865 | … |     |     |     |
| …  | …   |     |     | … | …   | … | …   |     | …   | … |     |     |     |
| 69 | 95  |     |     |   | …   |   | 10  |     |     |   |     |     |     |
| …  |     |     |     |   | …   |   | …   |     |     |   |     |     |     |
| 71 |     |     |     |   | 541 |   | 268 |     |     |   |     |     |     |
| …  |     |     |     |   |     |   | …   |     |     |   |     |     |     |
| 94 |     |     |     |   |     |   | 479 |     |     |   |     |     |     |

Некоторые поля в таблице пусты, так как для каждого символа исходного алфавита количество замен различно. Например, по этому фрагменту можно зашифровать слово «ВЕРА». Каждую букву исходного сообщения, в данном случае слова, следует заменить на одну из шифрозамен в столбце этой буквы. Если буквы заменить такими шифрозаменами: «В» — 325, «Е» — 700, «Р» — 865, «А» — 095, тогда зашифрованное слово имеет вид числовой последовательности «325 700 865 095».

[Решение](src/04_Functions/Task_04/src)
