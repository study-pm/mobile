<link href="styles.css" rel="stylesheet" />

# Разработка мобильных приложений 2023-2024 (МДК 01.03)
[66d6b6e6d048d3735272200f](https://e-learn.petrocollege.ru/course/view.php?id=7179)

- [Общее](#общее)
  - [Дополнительные материалы по курсу](#дополнительные-материалы-по-курсу)
  - [Официальные бесплатные курсы от Google](#официальные-бесплатные-курсы-от-google)
  - [Примерные теоретические вопросы к экзамену](#примерные-теоретические-вопросы-к-экзамену)
  - [Примерные практические задания на экзамен](#примерные-практические-задания-на-экзамен)
  - [Критерии оценки](#критерии-оценки)
    - [Группы 52-03в и 52-02в.](#группы-52-03в-и-52-02в)
    - [Группа 51-02](#группа-51-02)
    - [Группы 53-02в, 53-03в, 53-09в, 52-00в, 52-04в, 52-08в](#группы-53-02в-53-03в-53-09в-52-00в-52-04в-52-08в)
- [01 Введение](#01-введение)
  - [Коротко о GitHub](#коротко-о-github)
  - [Подключение VCS к IntelliJ IDEA](#подключение-vcs-к-intellij-idea)
  - [Хекслет](#хекслет)
- [02 Синтаксис языка. Управляющие конструкции — решение задач](#02-синтаксис-языка-управляющие-конструкции--решение-задач)
  - [Основной синтаксис](#основной-синтаксис)
    - [Определение имени пакета и импорт](#определение-имени-пакета-и-импорт)
    - [Точка входа в программу](#точка-входа-в-программу)
    - [Вывод в стандартный поток (с помощью `print()` и `println()`)](#вывод-в-стандартный-поток-с-помощью-print-и-println)
    - [Чтение данных с консоли](#чтение-данных-с-консоли)
    - [Переменные. Объявление переменных](#переменные-объявление-переменных)
  - [Основные типы](#основные-типы)
    - [Числа](#числа)
      - [Целочисленные типы](#целочисленные-типы)
      - [Типы с плавающей точкой](#типы-с-плавающей-точкой)
      - [Представление чисел в JVM](#представление-чисел-в-jvm)
      - [Символьные постоянные](#символьные-постоянные)
      - [Явные преобразования](#явные-преобразования)
      - [Арифметические операции](#арифметические-операции)
        - [Деление целых чисел](#деление-целых-чисел)
        - [Побитовые операции](#побитовые-операции)
      - [Сравнение чисел с плавающей точкой](#сравнение-чисел-с-плавающей-точкой)
      - [Целые беззнаковые числа](#целые-беззнаковые-числа)
        - [Беззнаковые массивы и диапазоны](#беззнаковые-массивы-и-диапазоны)
        - [Литералы](#литералы)
    - [Логический тип](#логический-тип)
    - [Символы](#символы)
    - [Строки](#строки)
      - [Строковые литералы](#строковые-литералы)
      - [Строковые шаблоны](#строковые-шаблоны)
    - [Массивы](#массивы)
      - [Массивы примитивных типов](#массивы-примитивных-типов)
  - [Условия и циклы](#условия-и-циклы)
    - [Условное выражение `if`](#условное-выражение-if)
    - [Условное выражение `when`](#условное-выражение-when)
    - [Цикл `for`](#цикл-for)
    - [Цикл `while`](#цикл-while)
    - [Break и continue в циклах](#break-и-continue-в-циклах)
  - [Операторы перехода](#операторы-перехода)
    - [Метки операторов break и continue](#метки-операторов-break-и-continue)
    - [Возврат к меткам](#возврат-к-меткам)
  - [Диапазоны и прогрессии](#диапазоны-и-прогрессии)
    - [Диапазоны](#диапазоны)
    - [Прогрессии](#прогрессии)
  - [Основы — задачи](#основы--задачи)
    - [1. Задача 1.](#1-задача-1)
    - [2. Задача 2.](#2-задача-2)
    - [3. Задача 3.](#3-задача-3)
    - [4. Задача 4.](#4-задача-4)
    - [5. Задача 5.](#5-задача-5)
    - [6. Задача 6.](#6-задача-6)
- [03 Массивы, коллекции](#03-массивы-коллекции)
  - [Массивы](#массивы-1)
    - [Объявление массива с использованием библиотечного метода `arrayOf()`](#объявление-массива-с-использованием-библиотечного-метода-arrayof)
    - [Свойство `indices`](#свойство-indices)
    - [Объявление массива неустановленных ("пустых"/"нулевых") значений и его инициализация (`arrayOfNulls()`)](#объявление-массива-неустановленных-пустыхнулевых-значений-и-его-инициализация-arrayofnulls)
    - [Создание пустого массива (`emptyArray()`)](#создание-пустого-массива-emptyarray)
    - [`val` vs `var`](#val-vs-var)
    - [Генерация значений с помощью инициализатора. Конструктор `Array()`](#генерация-значений-с-помощью-инициализатора-конструктор-array)
    - [Вывод значений массива. Класс `Arrays`](#вывод-значений-массива-класс-arrays)
    - [Массивы примитивных типов](#массивы-примитивных-типов-1)
    - [Двумерные массивы](#двумерные-массивы)
    - [Многомерный массив с базовыми типами](#многомерный-массив-с-базовыми-типами)
    - [Обход (перебор элементов) массивов](#обход-перебор-элементов-массивов)
    - [Итераторы](#итераторы)
      - [Использование итератора (интерфейс)](#использование-итератора-интерфейс)
        - [Functions](#functions)
        - [Extension Functions](#extension-functions)
    - [Операции с массивами](#операции-с-массивами)
      - [Переворачивание массива](#переворачивание-массива)
        - [Перевернуть массив: `reversedArray()`](#перевернуть-массив-reversedarray)
        - [Перевернуть массив: `reverse()`](#перевернуть-массив-reverse)
      - [Сортировка элементов массива](#сортировка-элементов-массива)
      - [Перемешивание элементов массива: `shuffle()` (Kotlin 1.40)](#перемешивание-элементов-массива-shuffle-kotlin-140)
      - [Наличие элемента в массиве: `contains()`](#наличие-элемента-в-массиве-contains)
      - [Найти среднее значение чисел в массиве: `average()`](#найти-среднее-значение-чисел-в-массиве-average)
      - [Подсчитать сумму чисел в массиве: `sum()`](#подсчитать-сумму-чисел-в-массиве-sum)
      - [Найти наибольшее и наименьшее число в массиве](#найти-наибольшее-и-наименьшее-число-в-массиве)
      - [Функция `intersect()`: найти общие элементы двух массивов](#функция-intersect-найти-общие-элементы-двух-массивов)
      - [Выбрать случайную строку из массива](#выбрать-случайную-строку-из-массива)
      - [`onEach()`: Операция с каждым элементом массива по очереди (Kotlin 1.40)](#oneach-операция-с-каждым-элементом-массива-по-очереди-kotlin-140)
      - [Удалить дубликаты](#удалить-дубликаты)
  - [Коллекции](#коллекции)
    - [Виды коллекций в Kotlin](#виды-коллекций-в-kotlin)
    - [Использование коллекций](#использование-коллекций)
    - [Типы коллекций](#типы-коллекций)
    - [`Collection`](#collection)
    - [`List`](#list)
    - [`Set`](#set)
    - [`Map`](#map)
  - [Массивы, коллекции — задачи](#массивы-коллекции--задачи)
    - [Задача 1.](#задача-1)
    - [Задача 2.](#задача-2)
    - [Задача 3.](#задача-3)
    - [Задача 4.](#задача-4)
    - [Задача 5.](#задача-5)
- [04 Функции](#04-функции)
  - [Функции](#функции)
    - [Функции – обязательные и необязательные параметры (значения по умолчанию)](#функции--обязательные-и-необязательные-параметры-значения-по-умолчанию)
    - [Функции – именованные параметры](#функции--именованные-параметры)
    - [Функции – изменение параметров](#функции--изменение-параметров)
    - [Функции – переменное число параметров](#функции--переменное-число-параметров)
    - [Оператор `*` — spread operator](#оператор---spread-operator)
    - [Функции – оператор `return`](#функции--оператор-return)
  - [Функции – вернули `Unit`](#функции--вернули-unit)
  - [Функции – однострочные функции](#функции--однострочные-функции)
    - [Функции – локальная функция](#функции--локальная-функция)
    - [Функции – рефакторинг кода](#функции--рефакторинг-кода)
    - [Функции – перегрузка](#функции--перегрузка)
    - [Функции – присвоение переменной](#функции--присвоение-переменной)
    - [Функции – примеры использования](#функции--примеры-использования)
    - [Функции высокого порядка](#функции-высокого-порядка)
    - [Возвращение функции из функции](#возвращение-функции-из-функции)
    - [Анонимные функции](#анонимные-функции)
    - [Анонимные функции как аргумент](#анонимные-функции-как-аргумент)
    - [Возвращение анонимной функции из функции](#возвращение-анонимной-функции-из-функции)
    - [Функции – лямбда-выражения](#функции--лямбда-выражения)
    - [Лямбда-выражения. Передача параметров](#лямбда-выражения-передача-параметров)
    - [Лямбда-выражения как аргументы функций](#лямбда-выражения-как-аргументы-функций)
    - [Ключевые особенности функций в Kotlin](#ключевые-особенности-функций-в-kotlin)
  - [Функции — задачи](#функции--задачи)
    - [1. Камень-Ножницы-Бумага (три события)](#1-камень-ножницы-бумага-три-события)
    - [2. Биграммный шифр Порты](#2-биграммный-шифр-порты)
    - [3. Программа шифрования методом Вижинера](#3-программа-шифрования-методом-вижинера)
    - [4. Программа шифрования методом омофонической замены](#4-программа-шифрования-методом-омофонической-замены)
- [05 Введение в классы](#05-введение-в-классы)
  - [Введение в классы](#введение-в-классы)
    - [ООП (объектно-ориентированное программирование)](#ооп-объектно-ориентированное-программирование)
    - [Принципы ООП — инкапсуляция](#принципы-ооп--инкапсуляция)
      - [Модификаторы видимости](#модификаторы-видимости)
    - [Принципы ООП — наследование](#принципы-ооп--наследование)
    - [Принципы ООП — полиморфизм](#принципы-ооп--полиморфизм)
    - [Выводы](#выводы)
  - [Классы — основы](#классы--основы)
    - [1. Точка и треугольник (создать класс Точка и класс Треугольник)](#1-точка-и-треугольник-создать-класс-точка-и-класс-треугольник)
    - [2. Расстояние между точками (с использованием класса Точка)](#2-расстояние-между-точками-с-использованием-класса-точка)
    - [3. Выбор наибольшего и наименьшего расстояний (обязательно использовать класс Точка)](#3-выбор-наибольшего-и-наименьшего-расстояний-обязательно-использовать-класс-точка)
    - [4. Треугольник в окружности (обязательно использование класса Точка и класса Треугольник. Класс Окружность и другие классы — по желанию)](#4-треугольник-в-окружности-обязательно-использование-класса-точка-и-класса-треугольник-класс-окружность-и-другие-классы--по-желанию)
    - [5. Окружность в треугольнике (обязательно использование класса Точка и класса Треугольник. Класс Окружность и другие классы — по желанию)](#5-окружность-в-треугольнике-обязательно-использование-класса-точка-и-класса-треугольник-класс-окружность-и-другие-классы--по-желанию)
- [06 Классы. Конструкторы. Get-еры. Set-еры](#06-классы-конструкторы-get-еры-set-еры)
  - [Классы. Конструкторы. Get-еры. Set-еры](#классы-конструкторы-get-еры-set-еры)
    - [Kotlin. Классы](#kotlin-классы)
    - [Kotlin. Классы. Конструкторы](#kotlin-классы-конструкторы)
    - [Kotlin. Классы. Вторичные конструкторы](#kotlin-классы-вторичные-конструкторы)
    - [Kotlin. Классы. Get-еры и Set-еры](#kotlin-классы-get-еры-и-set-еры)
  - [Поезд](#поезд)
- [07 Абстрактные классы. Интерфейсы](#07-абстрактные-классы-интерфейсы)
  - [Абстрактные классы. Интерфейсы](#абстрактные-классы-интерфейсы)
    - [Абстрактные классы](#абстрактные-классы)
    - [Интерфейсы](#интерфейсы)
    - [Различия между абстрактными классами и интерфейсами в Котлине](#различия-между-абстрактными-классами-и-интерфейсами-в-котлине)
    - [Выбор между абстрактными классами и интерфейсами в Котлине](#выбор-между-абстрактными-классами-и-интерфейсами-в-котлине)
    - [Ключевые моменты](#ключевые-моменты)
  - [PizzaCity — сеть пиццерий](#pizzacity--сеть-пиццерий)
  - [Сеть пиццерий](#сеть-пиццерий)
- [Data class. Enum class](#data-class-enum-class)
  - [Data классы](#data-классы)
    - [`toString()`](#tostring)
    - [`equals()`](#equals)
    - [`hashCode()`](#hashcode)
    - [`copy()`](#copy)
    - [Мультидекларации](#мультидекларации)
    - [Стандартные классы данных](#стандартные-классы-данных)
    - [Итоги](#итоги)
  - [Enum классы](#enum-классы)
    - [Свойства и методы Enum классов](#свойства-и-методы-enum-классов)
    - [Enum классы](#enum-классы-1)
    - [Перечисления как анонимные классы](#перечисления-как-анонимные-классы)
    - [Использование выражения When с классом перечисления](#использование-выражения-when-с-классом-перечисления)
  - [Философы](#философы)
    - [Задание 1](#задание-1)
    - [Задание 2](#задание-2)
  - [Мой банк](#мой-банк)
  - [Пример распределения при использовании одной вилки](#пример-распределения-при-использовании-одной-вилки)
  - [Пример распределения при использовании двух палочек](#пример-распределения-при-использовании-двух-палочек)
- [09 Coroutines](#09-coroutines)
  - [Корутины](#корутины)
    - [Зачем нужны асинхронность и параллельные вычисления?](#зачем-нужны-асинхронность-и-параллельные-вычисления)
    - [Вынесение кода корутин в отдельную функцию](#вынесение-кода-корутин-в-отдельную-функцию)
    - [Корутины и потоки](#корутины-и-потоки)
    - [Различия между корутинами и потоками](#различия-между-корутинами-и-потоками)
    - [Преимущества использования корутин](#преимущества-использования-корутин)
    - [Недостатки сопрограмм](#недостатки-сопрограмм)
    - [Несколько случаев, когда применение корутин может быть особенно полезным](#несколько-случаев-когда-применение-корутин-может-быть-особенно-полезным)
    - [Ситуации, когда использование корутин может быть нежелательным или нецелесообразным](#ситуации-когда-использование-корутин-может-быть-нежелательным-или-нецелесообразным)
    - [Область корутины](#область-корутины)
    - [Запуск нескольких корутин](#запуск-нескольких-корутин)
    - [Вложенные корутины](#вложенные-корутины)
    - [launch и job](#launch-и-job)
    - [Отложенное выполнение](#отложенное-выполнение)
  - [Звонок](#звонок)
    - [Задание 1](#задание-1-1)
    - [Задание 2](#задание-2-1)
  - [Пример вывода на консоль](#пример-вывода-на-консоль)
- [10 Установка, настройка и интерфейс Android Studio](#10-установка-настройка-и-интерфейс-android-studio)
  - [Файловая структура Android Studio](#файловая-структура-android-studio)
    - [Структура папок проекта Android](#структура-папок-проекта-android)
    - [Папка Java](#папка-java)
    - [Папка ресурсов (*res*)](#папка-ресурсов-res)
      - [папка *res* / *drawable*](#папка-res--drawable)
      - [папка *res* / *layout*](#папка-res--layout)
      - [папка *res* / *mipmap*](#папка-res--mipmap)
      - [папка *res* / *values*](#папка-res--values)
      - [Папка скриптов Gradle](#папка-скриптов-gradle)
      - [файл *build.gradle*:](#файл-buildgradle)
      - [Папка *Assets*:](#папка-assets)
      - [Папка ресурсов *Raw*:](#папка-ресурсов-raw)
      - [Окно Logcat:](#окно-logcat)
      - [*debug.keystore* file:](#debugkeystore-file)
- [19 01 Основы XML-разметки пользовательского интерфейса. FrameLayout, LinerLayout, GridLayout](#19-01-основы-xml-разметки-пользовательского-интерфейса-framelayout-linerlayout-gridlayout)
  - [ЛЕКЦИЯ - 01](#лекция---01)
    - [FrameLayout](#framelayout)
    - [LinearLayout](#linearlayout)
    - [GridLayout](#gridlayout)
- [20 ПРАКТИКА по теме "Основы XML-разметки пользовательского интерфейса. FrameLayout, LinerLayout, GridLayout"](#20-практика-по-теме-основы-xml-разметки-пользовательского-интерфейса-framelayout-linerlayout-gridlayout)
  - [Разметка клавиатуры](#разметка-клавиатуры)
- [21 02 Компоновщики RelativeLayout и ConstraintLayout](#21-02-компоновщики-relativelayout-и-constraintlayout)
  - [ЛЕКЦИЯ - 02](#лекция---02)
    - [RelativeLayout](#relativelayout)
    - [ConstraintLayout](#constraintlayout)
      - [Преимущества ConstraintLayout](#преимущества-constraintlayout)
      - [Создание ConstraintLayout](#создание-constraintlayout)
    - [Задания](#задания)

## Общее
[66df5d7ed048d373527220f7](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-0)

### Дополнительные материалы по курсу

- [Документация по Kotlin](https://kotlinlang.org/docs/home.html)
- [Документация по Kotlin (ru)](https://kotlinlang.ru/)
- [Материал по коллекциям](https://trello.com/b/7eWLU7kG/kotlin-collections)
- [Android for Developers](https://developer.android.com/)
- [Документация по GitHub](https://docs.github.com/en)
- [Книга Pro Git (на русском)](https://git-scm.com/book/ru/v2)
- [Различные иконки](https://www.flaticon.com/)
- [Шрифты от Google](https://fonts.google.com/)
- [Material Design](https://m3.material.io/)
- [Android разработчик](https://developer.android.com/guide/index.html)
- [Android Developer Fundamentals (Version 2)](https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/index.html)
- [On-line редактор для работы с Kotlin - официальный](https://play.kotlinlang.org/)
- [On-line редактор для работы с Kotlin - работает с интерактивом](https://www.jdoodle.com/compile-kotlin-online/)

### Официальные бесплатные курсы от Google

- [Android Basics (RUS)](https://javarush.ru/quests/QUEST_GOOGLE_ANDROID)
- [Developing Android Apps - Intermediate level (ENG)](https://www.udacity.com/course/new-android-fundamentals--ud851)
- [Android app development - Advanced level (ENG)](https://www.udacity.com/course/-advanced-android-app-development--ud855)
- [Kotlin Bootcamp for Programmers (ENG)](https://www.udacity.com/course/kotlin-bootcamp-for-programmers--ud9011)
- [Developing Android Apps with Kotlin (ENG)](https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012)
- [Kotlin for Android Developers (ENG)](https://www.udacity.com/course/kotlin-for-android-developers--ud888)
- [Advanced Android with Kotlin (ENG)](https://www.udacity.com/course/advanced-android-with-kotlin--ud940)
- [Android Performance (ENG)](https://www.udacity.com/course/android-performance--ud825)
- [Material Design for Android Developers (ENG)](https://www.udacity.com/course/material-design-for-android-developers--ud862)
- [Firebase in a Weekend: Android (ENG)](https://www.udacity.com/course/firebase-in-a-weekend-by-google-android--ud0352)
- [Build Native Mobile Apps with Flutter (ENG)](https://www.udacity.com/course/build-native-mobile-apps-with-flutter--ud905)

### Примерные теоретические вопросы к экзамену
[66e01520d048d3735272210c](https://e-learn.petrocollege.ru/mod/page/view.php?id=345133)

1. Понятие мобильной разработки. История развития.

2. Инструментарий разработчика мобильных приложений

3. Использование систем контроля версий при разработке мобильных приложений

4. История языка Kotlin. Преимущества и недостатки Kotlin.

5. Типы данных, используемые в языке Kotlin

6. Структура программы на языке Kotlin. Использование условий и циклов

7. Встроенные и пользовательские функции языка Kotlin. Нефиксированное число аргументов. Перегрузка функций.

8. Массивы и их использование в языке Kotlin.

9. Immutable Collection. Mutable Collection. List и его использование в языке Kotlin.

10. Immutable Collection. Mutable Collection. Set и его использование в языке Kotlin.

11. Immutable Collection. Mutable Collection. Map и его использование в языке Kotlin.

12. ООП в Kotlin. Создание и использование классов. Свойства и методы классов.

13. ООП в Kotlin. Использование конструкторов и интерфейсов.

14. Среда разработки Android Studio. Краткий обзор базовых UI-компонентов.

15. Среда разработки Android Studio. Файловая структура проекта. Режимы Project и Android

16. Создание экрана приложения. Использование компоновщиков.

17. Обработка нажатия кнопки. Использование события onClick и параметра viewBinding

18. ToolBar и создание меню для ToolBar

19. BottomNavigationView и создание меню.

20. Activity и ее жизненный цикл. Способы создания.

21. Переход между Activity и передача данных между Activity

22. Fragment. Создание и использование

23. Передача данных между Fragment и Activity с помощью ViewModal

24. Создание базы данных с использованием Kotlin.

25. Работа с базой данных с использованием Room

26. Списки и их использование. Работа с ListView

27. Списки и их использование. Использование RecyclerView

###  Примерные практические задания на экзамен
[66e015b8d048d3735272210e](https://e-learn.petrocollege.ru/mod/page/view.php?id=345134)

1. Расположить на экране, в центре, квадрат размером 200х200 синего цвета. Внизу экрана расположить кнопку с надписью «СТАРТ». При нажатии на кнопку цвет квадрата меняется циклично в следующем порядке: синий – красный – желтый

2. Создать приложение, состоящее из двух Activity. На каждой Activity расположить по центру соответствующие надписи: «Activity 01» и «Activity 02». Также на каждой Activity расположить ниже надписей (на 100px), кнопки. Нажатием на кнопку пользователь переходит на другую Activity.

3. Создать приложение, состоящее из кнопки и текстового поля. При запуске приложения в текстовом поле стоит число 1.  При нажатии на кнопку значение в текстовом поле меняется от 1 до 10 с шагом 1. После 10-и отсчет опять начинается с 1-ы.

4. Создать приложение, состоящее из кнопки и текстового поля. При запуске приложения в текстовом поле стоит число 0.  При последовательных нажатиях на кнопку в текстовое поле выводятся последовательно нечетные числа в диапазоне [1;10]. После 10-и отсчет опять начинается с наименьшего нечетного числа.

5. Создать приложение, состоящее из кнопки и текстового поля. При запуске приложения в текстовом поле стоит число 0.  При последовательных нажатиях на кнопку в текстовое поле выводятся последовательно четные числа в диапазоне [1;10]. После 10-и отсчет опять начинается с наименьшего четного числа.

6. Создать приложение, состоящее из Activity и двух Fragment. На Fragment расположены соответственно надписи – «Фрагмент01» и «Фрагмент02». На Activity расположить кнопку, нажатие на которую будет показывать циклично Fragment01 и Fragment02.

7. Создать приложение, состоящее из двух Activity. На каждом Activity находится кнопка для перехода на другую Activity, и текстовое поле, в которое можно ввести только цифры. Пользователь вводит в поле какое-то значение и нажимает кнопку. Осуществляется переход на другую Activity при котором в поле для ввода передается введенное значение.

8. Создать простое приложение, демонстрирующее передачу данных от Activity во Fragment.

9. Создать простое приложение, демонстрирующее передачу данных от Fragment в Activity.

10. Создать простое приложение, демонстрирующее передачу данных из одного Fragment в другой Fragment.

11. Создать приложение, в котором имеется меню в ToolBar, состоящее из пунктов – Red, Green и Yellow. В центре экрана имеется квадрат, который при выборе пункта меню меняет свой цвет на соответствующий. При запуске приложения цвет квадрата Black.

12. Создать приложение, в котором имеется меню в BottomNavigationView, состоящее из пунктов – Red, Green и Yellow. В центре экрана имеется квадрат, который при выборе пункта меню меняет свой цвет на соответствующий. При запуске приложения цвет квадрата Black.

13. Вывести на экран приложения элементы массива нечетных чисел (не менее 30-и элементов) с использованием ListView и ArrayAdapter.

14. Имеется два массива – массив четных чисел и массив числительных, соответствующих этим числам. Вывести на экран приложения элементы массива четных чисел (не менее 30-и элементов) с использованием ListView и ArrayAdapter. При нажатии на элемент списка во всплывающем сообщении появляется соответствующее ему числительное.

15. Показать приложение «Рецепты», созданное с использованием ListView, и объяснить его работу (свой Adapter, изменения в Manifest и т.д.). Приложение необходимо сделать заранее по презентации до экзамена.

16. Показать приложение «Пикачу», созданное с использованием RecyclerView, и объяснить его работу (свой Adapter, ресурсы, изменения в Manifest и т.д.). Приложение необходимо сделать заранее по презентации до экзамена.

17. Создать приложение, состоящее из кнопки в центре экрана и четырех пронумерованных квадратов, расположенных по углам Activity. Квадрат с номером 1 расположен в верхнем правом углу. Далее – по часовой стрелке. При нажатии на кнопку у квадратов последовательно меняется цвет на красный. Ранее выделенный красным квадрат меняет свой цвет на цвет по умолчанию (синий).

18. Создать приложение, состоящее из кнопки в центре экрана и четырех пронумерованных квадратов, расположенных по углам Activity. Квадрат с номером 1 расположен в верхнем правом углу. Далее – по часовой стрелке. При нажатии на кнопку случайным образом выбирается квадрат и его цвет меняется на красный. Ранее выделенный красным квадрат меняет свой цвет на цвет по умолчанию (синий).

19. Создать приложение, состоящее из двух полей ввода и текстового поля, а также кнопки «РЕЗУЛЬТАТ». Пользователь вводит целые числа в поля ввода. При нажатии на кнопку в текстовом поле получаем сумму введенных чисел. Сделать так, чтобы в поля ввода можно было вводить только числовые значения.

20. Создать приложение, с помощью которого пользователь вводит в соответствующие поля только числовые значения и при нажатии на кнопку «РЕЗУЛЬТАТ» получает частное и остаток от деления первого числа на второе.

21. Создать приложение, в котором пользователь вводит в соответствующие поля два целых числа и при нажатии на кнопку «РЕЗУЛЬТАТ» между введенными числами ставится знак «<» или «>», в зависимости от введенных значений.

22. Создать приложение, в котором пользователь вводит в соответствующее поле любое число (целое или дробное). При нажатии на кнопку «РЕЗУЛЬТАТ» в другом текстовом поле отображается округленное до ближайшего большего целое число.

23. Создать приложение, которое подсчитывает в веденном слове количество гласных букв.

24. Создать приложение, которое подсчитывает в веденном слове количество согласных букв.

25. Создать приложение, в котором пользователь вводит в соответствующее поле любое число (целое или дробное). При нажатии на кнопку «РЕЗУЛЬТАТ» в другом текстовом поле отображается округленное до ближайшего нечетного большего целое число.

26. Создать приложение, в котором пользователь вводит в соответствующее поле любое число (целое или дробное). При нажатии на кнопку «РЕЗУЛЬТАТ» в другом текстовом поле отображается округленное до ближайшего большего четного целое число.

27. Создать приложение, с помощью которого пользователь вводит в соответствующее поле числовое значение и при нажатии на кнопку «РЕЗУЛЬТАТ» получает сообщение о четности или нечетности числа.

### Критерии оценки

#### Группы 52-03в и 52-02в.

Для получения положительной оценки необходимо создать ОДНО приложение. Ссылку на репозиторий прикрепить в задании, которое расположено под данным описанием.

На оценку "3" или "4" создается консольное приложение (среда разработки IntelliJ IDEA Community Edition). На оценку "5" создается мобильное приложение (среда разработки Android Studio). Критерии оценивания описаны ниже:

Оценка "3":
1. Создание консольной программы по презентации [PizzaCity - сеть пиццерий](https://wywiwyg.ru/learn_kotlin/Task-PizzaCity.html) 

2. Создать игру согласно описания ["Быки и коровы"](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345165)

Оценка "4":
1. Реализация заданий из последнего слайда презентации [PizzaCity - сеть пиццерий](https://wywiwyg.ru/learn_kotlin/Task-PizzaCity.html) (консольное приложение)

2. Создать консольное приложение ["Мой банк"](https://e-learn.petrocollege.ru/mod/assign/view.php?id=352490) согласно описания   

Оценка "5":
1. Создать одно из мобильных приложений: ["Реши пример"](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345173) или ["Проверь решение"](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345174)

2. Создать свое мобильное приложение. Можно взять идеи с данного ресурса https://kids-smart.ru/exercises/groups

#### Группа 51-02

Для получения положительной оценки на экзамене необходимо создать ОДНО консольное приложение и ДВА мобильных приложения. Кроме этого необходимо выполнять задания на занятиях

Если вы собираетесь писать для дипломного проекта мобильное приложение, то вместо двух приложений вы можете написать мобильное приложение, которое собираетесь показывать на защите диплома

1. Консольное приложение ["Мой банк"](https://e-learn.petrocollege.ru/mod/assign/view.php?id=352490) согласно описания

2. Идеи мобильного приложения можно взять с сайта https://kids-smart.ru/exercises/groups

Ссылку на репозиторий прикрепить в задании, которое расположено под данным описанием.

#### Группы 53-02в, 53-03в, 53-09в, 52-00в, 52-04в, 52-08в

Для получения положительной оценки за семестр необходимо ОБЯЗАТЕЛЬНО выполнить следующие задания:

1. Консольное приложение ["Поезд"](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345151) согласно описания

2. Консольное приложение ["PizzaCity - сеть пиццерий"](https://wywiwyg.ru/learn_kotlin/Task-PizzaCity.html) согласно описания. Необходимо также выполнить задания, расположенные на последнем слайде

3. Консольное приложение ["Быки и коровы"](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345165) согласно описания. Или любую задачу из раздела "Функции" или "Коллекции"

Ссылку на репозиторий прикрепить в соответствующих заданиях.

## 01 Введение
[66e0171ad048d37352722110](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-1)

### Коротко о GitHub
66e1bf5ad048d37352722148

Сервис для совместной разработки и хостинга ИТ-проектов Github был основан в апреле 2008 года программистами Крисом Ванстрасом (Chris Wanstrath), Томом Престон-Вернером (Thomas Preston-Werner) и Пи Джей Хайеттом (PJ Hyett).

![](./img/github-1.webp)

Первоначально проект предполагался как сообщество по разработке с помощью открытого исходного кода, использующего систему управления версиями Git.

В 2005 году программист Линус Торвальдс создал Git в ходе работы над ядром Linux. Разработчики начали применять эту систему в своей работе. Создание Git считалось выходом «на следующий уровень» по сравнению с другим программным обеспечением для управления версиями.

![](./img/github-2.webp)

При этом, по мнению Престон-Вернера, проблема совместной работы не исчезла — Git делала её возможной, но сложной. GitHub был призван стать решением проблемы. В дальнейшем первым слоганом платформы станет «Гит-хостинг: больше не боль в заднице» (Git hosting: No longer a pain in the ass).

Идея пришла Ванстрасу и Престону-Вернеру во время митапа Ruby-разработчиков в октябре 2007 года в Сан-Франциско. Они планировали, что будущий проект должен стать местом, где разработчики могли бы легко делиться кодом и изучать программы друг друга.

В то время Ванстрас зарабатывал консалтингом, а до этого занимался техническим развитием сайта о технологиях Cnet. В свою очередь Престон-Вернер был разработчиком в компании Powerset.

В конце 2007 года они приступили к созданию собственного проекта — по субботам разработчики устраивали мозговой штурм, а в свободное время писали код будущей платформы. Престон-Вернер взял на себя разработку пользовательского интерфейса GitHub, а Ванстрас занялся разработкой самого приложения на Ruby on Rails.

«GitHub не должен был стать стартапом или компанией. GitHub был всего лишь инструментом, который был нужен нам самим», — рассказывал в интервью Wired Ванстрас.

Престон-Вернеру в работе над GitHub также пригодился опыт создания сервиса Gravatar в 2007 году, который позволял сохранять изображения для профилей в соцсетях на отдельном сервере. В том же году разработчик продал сайт компании Automattic (владеет блог-платформой WordPress).

Молодые люди потратили «несколько сотен долларов» на покупку домена у VPS-провайдера Slicehost, регистрацию компании Logical Awesome и графику для будущего сайта.

Кроме того, разработчики приобрели в фотостоке iStockphoto права на рисунок «осьмикота» (смесь кота и осьминога) художника Саймона Оуксли, создавшего первый логотип Twitter. Выдуманное животное стало маскотом GitHub.

![](./img/github-3.webp)

Должность генерального директора компании занял Ванстрас. Первое время команда GitHub работала удаленно в кофейнях и из дома, общаясь через сервис Campfire. Собственный офис в Сан-Франциско у компании появился только в 2010 году.

В начале 2008 года разработчики запустили бета-версию платформы и разослали приглашения друзьям и знакомым. Первые участники начали пользоваться GitHub, размещая на площадке свои рабочие коды. Одним из первых проектов, который присоединился к новой платформе, стал фреймворк Ruby on Rails.

В феврале 2008 к команде основателей проекта присоединился Пи Джей Хайетт. С ним в 2007 году Ванстрас познакомился в Cnet, а затем молодые люди пытались запустить аналог Google+ под названием Famspam. Однако их стартап не стал успешным.

Публичный запуск GitHub состоялся 10 апреля 2008 года. К этому моменту проект содержал 20 тысяч репозиториев, а количество пользователей составило более двух тысяч.

«Мы действительно гордимся этим сайтом, и у нас есть так много идей на будущее. Это только начало», — написал в блоге проекта Ванстрас.

Разработчики заложили в GitHub такие возможности, как дублирование или форкинг (Forking), запросы на включение в проект изменений (Pull Requests) и слияние (Merging).

В GitHub можно скопировать любой опубликованный репозиторий в свой профиль, чтобы модифицировать его. Затем разработчик может поделиться изменениями с владельцем репозитория посредством запроса на включение. Если владельцу нравятся изменения, то он может слить их с первоначальным репозиторием.

Таким образом подход GitHub позволил любому зарегистрированному пользователю делиться, улучшать или развивать открытые проекты.

Также GitHub предоставил такие функции совместной работы, как отслеживание ошибок, запрос функций, управление задачами и вики-страницами для каждого проекта.

3 июня 2018 года Bloomberg сообщило, что Microsoft заключила соглашение о покупке GitHub. По словам одного из источников агентства, владельцы GitHub решили не выводить компанию на биржу, а продать её, так как их впечатлил глава корпорации Сатья Наделла.

На следующий день Microsoft и GitHub подтвердили сделку. Её стоимость составила $7,5 млрд.

### Подключение VCS к IntelliJ IDEA
[66e1c090d048d3735272214a](https://rutube.ru/video/private/b9a41fbd9e87579966bb398b1c1e3baf/?p=hQYXvP2kkS5ONZM9CaDxHQ)

1. Go *GitHub.com* and generate a new classical token with the following settings:

   - [x] repo
     - [x] repo:status
     - [x] repo_deployment
     - [x] public_repo
     - [x] repo:invite
     - [x] security_events
   - [ ] admin:org
     - [ ] write:org
     - [x] read:org
     - [ ] manage_runners:org
   - [x] gist

2. Copy and saved a newly generated token.
2. IntelliJ IDEA: *File* > *Settings* > *Version Control* > *GitHub*. Press "+" and choose to "Log in with Token...".
3. Add GitHub Account with the following settings:
   - Server: *github.com*
   - Token: *your generated GitHub token*
4. Replace .gitignore contents with the [following](https://github.com/JetBrains/kotlin/blob/master/.gitignore):

    <details>
    <summary><b><i>.gitignore</i></b></summary>

    ```
    .DS_Store
    .idea/shelf
    /confluence/target
    /dependencies/repo
    /android.tests.dependencies
    /dependencies/android.tests.dependencies
    /dist
    /local
    /gh-pages
    /ideaSDK
    /clionSDK
    /android-studio/sdk
    out/
    /tmp
    /intellij
    workspace.xml
    *.versionsBackup
    /idea/testData/debugger/tinyApp/classes*
    /jps-plugin/testData/kannotator
    /js/js.translator/testData/out/
    /js/js.translator/testData/out-min/
    /js/js.translator/testData/out-pir/
    .gradle/
    build/
    !**/src/**/build
    !**/test/**/build
    *.iml
    !**/testData/**/*.iml
    .idea/artifacts
    .idea/remote-targets.xml
    .idea/libraries/Gradle*.xml
    .idea/libraries/Maven*.xml
    .idea/modules
    .idea/runConfigurations/JPS_*.xml
    .idea/runConfigurations/_JPS_*.xml
    .idea/runConfigurations/PILL_*.xml
    .idea/runConfigurations/_FP_*.xml
    .idea/runConfigurations/_MT_*.xml
    .idea/libraries
    .idea/modules.xml
    .idea/gradle.xml
    .idea/compiler.xml
    .idea/inspectionProfiles/profiles_settings.xml
    .idea/.name
    .idea/jarRepositories.xml
    .idea/csv-plugin.xml
    .idea/libraries-with-intellij-classes.xml
    .idea/misc.xml
    .idea/protoeditor.xml
    .idea/uiDesigner.xml
    node_modules/
    .rpt2_cache/
    local.properties
    buildSrcTmp/
    distTmp/
    outTmp/
    /test.output
    /kotlin-native/dist
    kotlin-ide/
    .kotlin/
    .teamcity/
    ```

    </details>

5. Create new repository and branch from main.
6. Do your work, commit and push to GitHub.
7. Create pull request at GitHub.
8. Attach GitHub pull request url at the colledge system.
9. Merge branch to main after approval.

### Хекслет
[66ec3c46d048d37352722213](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345139)

Зарегистрироваться при необходимости на сайте Хекслет

Пройти курс [Введение в Git](https://ru.hexlet.io/courses/intro_to_git)

В качестве отчета приложить архив скриншота экрана главной страницы курса с открытым меню для профиля (см. пример). Преподаватель может попросить войти на указанный ресурс с компьютера колледжа для проверки достоверности указанных сведений.

## 02 Синтаксис языка. Управляющие конструкции — решение задач
[66ec3cb8d048d37352722215](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-2)

### Основной синтаксис
[66ed9ed65040133e8429e165](https://e-learn.petrocollege.ru/mod/url/view.php?id=345141)

https://kotlinlang.ru/docs/basic-syntax.html

#### Определение имени пакета и импорт
Имя пакета указывается в начале исходного файла, так же как и в Java.
```kotlin
package my.demo

import java.util.*

// ...
```

Но в отличие от Java, нет необходимости, чтобы структура пакетов совпадала со структурой папок: исходные файлы могут располагаться в произвольном месте на диске.

См. [Пакеты](https://kotlinlang.ru/docs/packages.html).

#### Точка входа в программу
В Kotlin точкой входа в программу является функция `main`.
```kotlin
fun main() {
    println("Hello world!")
}
```

Другая форма `main` может принимать массив строк `String`.
```kotlin
fun main(args: Array<String>) {
    println(args.contentToString())
}
```

#### Вывод в стандартный поток (с помощью `print()` и `println()`)
`print` выводит свой аргумент в стандартный поток вывода.
```kotlin
print("Hello ")
print("world!")
```

`println` выводит свой аргумент и добавляет перевод строки, так что следующее, что вы выведите, появится на следующей строке.
```kotlin
println("Hello world!")
println(42)
```

!!! example [Example](samples/02_Syntax/02_Output/src/Main.kt)
```kotlin
fun main() {
    val testF = "1234567"
    for (i in 0..testF.length - 1) {
        println(testF[i])
    }
    println("====================")
    for (i in 0..testF.length - 1) {
        print(testF[i])
    }
}

```

<details>
<summary>Output</summary>

```
1
2
3
4
5
6
7
====================
1234567

Process finished with exit code 0
```

</details>


!!! example [Example](samples/02_Syntax/03_Output/src/Main.kt)
```kotlin
fun main() {
    print("Введите трехзначное число: ")
    val testF = readln()
    println("==============")
    println("Простой вывод значения переменной")
    println(testF)
    println("Вывод переменной как части строки")
    println("Мы ввели число - $testF")
    println("Некорректное обращение к части строки")
    println("Первый символ введенного числа - $testF[0]")
    println("Обратите внимание на фигурные скобки")
    println("Первый символ введенного числа - ${testF[0]}")
}

```

<details>
<summary>Output</summary>

```
Введите трехзначное число: 987
==============
Простой вывод значения переменной
987
Вывод переменной как части строки
Мы ввели число - 987
Некорректное обращение к части строки
Первый символ введенного числа - 987[0]
Обратите внимание на фигурные скобки
Первый символ введенного числа - 9

Process finished with exit code 0
```

</details>

#### Чтение данных с консоли

!!! example [Example](samples/02_Syntax/04_ConsoleInput/src/Main.kt)
```kotlin
fun main() {
    print("Введите строку символов: ")
    val testF = readln()
    println()

    for (i in 0..testF.length - 1) {
        print(testF[i])
    }
}
```

<details>
<summary>Output</summary>

```
Введите строку символов: Это строка символов

Это строка символов
Process finished with exit code 0

```

</details>

!!! example [Example](samples/02_Syntax/05_ConsoleIO/src/Main.kt)
```kotlin
fun main() {
    print("Введите строку символов: ")
    val testF = readln()
    println()

    for (i in testF) {
        print(i)
    }
}

```

<details>
<summary>Output</summary>

```
Введите строку символов: Чтение символов из строки

Чтение символов из строки
Process finished with exit code 0

```

</details>

#### Переменные. Объявление переменных
Неизменяемые (только для чтения) локальные переменные определяются с помощью ключевого слова `val`. Присвоить им значение можно только один раз.
```kotlin
val a: Int = 1   // Инициализация при объявлении
val b = 1        // Тип `Int` определен автоматически
val c: Int       // Указывать тип обязательно, если переменная не инициализирована сразу
c = 1            // Последующее присвоение
```

Изменяемые переменные объявляются с помощью ключевого слова `var`.
```kotlin
var x = 5 // Тип `Int` определен автоматически
x += 1
```

Вы можете объявлять глобальные переменные.
```kotlin
val PI = 3.14
var x = 0

fun incrementX() { 
    x += 1 
}
```

!!! example [Example](samples/02_Syntax/01_VariableDeclaration/src/Main.kt)
```kotlin
fun main() {
    // Неизменяемые (только для чтения)
    // локальные переменные определяются
    // с помощью ключевого слова val.
    // Присвоить им значение можно только один раз.
    val testC = 7
    println(testC) // => 7

    // testC = 9 // => Kotlin: Val cannot be reassigned

    // Изменяемые переменные объявляются
    // с помощью ключевого слова var.
    var testD = "строка символов"
    println(testD) // => строка символов

    testD = "новая строка символов"
    println(testD) // => новая строка символов
}
```

<details>
<summary>Output</summary>

```
7
строка символов
новая строка символов

Process finished with exit code 0
```

</details>

!!! error Error
```kotlin
testC = 9 // => Kotlin: Val cannot be reassigned
```

<details>
<summary>Output</summary>

```
Kotlin: Val cannot be reassigned

Process finished with exit code 0
```

</details>

### Основные типы
https://kotlinlang.ru/docs/basic-types.html

В Kotlin всё является объектом, в том смысле, что пользователь может вызвать функцию или получить доступ к свойству любой переменной. Некоторые типы являются встроенными, т.к. их реализация оптимизирована, хотя для пользователя они выглядят как обычные классы. В данном разделе описываются основные типы: числа, логические переменные, символы, строки и массивы.

#### Числа

##### Целочисленные типы
В Kotlin есть набор встроенных типов, которые представляют числа. Для целых чисел существует четыре типа с разными размерами и, следовательно, разными диапазонами значений.

| Тип |	Размер (биты) |	Минимальное значение |	Максимальное значение |
| --- | :--: | --: | -----------: |
| `Byte` |	8 |	-128 |	127 |
| `Short` |	16 |	-32768 |	32767 |
| `Int` |	32 |	-2,147,483,648 (-2^31^) |	2,147,483,647 (2^31^ - 1) |
| `Long` |	64 |	-9,223,372,036,854,775,808 (-2^63^) |	9,223,372,036,854,775,807 (2^63^ - 1) |

Все переменные, инициализированные целыми значениями, не превышающими максимальное значение `Int`, имеют предполагаемый тип `Int`. Если начальное значение превышает это значение, то тип `Long`. Чтобы явно указать тип `Long`, добавьте после значения `L`.
```kotlin
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1
```

!!! example [Example](samples/02_Syntax/06_IntegerTypes/src/Main.kt)
```kotlin
fun main() {
    var testByte: Byte = 120
    var testShort: Short = 32000
    var testInt: Int = 957_235_455
    var testLong: Long = 873_554_554_545_525
    var testLongTwo: Long = 934_347_523_555L
}

```

##### Типы с плавающей точкой
Для действительных чисел в Kotlin есть типы с плавающей точкой `Float` и `Double`. Согласно стандарту IEEE 754, типы с плавающей точкой различаются своим десятичным разрядом, то есть количеством десятичных цифр, которые они могут хранить. С точки зрения IEEE 754 `Float` является одинарно точным, а `Double` обеспечивает двойную точность.

| Тип    | Размер (биты) | Значимые биты | Биты экспоненты | Разряды |
| ------ | :-----------: | :-----------: | :-------------: | :-----: |
| `Float`  | 32            | 24            | 8               | 6-7     |
| `Double` | 64            | 53            | 11              | 15-16   |

Вы можете инициализировать переменные `Double` и `Float` числами, имеющими дробную часть. Она должна быть отделена от целой части точкой (`.`). Для переменных, инициализированных дробными числами, компилятор автоматически определяет тип `Double`.
```kotlin
val pi = 3.14 // Double
// val one: Double = 1 // Ошибка: несоответствие типов
val oneDouble = 1.0 // Double
```

Чтобы явно указать тип `Float`, добавьте после значения `f` или `F`. Если такое значение содержит более 6-7 разрядов, оно будет округлено.
```kotlin
val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float, фактическое значение 2.7182817
```

Обратите внимание, что в отличие от некоторых других языков, в Kotlin нет неявных преобразований для чисел. Например, функция с `Double` параметром может вызываться только для `Double`, но не для `Float`, `Int` или других числовых значений.
```kotlin
fun main() {
    fun printDouble(d: Double) { print(d) }

    val i = 1    
    val d = 1.0
    val f = 1.0f 

    printDouble(d)
//  printDouble(i) // Ошибка: несоответствие типов
//  printDouble(f) // Ошибка: несоответствие типов
}
```

Чтобы преобразовать числовые значения в различные типы, используйте [Явные преобразования](#явные-преобразования).


!!! example [Example](samples/02_Syntax/07_Floats/src/Main.kt)
```kotlin
fun main() {
    var testDouble: Double = 120.0
    // val one: Double = 1 // Ошибка: несоответствие типов
    // var testDoubleTwo: Double = 120 // => Kotlin: Initializer type mismatch: expected 'kotlin/Double', actual 'kotlin/Int'
    printDouble(testDouble) // => 120.0

    var testFloat: Float = 32000F
    // var testFloatTwo: Float = 32000.7 // => Kotlin: Initializer type mismatch: expected 'kotlin/Float', actual 'kotlin/Double'
    printDouble(testFloat) // => 32000.0

    val i = 1
    // printDouble(i) // Ошибка: несоответствие типов
}

fun printDouble(testPar: Float) {
    println(testPar)
}

fun printDouble(testPar: Double) {
    println(testPar)
}
```

<details>
<summary>Output</summary>

```
120.0
32000.0

Process finished with exit code 0

```

</details>

##### Представление чисел в JVM
Обычно платформа JVM хранит числа в виде примитивных типов: `int`, `double` и так далее. Если же вам необходима ссылка, которая может принимать значение `null` (например, `Int?`), то используйте обёртки. В этих случаях числа помещаются в Java классы как `Integer`, `Double` и так далее.

Обратите внимание, что использование обёрток для одного и того же числа не гарантирует равенства ссылок на них.
```kotlin
val a: Int = 100
val boxedA: Int? = a
val anotherBoxedA: Int? = a

val b: Int = 10000
val boxedB: Int? = b
val anotherBoxedB: Int? = b

println(boxedA === anotherBoxedA) // true
println(boxedB === anotherBoxedB) // false
```

Все nullable-ссылки на `a` на самом деле являются одним и тем же объектом из-за оптимизации памяти, которую JVM применяет к `Integer` между “-128” и “127”. Но `b` больше этих значений, поэтому ссылки на `b` являются разными объектами.

Однако, равенство по значению сохраняется.
```kotlin
val b: Int = 10000
println(b == b) // Prints 'true'
val boxedB: Int? = b
val anotherBoxedB: Int? = b
println(boxedB == anotherBoxedB) // Prints 'true'
```

##### Символьные постоянные
В языке Kotlin присутствуют следующие виды символьных постоянных (констант) для целых значений:

- Десятичные числа: `123`
  - Тип `Long` обозначается заглавной `L`: `123L`
- Шестнадцатеричные числа: `0x0F`
- Двоичные числа: `0b00001011`

> ВНИМАНИЕ: Восьмеричные литералы не поддерживаются.

Также Kotlin поддерживает числа с плавающей запятой:

- Тип `Double` по умолчанию: `123.5`, `123.5e10`
- Тип `Float` обозначается с помощью `f` или `F`: `123.5f`

Вы можете использовать нижние подчеркивания, чтобы сделать числовые константы более читаемыми:
```kotlin
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

!!! error [Error](samples/02_Syntax/08_NumericLiterals/src/Main.kt)
```kotlin
fun main() {
    var testInt = 123
    var testLong = 120L

    var testHex = 0x0F
    var testBinary = 0b00001011
    printDouble(testBinary) // => // Ошибка: несоответствие типов

    var testDoublePoint = 123.5
    var testDoubleE = 123.5e12

    var testFloat_f = 481.78f
    var testFloat_F = 346.49F

    val oneMillion = 1_000_000
    val creditCardNumber = 1234_5678_9012_3456L
    val socialSecurityNumber = 999_99_9999L
    val hexBytes = 0xFF_EC_DE_5E
    val bytes = 0b11010010_01101001_10010100_10010010
}

fun printDouble(testPar: Double) {
    println(testPar)
}
```

<details>
<summary>Output</summary>

```
Kotlin: Argument type mismatch: actual type is 'kotlin/Int' but 'kotlin/Double' was expected

```

</details>

##### Явные преобразования
Из-за разницы в представлениях меньшие типы не являются подтипами бОльших типов. В противном случае возникли бы сложности.
```kotlin
// Возможный код, который на самом деле не скомпилируется:
val a: Int? = 1 // "Обёрнутый" Int (java.lang.Integer)
val b: Long? = a // неявное преобразование возвращает "обёрнутый" Long (java.lang.Long)
print(b == a) // Внимание! Данное выражение выведет "false" т. к. метод equals() типа Long предполагает, что вторая часть выражения также имеет тип Long
```

Таким образом, будет утрачена не только тождественность (равенство по ссылке), но и равенство по значению.

Как следствие, неявное преобразование меньших типов в большие НЕ происходит. Это значит, что мы не можем присвоить значение типа `Byte` переменной типа `Int` без явного преобразования.
```kotlin
val b: Byte = 1 // всё хорошо, литералы проверяются статически
// val i: Int = b // ОШИБКА
val i1: Int = b.toInt()
```

Каждый численный тип поддерживает следующие преобразования:

- `toByte(): Byte`
- `toShort(): Short`
- `toInt(): Int`
- `toLong(): Long`
- `toFloat(): Float`
- `toDouble(): Double`
- `toChar(): Char`

Часто необходимости в явных преобразованиях нет, поскольку тип выводится из контекста, а арифметические действия перегружаются для подходящих преобразований.
```kotlin
val l = 1L + 3 // Long + Int => Long
```

!!! example [Example](samples/02_Syntax/09_ExplicitConversions/src/Main.kt)
```kotlin
fun main() {
    val testA = 1
    val testB: Byte = 1
    // println(testA == testB) // => Kotlin: Operator '==' cannot be applied to 'kotlin/Int' and 'kotlin/Byte'
    // val testD: Int = testB // => Kotlin: Initializer type mismatch: expected 'kotlin/Int', actual 'kotlin/Byte'

    val testH = testB.toInt()

    println(5 / 2)      // => 2
    println(5 / 2.0)    // => 2.5
    println(6.0 / 2.0)  // => 3.0

    val l = 1L + 3      // Long + Int => Long
    println(l)          // => 4
}
```

<details>
<summary>Output</summary>

```
2
2.5
3.0
4

Process finished with exit code 0

```

</details>

!!! error Error
```kotlin
fun main() {
    val testA = 1
    val testB: Byte = 1
    println(testA == testB)
}
```

<details>
<summary>Output</summary>

```
Kotlin: Operator '==' cannot be applied to 'kotlin/Int' and 'kotlin/Byte'

```

</details>

!!! error Error
```kotlin
fun main() {
    val testA = 1
    val testB: Byte = 1
    val testD: Int = testB // => Kotlin: Initializer type mismatch: expected 'kotlin/Int', actual 'kotlin/Byte'
}

```

<details>
<summary>Output</summary>

```
Kotlin: Initializer type mismatch: expected 'kotlin/Int', actual 'kotlin/Byte'

```

</details>

##### Арифметические операции
Котлин поддерживает стандартный набор арифметических операций над числами: `+`, `-`, `*`, `/`, `%`. Они объявляются членами соответствующих классов.
```kotlin
println(1 + 2)
println(2_500_000_000L - 1L)
println(3.14 * 2.71)
println(10.0 / 3)
```

Вы также можете переопределить эти операторы для пользовательских классов. См. [Перегрузка операторов](https://kotlinlang.ru/docs/operator-overloading.html) для деталей.

!!! example [Example](samples/02_Syntax/10_ArithmeticOperations/src/Main.kt)
```kotlin
fun main() {
    println(78 + 96)
    println(158 - 9)
    println(3.14 * 51)
    println(854 / 32)
    println(9 % 4)

    for (i in 2..9) {
        print("$i ")
    }
    println()
    println(2 in -3..9)
    println(-12 !in -3..9)
}
```

<details>
<summary>Output</summary>

```
174
149
160.14000000000001
26
1
2 3 4 5 6 7 8 9 
true
true

Process finished with exit code 0
```

</details>

###### Деление целых чисел
Деление целых чисел всегда возвращает целое число. Любая дробная часть отбрасывается.
```kotlin
val x = 5 / 2
// println(x == 2.5) // ОШИБКА: Оператор '==' не может быть применен к 'Int' и 'Double'
println(x == 2) // true
```

Это справедливо для деления любых двух целочисленных типов.
```kotlin
val x = 5L / 2
println(x == 2L) // true
```

Чтобы вернуть тип с плавающей точкой, явно преобразуйте один из аргументов в тип с плавающей точкой.
```kotlin
val x = 5 / 2.toDouble()
println(x == 2.5) // true
```

###### Побитовые операции
Kotlin поддерживает обычный набор *побитовых операций* над целыми числами. Они работают на двоичном уровне непосредственно с битовыми представлениями чисел. Побитовые операции представлены функциями, которые могут быть вызваны в инфиксной форме. Они могут быть применены только к `Int` и `Long`.
```kotlin
val x = (1 shl 2) and 0x000FF000
```

Ниже приведён полный список битовых операций:

- `shl(bits)` – сдвиг влево с учётом знака (`<<` в Java)
- `shr(bits)` – сдвиг вправо с учётом знака (`>>` в Java)
- `ushr(bits)` – сдвиг вправо без учёта знака (`>>>` в Java)
- `and(bits)` – побитовое И
- `or(bits)` – побитовое ИЛИ
- `xor(bits)` – побитовое исключающее ИЛИ
- `inv()` – побитовое отрицание

##### Сравнение чисел с плавающей точкой
В этом разделе обсуждаются следующие операции над числами с плавающей запятой:

- Проверки на равенство: `a == b` и `a != b`
- Операторы сравнения: `a < b`, `a > b`, `a <= b`, `a >= b`
- Создание диапазона и проверка диапазона: `a..b`, `x in a..b`, `x !in a..b`

Когда статически известно, что операнды `a` и `b` являются `Float` или `Double` или их аналогами с nullable-значением (тип объявлен или является результатом [умного приведения](https://kotlinlang.ru/docs/typecasts.html#smart-casts)), операции с числами и диапазоном, который они образуют, соответствуют стандарту [IEEE 754 для арифметики с плавающей точкой](https://en.wikipedia.org/wiki/IEEE_754).

Однако для поддержки общих вариантов использования и обеспечения полного упорядочивания, когда операнды статически *не* объявлены как числа с плавающей запятой (например, `Any`, `Comparable<...>`, параметр типа), операции используют реализации `equals` и `compareTo` для `Float` и `Double`, которые не согласуются со стандартом, так что:

- `NaN` считается равным самому себе
- `NaN` считается больше, чем любой другой элемент, включая “POSITIVE_INFINITY”
- `-0.0` считается меньше, чем `0.0`

##### Целые беззнаковые числа
В дополнение к [целочисленным типам](#целочисленные-типы), в Kotlin есть следующие типы целых беззнаковых чисел:

- `UByte`: беззнаковое 8-битное целое число, в диапазоне от 0 до 255
- `UShort`: беззнаковое 16-битное целое число, в диапазоне от 0 до 65535
- `UInt`: беззнаковое 32-битное целое число, в диапазоне от 0 до 2^32^ - 1
- `ULong`: беззнаковое 64-битное целое число, в диапазоне от 0 до 2^64^ - 1

Беззнаковые типы поддерживают большинство операций своих знаковых аналогов.

> Изменение типа с беззнакового типа на его знаковый аналог (и наоборот) является *двоично несовместимым* изменением.

###### Беззнаковые массивы и диапазоны
> Беззнаковые массивы и операции над ними находятся в стадии бета-тестирования. Они могут быть несовместимо изменены в любое время.

Как и в случае с примитивами, каждому типу без знака соответствует тип массивов знаковых типов:

- `UByteArray`: массив беззнаковых `byte`
- `UShortArray`: массив беззнаковых `short`
- `UIntArray`: массив беззнаковых `int`
- `ULongArray`: массив беззнаковых `long`

Как и целочисленные массивы со знаком, такие массивы предоставляют API, аналогичный классу `Array`, без дополнительных затрат на оборачивание.

При использовании массивов без знака вы получите предупреждение, что эта функция еще не стабильна. Чтобы удалить предупреждение используйте аннотацию `@ExperimentalUnsignedTypes`. Вам решать, должны ли ваши пользователи явно соглашаться на использование вашего API, но имейте в виду, что беззнаковый массив не является стабильной функцией, поэтому API, который он использует, может быть нарушен изменениями в языке.

[Диапазоны и прогрессии](#диапазоны-и-прогрессии) поддерживаются для `UInt` и `ULong` классами `UIntRange,UIntProgression`, `ULongRange` и `ULongProgression`. Вместе с целочисленными беззнаковыми типами эти классы стабильны.

###### Литералы
Чтобы целые беззнаковые числа было легче использовать, в Kotlin можно помечать целочисленный литерал суффиксом, указывающим на определенный беззнаковый тип (аналогично `Float` или `Long`):

- `u` и `U` помечают беззнаковые литералы. Точный тип определяется на основе ожидаемого типа. Если ожидаемый тип не указан, компилятор будет использовать `UInt` или `ULong` в зависимости от размера литерала.

  ```kotlin
  val b: UByte = 1u  // UByte, есть ожидаемый тип
  val s: UShort = 1u // UShort, есть ожидаемый тип
  val l: ULong = 1u  // ULong, есть ожидаемый тип

  val a1 = 42u // UInt: ожидаемого типа нет, константе подходит тип UInt
  val a2 = 0xFFFF_FFFF_FFFFu // ULong: ожидаемого типа нет, тип UInt не подходит константе
  ```

- `uL` и `UL` явно помечают литерал как `unsigned long`.

  ```kotlin
  val a = 1UL // ULong, даже несмотря на то, что ожидаемого типа нет и константа вписывается в UInt
  ```

#### Логический тип
Тип `Boolean` представляет логический тип данных и принимает два значения: `true` и `false`.

При необходимости использования nullable-ссылок логические переменные оборачиваются `Boolean?`.

Встроенные действия над логическими переменными включают:

- `||` – ленивое логическое ИЛИ
- `&&` – ленивое логическое И
- `!` – отрицание

```kotlin
val myTrue: Boolean = true
val myFalse: Boolean = false
val boolNull: Boolean? = null

println(myTrue || myFalse)
println(myTrue && myFalse)
println(!myTrue)
```

> В JVM: nullable-ссылки на логические объекты заключены в рамки аналогично числам.

!!! example [Example](samples/02_Syntax/11_LogicalOperations/src/Main.kt)
```kotlin
fun main() {
    val testTrue = true
    val testFalse = false
    val testNull: Boolean? = null

    println(testTrue && testFalse)
    println(testTrue || testFalse)
    println(!testTrue || testFalse)
    println(!testTrue || !testFalse)

    println(2 > 5 && 9 > 0)
}
```

<details>
<summary>Output</summary>

```
false
true
false
true
false

Process finished with exit code 0
```

</details>

#### Символы
Символы в Kotlin представлены типом `Char`. Символьные литералы заключаются в одинарные кавычки: `'1'`.

Специальные символы начинаются с обратного слеша `\.` Поддерживаются следующие escape-последовательности: `\t`, `\b`, `\n`, `\r`, `\'`, `\"`, `\\` и `\$`.

Для кодирования любого другого символа используйте синтаксис escape-последовательности Юникода: `'\uFF00'`.
```kotlin
val aChar: Char = 'a'

println(aChar)
println('\n') // выводит дополнительный символ новой строки
println('\uFF00')
```

Если значение символьной переменной – цифра, её можно явно преобразовать в `Int` с помощью функции `digitToInt()`.

> В JVM: Подобно числам, символы оборачиваются при необходимости использования nullable-ссылки. При использовании обёрток тождественность (равенство по ссылке) не сохраняется.

!!! example [Example](samples/02_Syntax/12_Symbols/src/Main.kt)
```kotlin
fun main() {
    val testChar = 'N'
    println(testChar)
    println("Новая строка\n")
    println("Еще одна новая строка")
    println()
    println("1\t2\t3\t4\t5")
    println('9'.digitToInt())
    // println("9".digitToInt()) // => Kotlin: Overload resolution ambiguity between candidates:
    println('\uFF00') // => ＀
}
```

<details>
<summary>Output</summary>

```
N
Новая строка

Еще одна новая строка

1	2	3	4	5
9
＀

Process finished with exit code 0
```

</details>

!!! error Error
```kotlin
println("9".digitToInt())
```

<details>
<summary>Output</summary>

```
Kotlin: Overload resolution ambiguity between candidates: [@InlineOnly() fun println(message: Any?): Unit, @InlineOnly() fun println(message: Boolean): Unit, @InlineOnly() fun println(message: Byte): Unit, ...]
```

</details>

#### Строки
Строки в Kotlin представлены типом `String`. Как правило, строка представляет собой последовательность символов в двойных кавычках (`"`).
```kotlin
val str = "abcd 123"
```

Строки состоят из символов, которые могут быть получены по порядковому номеру: `s[i]`. Проход по строке выполняется циклом `for`.
```kotlin
for (c in str) {
    println(c)
}
```

Строки являются неизменяемыми. После инициализации строки вы не можете изменить ее значение или присвоить ей новое. Все операции, преобразующие строки, возвращают новый объект `String`, оставляя исходную строку неизменной.
```kotlin
val str = "abcd"
println(str.uppercase()) // Создается и выводится новый объект String
println(str) // исходная строка остается прежней
```

Для объединения строк используется оператор `+`. Это работает и для объединения строк с другими типами, если первый элемент в выражении является строкой.
```kotlin
val s = "abc" + 1
println(s + "def") // abc1def
```

Обратите внимание, что в большинстве случаев использование [строковых шаблонов](#строковые-шаблоны) или обычных строк предпочтительнее объединения строк.

!!! example [Example](samples/02_Syntax/13_Strings/src/Main.kt)
```kotlin
fun main() {
    var testString = "Строка символов"
    println(testString.uppercase())
    println(testString)
    testString = testString.uppercase()
    val newTestString = testString.uppercase()
    println(newTestString)
    testString = "Измененное значение переменной"
    println(testString + "!!!")
    println("${testString.substring(5, 9)}")
}
```

<details>
<summary>Output</summary>

```
СТРОКА СИМВОЛОВ
Строка символов
СТРОКА СИМВОЛОВ
Измененное значение переменной!!!
енно

Process finished with exit code 0

```

</details>

##### Строковые литералы
В Kotlin представлены два типа строковых литералов:

- *экранированные* строки с экранированными символами
- *обычные* строки, которые могут содержать символы новой строки и произвольный текст

Вот пример экранированной строки:
```kotlin
val s = "Hello, world!\n"
```

Экранирование выполняется общепринятым способом, а именно с помощью обратного слеша (`\`). Список поддерживаемых escape-последовательностей см. в разделе [Символы](#символы) выше.

Обычная строка выделена тройной кавычкой (`"""`), не содержит экранированных символов, но может содержать символы новой строки и любые другие символы:
```kotlin
val text = """
  for (c in "foo")
    print(c)
"""
```

Чтобы удалить пробелы в начале обычных строк, используйте функцию [`trimMargin()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-margin.html).
```kotlin
val text = """
    |Tell me and I forget.
    |Teach me and I remember.
    |Involve me and I learn.
    |(Benjamin Franklin)
    """.trimMargin()
```

По умолчанию `|` используется в качестве префикса поля, но вы можете выбрать другой символ и передать его в качестве параметра, например, `trimMargin(">")`.

!!! example [Example](samples/02_Syntax/14_StringLiterals/src/Main.kt)
```kotlin
fun main() {
    val s = "Hello, world!\n"
    println("Regular escaped string: " + s)

    var text = """
        for (c in "foo"){
            print(c)
        }"""

    println(text + "\n")
    println(text.trimIndent() + "\n")

    text = """
    |Tell me and I forget.
    |Teach me and I remember.
    |Involve me and I learn.
    |(Benjamin Franklin)
    """.trimMargin()
    println(text)
}

```

<details>
<summary>Output</summary>

```
Regular escaped string: Hello, world!


        for (c in "foo"){
            print(c)
        }

for (c in "foo"){
    print(c)
}

Tell me and I forget.
Teach me and I remember.
Involve me and I learn.
(Benjamin Franklin)

Process finished with exit code 0

```

</details>

##### Строковые шаблоны
Строки могут содержать *шаблонные* выражения, т.е. участки кода, которые выполняются, а полученный результат встраивается в строку. Шаблон начинается со знака доллара (`$`) и состоит либо из простого имени (например, переменной),
```kotlin
val i = 10
println("i = $i") // выведет "i = 10"
```

либо из произвольного выражения в фигурных скобках.
```kotlin
val s = "abc"
println("$s.length is ${s.length}") // выведет "abc.length is 3"
```

Шаблоны поддерживаются как в обычных, так и в экранированных строках. При необходимости вставить символ `$` в обычную строку (такие строки не поддерживают экранирование обратным слешом) перед любым символом, который разрешен в качестве начала идентификатора, используйте следующий синтаксис:
```kotlin
val price = """
${'$'}_9.99
"""
```

#### Массивы
Массивы в Kotlin представлены классом `Array`, обладающим функциями `get` и `set` (которые обозначаются `[]` согласно соглашению о перегрузке операторов), и свойством `size`, а также несколькими полезными встроенными функциями.
```kotlin
class Array<T> private constructor() {
    val size: Int
    operator fun get(index: Int): T
    operator fun set(index: Int, value: T): Unit

    operator fun iterator(): Iterator<T>
    // ...
}
```

Для создания массива используйте функцию `arrayOf()`, которой в качестве аргумента передаются элементы массива, т.е. выполнение `arrayOf(1, 2, 3)` создаёт массив `[1, 2, 3]`. С другой стороны функция `arrayOfNulls()` может быть использована для создания массива заданного размера, заполненного значениями `null`.

Также для создания массива можно использовать фабричную функцию, которая принимает размер массива и функцию, возвращающую начальное значение каждого элемента по его индексу.
```kotlin
// создаёт массив типа Array<String> со значениями ["0", "1", "4", "9", "16"]
val asc = Array(5) { i -> (i * i).toString() }
asc.forEach { println(it) }
```

Как отмечено выше, оператор `[]` используется вместо вызовов встроенных функций `get()` и `set()`.

Обратите внимание: в отличие от Java массивы в Kotlin являются *инвариантными*. Это значит, что Kotlin запрещает нам присваивать массив `Array<String>` переменной типа `Array<Any>`, предотвращая таким образом возможный отказ во время исполнения (хотя вы можете использовать `Array<out Any>`, см. [Проекции типов](https://kotlinlang.ru/docs/generics.html#type-projections)).

!!! example [Example](samples/02_Syntax/15_Arrays/src/Main.kt)
```kotlin
fun main() {
    var testArray = arrayOf("1", 2, true)
    testArray.forEach { print(it.toString() + "\t") }
    println("\n")
    val testArrayNum = Array(5) { i -> (i * i).toString() }
    testArrayNum.forEach { println(it) }
    println(testArrayNum.get(3))
    testArrayNum.set(0, "99")
    testArrayNum.forEach { print(it + "\t") }
}
```

<details>
<summary>Output</summary>

```
1	2	true	

0
1
4
9
16
9
99	1	4	9	16	
Process finished with exit code 0

```

</details>

##### Массивы примитивных типов
Также в Kotlin есть особые классы для представления массивов примитивных типов без дополнительных затрат на оборачивание: `ByteArray`, `ShortArray`, `IntArray` и т.д. Данные классы не наследуют класс `Array`, хотя и обладают тем же набором методов и свойств. У каждого из них есть соответствующая фабричная функция:
```kotlin
val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2]
```

```kotlin
// int массив, размером 5 со значениями [0, 0, 0, 0, 0]
val arr = IntArray(5)

// инициализация элементов массива константой
// int массив, размером 5 со значениями [42, 42, 42, 42, 42]
val arr = IntArray(5) { 42 }

// инициализация элементов массива лямбда-выражением
// int массив, размером 5 со значениями [0, 1, 2, 3, 4] (элементы инициализированы своим индексом)
var arr = IntArray(5) { it * 1 }
```

!!! example [Example](samples/02_Syntax/16_PrimitivesArrays/src/Main.kt)
```kotlin
import kotlin.math.pow

fun main() {
    val testArrayInt: IntArray = intArrayOf(1, 2, 3)
    testArrayInt[0] = testArrayInt[1] + testArrayInt[2]
    testArrayInt.forEach { print(it.toString() + "\t") }
    println()
    val testArrayInit = IntArray(5)
    testArrayInit.forEach { print(it.toString() + "\t ") }
    println()
    val testArrayConst = IntArray(5) { 79 }
    testArrayConst.forEach { print(it.toString() + "\t ") }
    println()
    var testArrayLambda = DoubleArray(9) { 2.0.pow(it) }
    testArrayLambda.forEach { print(it.toString() + "\t ") }
    println()
}
```

<details>
<summary>Output</summary>

```
5	2	3	
0	 0	 0	 0	 0	 
79	 79	 79	 79	 79	 
1.0	 2.0	 4.0	 8.0	 16.0	 32.0	 64.0	 128.0	 256.0	 

Process finished with exit code 0

```

</details>

### Условия и циклы
https://kotlinlang.ru/docs/control-flow.html

#### Условное выражение `if`
В языке Kotlin `if` является выражением, т.е. оно возвращает значение. Это позволяет отказаться от тернарного оператора (`условие ? условие истинно : условие ложно`), потому что обычному `if` вполне по силам его заменить.
```kotlin
// обычное использование
var max = a
if (a < b) max = b

// с блоком else
var max: Int
if (a > b) {
    max = a
} else {
    max = b
}

// в виде выражения
val max = if (a > b) a else b
```

“Ветви” выражения `if` могут быть блоками, т.е. содержать несколько строк кода, при этом последнее выражение является значением блока:
```kotlin
val max = if (a > b) {
    print("возвращаем a")
    a
} else {
    print("возвращаем b")
    b
}
```

Если вы используете `if` в качестве выражения (например, возвращая его значение или присваивая его переменной), то использование ветки `else` является обязательным.

!!! example [Example](samples/02_Syntax/17_If/src/Main.kt)
```kotlin
fun main() {
    var testMax = 5
    val testNew = (0..9).random()
    println("testNew: $testNew")
    if (testMax < testNew) testMax = testNew
    println(testMax)

    val testOne = (10..19).random()
    val testTwo = (10..19).random()
    println("testOne: $testOne, testTwo: $testTwo")

    if (testOne > testTwo) {
        println(testOne)
    } else {
        println(testTwo)
    }

    val testPrint = if (testOne > testTwo) {
        print("Возвращаем testOne - ")
        testOne
    } else {
        print("Возвращаем testTwo - ")
        testTwo
    }

    println(testPrint)
}
```

<details>
<summary>Output</summary>

```
testNew: 7
7
testOne: 17, testTwo: 13
17
Возвращаем testOne - 17

Process finished with exit code 0

```

</details>

#### Условное выражение `when`
`when` определяет условное выражение с несколькими “ветвями”. Оно похоже на оператор `switch`, присутствующий в C-подобных языках.
```kotlin
when (x) {
    1 -> print("x == 1")
    2 -> print("x == 2")
    else -> { // обратите внимание на блок
        print("x не равен ни 1, ни 2")
    }
}
```

`when` последовательно сравнивает свой аргумент со всеми указанными значениями, пока не выполнится какое-либо из условий ветвей.

`when` можно использовать и как выражение, и как оператор. При использовании его в виде выражения значение первой ветки, удовлетворяющей условию, становится значением всего выражения. При использовании в виде оператора значения отдельных веток отбрасываются. В точности как `if`: каждая ветвь может быть блоком и её значением является значение последнего выражения блока.

Значение ветки `else` вычисляется в том случае, когда ни одно из условий в других ветках не удовлетворено.

Если when используется как *выражение*, то ветка else является обязательной, за исключением случаев, в которых компилятор может убедиться, что ветки покрывают все возможные значения. Так происходит, например с записями [класса `enum`](https://kotlinlang.ru/docs/enum-classes.html) и с подтипами [`sealed` (изолированных) классов](https://kotlinlang.ru/docs/sealed-classes.html).
```kotlin
enum class Bit {
  ZERO, ONE
}
val numericValue = when (getRandomBit()) {
    Bit.ZERO -> 0
    Bit.ONE -> 1
    // 'else' не требуется, потому что все случаи учтены
}
```

В *операторах* `when` ветка `else` является обязательной в следующих условиях:

- `when` имеет объект типа `Boolean`, `enum`, `sealed` или их nullable-аналоги;
- ветки `when` не охватывают все возможные случаи для этого объекта.

```kotlin
enum class Color {
    RED, GREEN, BLUE
}

when (getColor()) {
    Color.RED -> println("red")
    Color.GREEN -> println("green")
    Color.BLUE -> println("blue")
    // 'else' не требуется, потому что все случаи учтены
}

when (getColor()) {
    Color.RED -> println("red") // нет веток для GREEN и BLUE
    else -> println("not red") // 'else' обязателен
}
```

Если для нескольких значений выполняется одно и то же действие, то условия можно перечислять в одной ветке через запятую.
```kotlin
when (x) {
    0, 1 -> print("x == 0 or x == 1")
    else -> print("otherwise")
}
```

Помимо констант в ветках можно использовать произвольные выражения.
```kotlin
when (x) {
    s.toInt() -> print("s encodes x")
    else -> print("s does not encode x")
}
```

Также можно проверять вхождение аргумента в [интервал](#диапазоны-и-прогрессии) `in` или `!in` или его наличие в коллекции:
```kotlin
when (x) {
    in 1..10 -> print("x is in the range")
    in validNumbers -> print("x is valid")
    !in 10..20 -> print("x is outside the range")
    else -> print("none of the above")
}
```

Помимо этого Kotlin позволяет с помощью `is` или `!is` проверить тип аргумента. Обратите внимание, что благодаря [умным приведениям](https://kotlinlang.ru/docs/typecasts.html#smart-casts) вы можете получить доступ к методам и свойствам типа без дополнительной проверки.
```kotlin
fun hasPrefix(x: Any) = when(x) {
    is String -> x.startsWith("prefix")
    else -> false
}
```

`when` удобно использовать вместо цепочки условий вида `if`-`else if`. При отсутствии аргумента условия работают как простые логические выражения, а тело ветки выполняется при его истинности.
```kotlin
when {
    x.isOdd() -> print("x is odd")
    y.isEven() -> print("y is even")
    else -> print("x+y is odd")
}
```

Можно получать переменную внутри `when` условия по следующему синтаксису:
```kotlin
fun Request.getBody() =
    when (val response = executeRequest()) {
        is Success -> response.body
        is HttpError -> throw HttpException(response.status)
    }
```

Такая переменная, объявленная внутри условия `when` может быть видна только внутри тела этого `when`.

!!! example [Example](samples/02_Syntax/18_When/src/Main.kt)
```kotlin
fun main() {
    val testRandom = (1..9).random()
    println("testRandom: $testRandom")
    when (testRandom) {
        1 -> println("testRandom == 1")
        2, 4, 6, 8 -> println("testRandom == 2 или 4 или 6 или 8")
        else -> { // обратите внимание на блок
            println("testRandom не равен 1 и не кратно 2")
        }
    }
    val testArrayInt = IntArray(10) { it }
    val testRandomNew = (1..30).random()
    println("testRandomNew: $testRandomNew")
    when (testRandomNew) {
        in 10..20 -> println("Значение в промежутке от 10 до 20")
        in testArrayInt -> println("Значение попадает в массив с числами от 0 до 9")
        !in 21..25 -> println("Значение больше 25")
        else -> println("Значение в промежутке от 21 до 25")
    }
    val testRem = when(testRandomNew) {
        in 1..15 -> testRandomNew
        else -> "Значение больше 15"
    }
    println(testRem)
}
```

<details>
<summary>Output</summary>

```
testRandom: 6
testRandom == 2 или 4 или 6 или 8
testRandomNew: 4
Значение попадает в массив с числами от 0 до 9
4

Process finished with exit code 0

```

</details>

#### Цикл `for`
Цикл `for` обеспечивает перебор всех значений, поставляемых итератором. Он эквивалентен циклу `foreach` в таких языках, как C#.
```kotlin
for (item in collection) print(item)
```

Телом цикла может быть блок кода.
```kotlin
for (item: Int in ints) {
    // ...
}
```

Как отмечено выше, цикл `for` позволяет проходить по всем элементам объекта, имеющего итератор, например:

- обладающего внутренней или внешней функцией `iterator()`, возвращаемый тип которой `Iterator<>`:
  - обладает внутренней или внешней функцией `next()`
  - обладает внутренней или внешней функцией `hasNext()`, возвращающей `Boolean`.

Все три указанные функции должны быть объявлены как `operator`.

Чтобы перебрать диапазон чисел, используйте выражение диапазона:
```kotlin
for (i in 1..3) {
    println(i)
}
for (i in 6 downTo 0 step 2) {
    println(i)
}
```

Цикл `for` по диапазону или массиву компилируется в основанный на индексе цикл, который не создает объект итератора.

Если при проходе по массиву или списку необходим порядковый номер элемента, используйте следующий подход:
```kotlin
for (i in array.indices) {
    println(array[i])
}
```

Также вы можете использовать библиотечную функцию `withIndex`.
```kotlin
for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}
```

!!! example [Example](samples/02_Syntax/20_For/src/Main.kt)
```kotlin
fun main() {
    val testArrayInt = IntArray(5) { it * 5 }

    for (item in testArrayInt) print(item.toString() + "\t")
    println()
    for (item in testArrayInt) {
        if (item % 3 == 0) {
            print("кратно\t")
        } else {
            print("некратно\t")
        }
    }
    println()
    for ((index, value) in testArrayInt.withIndex()) {
        println("Индекс - $index. Значение - $value")
    }
}
```

<details>
<summary>Output</summary>

```
0	5	10	15	20
кратно	некратно	некратно	кратно	некратно
Индекс - 0. Значение - 0
Индекс - 1. Значение - 5
Индекс - 2. Значение - 10
Индекс - 3. Значение - 15
Индекс - 4. Значение - 20

Process finished with exit code 0
```

</details>

#### Цикл `while`
Тело циклов `while` и `do-while` выполняется до тех пор, пока их условие выполняется. Разница между ними заключается во времени проверки условия:

- `while` проверяет условие и, если оно истинно, выполняет тело, а затем возвращается к проверке условия;
- `do-while` выполняет тело и только затем проверяет условие. Если оно выполняется, цикл повторяется. Таким образом, тело `do-while` выполняется по крайней мере один раз независимо от условия.
```kotlin
while (x > 0) {
    x--
}

do {
    val y = retrieveData()
} while (y != null) // y здесь доступно!
```

!!! example [Example](samples/02_Syntax/19_While/src/Main.kt)
```kotlin
fun main() {
    val testSize = (1..10).random()
    var testArr = IntArray(testSize)

    var i = 0
    while (i < testSize) {
        testArr[i] = (20..50).random()
        i++
    }
    testArr.forEach { print(it.toString() + "\t") }
    println()
    var j = 0
    do {
        testArr[j] = (20..50).random()
        j++
    } while (j < testSize)
    testArr.forEach { print(it.toString() + "\t") }
}
```

<details>
<summary>Output</summary>

```
21	40	40	28
45	21	50	48
Process finished with exit code 0

```

</details>

#### Break и continue в циклах
Kotlin поддерживает привычные операторы `break` и `continue` в циклах. См. [Операторы перехода](#операторы-перехода).

### Операторы перехода
https://kotlinlang.ru/docs/returns.html

В Kotlin определено три оператора перехода:

- `return` по умолчанию производит возврат из ближайшей окружающей его функции или анонимной функции;
- `break` завершает выполнение ближайшего окружающего его цикла;
- `continue` продолжает выполнение цикла со следующего его шага, без обработки оставшегося кода текущей итерации.

Все эти выражения можно использовать как часть более крупных выражений:
```kotlin
val s = person.name ?: return
```

Эти выражения имеют тип `Nothing`.

#### Метки операторов break и continue
Любое выражение в Kotlin может быть помечено меткой *label*. Метки имеют форму идентификатора, за которым следует знак `@`, например `abc@` или `fooBar@`. Для того чтобы пометить выражение, мы просто ставим метку перед ним.
```kotlin
loop@ for (i in 1..100) {
    // ...
}
```

Теперь мы можем уточнить значения операторов `break` или `continue` с помощью меток.
```kotlin
loop@ for (i in 1..100) {
    for (j in 1..100) {
        if (...) break@loop
    }
}
```

Оператор `break`, отмеченный `@loop`, переводит выполнение кода в точку сразу после цикла, отмеченного этой меткой. Оператор `continue` продолжает цикл со следующей его итерации.

#### Возврат к меткам
В Kotlin функции могут быть вложены друг в друга с помощью литералов функций, локальных функций и анонимных объектов. Подходящий `return` позволит вернуться из внешней функции. Одним из самых важных применений этой синтаксической конструкции является возврат из лямбда-выражения. Напомним, что в таких случаях, как в примере ниже, `return` возвращает из ближайшей заключающей функции — `foo`:
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return // нелокальный возврат, непосредственно к объекту вызывающему функцию foo()
        print(it)
    }
    println("эта строка не достижима")
}
```

Обратите внимание, что такой нелокальный возврат поддерживается только лямбда-выражениями, переданными [инлайн-функциям](https://kotlinlang.ru/docs/inline-functions.html). Чтобы вернуться из лямбда-выражения, к оператору стоит поставить метку и тем самым сделать уточнение для `return`.
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // локальный возврат внутри лямбды, то есть к циклу forEach
        print(it)
    }
    print(" выполнится с использованием явной метки(lit@)")
}
```

Теперь он возвращает только из лямбда-выражения. Зачастую намного более удобно использовать *неявные метки*, потому что такие метки имеют такое же имя, как и функция, к которой относится лямбда.
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return@forEach // локальный возврат внутри лямбды, то есть к циклу forEach
        print(it)
    }
    print(" выполнится с использованием неявной метки(forEach@)")
}
```

Возможно также использование [анонимной функции](https://kotlinlang.ru/docs/lambdas.html#anonymous-functions) в качестве альтернативы лямбда-выражениям. Оператор `return` возвращает из самой анонимной функции.

```
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {
        if (value == 3) return  // локальный возврат внутри анонимной функции, то есть к циклу forEach
        print(value)
    })
    print(" выполнится с использованием анонимной функции")
}

```

Обратите внимание, что использование локальных возвратов в предыдущих трех примерах аналогично использованию `continue` в обычных циклах.

Прямого эквивалента для `break` не существует, но его можно смоделировать — добавить еще одну вложенную лямбду и нелокально вернуться из нее.
```kotlin
fun foo() {
    run loop@{
        listOf(1, 2, 3, 4, 5).forEach {
            if (it == 3) return@loop // нелокальный возврат из лямбды к вызывающему run
            print(it)
        }
    }
    print(" выполнится с использованием вложенной метки")
}
```

При возвращении значения парсер отдаёт предпочтение специализированному возврату.
```kotlin
return@a 1
```

что значит “верни `1` в метке `@a`”, а не “верни выражение с меткой `(@a 1)`”.

### Диапазоны и прогрессии
https://kotlinlang.ru/docs/ranges.html

Kotlin позволяет легко создавать диапазоны значений с помощью функции `rangeTo()`, которая находится в пакете `kotlin.ranges`. У функции есть операторная форма — `..`. Обычно `rangeTo()` используется совместно с функциями `in` или `!in`.
```kotlin
if (i in 1..4) {  // эквивалентная запись 1 <= i && i <= 4
    print(i)
}
```
У диапазонов целочисленных типов (`IntRange`, `LongRange`, `CharRange`) есть дополнительная функция: они поддерживают итерацию. Эти диапазоны также являются [прогрессиями](https://en.wikipedia.org/wiki/Arithmetic_progression).

Подобные диапазоны, как правило, используются в цикле `for`.
```kotlin
fun main() {
    for (i in 1..4) print(i) // 1234
}
```

Для перебора чисел в обратном порядке используйте функцию `downTo` вместо `..`.
```kotlin
fun main() {
    for (i in 4 downTo 1) print(i) // 4321
}
```

Можно перебирать числа с произвольным шагом. Осуществляется это с помощью функции `step`.
```kotlin
fun main() {
    for (i in 1..8 step 2) print(i) // 1357
    println()
    for (i in 8 downTo 1 step 2) print(i) // 8642
}
```

Если требуется перебрать диапазон чисел, исключая его последний элемент, то используйте функцию `until`.
```kotlin
fun main() {
    for (i in 1 until 10) { // i in [1, 10), 10 будет исключён
        print(i) // 123456789
    }
}
```

#### Диапазоны
В математическом смысле <dfn title="диапазон">диапазон</dfn> — это закрытый интервал: он определяется двумя значениями и они оба являются частью диапазона. Диапазоны применимы к сопоставимым (*comparable*) типам: имея порядок, вы можете определить, находится ли произвольный экземпляр в диапазоне между двумя заданными экземплярами.

Основная операция с диапазонами — это `contains`, которая обычно используется в форме операторов `in` и `!in`.

Чтобы создать диапазон на основе ваших классов, вызовите функцию `rangeTo()` для начального значения диапазона и укажите конечное значение в качестве аргумента. Чаще всего используется операторная форма функции `rangeTo()` — `..`.
```kotlin
class Version(val major: Int, val minor: Int): Comparable<Version> {
    override fun compareTo(other: Version): Int {
        if (this.major != other.major) {
            return this.major - other.major
        }
        return this.minor - other.minor
    }
}

fun main() {
    val versionRange = Version(1, 11)..Version(1, 30)
    println(Version(0, 9) in versionRange) // false
    println(Version(1, 20) in versionRange) // true
}
```

#### Прогрессии
Как показано в приведённых выше примерах, диапазоны целочисленных типов, таких как `Int`, `Long` и `Char`, можно рассматривать как [арифметические прогрессии](https://en.wikipedia.org/wiki/Arithmetic_progression). В Kotlin есть специальные типы для определения таких прогрессий: `IntProgression`, `LongProgression` и `CharProgression`.

У прогрессий есть три основных свойства: `first`, `last` и `step`, при этом `step` не может быть нулём. `first` — это первый элемент. Последующие элементы — это предыдущий элемент плюс `step`. Итерация по прогрессии с положительным шагом (`step`) эквивалентна индексируемому циклу `for` в Java / JavaScript.
```kotlin
for (int i = first; i <= last; i += step) {
  // ...
}
```
При неявном создании прогрессии путём итерации диапазона, элементы `first` и `last` этой прогрессии являются конечными точками диапазона, а `step` равен 1.
```kotlin
fun main() {
    for (i in 1..10) print(i) // 12345678910
}
```

Чтобы прогрессии задать собственный шаг, используйте функцию `step`.
```kotlin
fun main() {
    for (i in 1..8 step 2) print(i) // 1357
}
```

Последний элемент прогрессии (`last`) рассчитывается следующим образом: * Для положительного шага: максимальное значение, но не больше конечного значения — `(last - first) % step == 0`. * Для отрицательного шага: минимальное значение, но не меньше конечного значения — `(last - first) % step == 0`.

Таким образом, элемент `last` не всегда совпадает с конечным значением диапазона.
```kotlin
fun main() {
    for (i in 1..9 step 3) print(i) // 147, last = 7
}
```

Чтобы создать прогрессию для итерации в обратном направлении, при определении диапазона используйте `downTo` вместо `..`.
```kotlin
fun main() {
    for (i in 4 downTo 1) print(i) // 4321
}
```

Прогрессии реализуют интерфейс `Iterable<N>`, где `N` — это `Int`, `Long` или `Char`, поэтому вы можете использовать их в различных [функциях коллекций](https://kotlinlang.ru/docs/collection-operations.html), таких как map, filter и т. д.
```kotlin
fun main() {
    println((1..10).filter { it % 2 == 0 }) // [2, 4, 6, 8, 10]
}
```

!!! example [Example](./samples/02_Syntax/21_Ranges/src/Main.kt)
```kotlin
fun main() {
    for (i in 1..10) print(i.toString() + "\t")
    println()

    for (i in 1 until 10) print(i.toString() + "\t")
    println()

    for (i in 10 downTo 1) print(i.toString() + "\t")
    println()

    for (i in 1..10 step 3) print(i.toString() + "\t")
    println()
}
```

<details>
<summary>Output</summary>

```
1	2	3	4	5	6	7	8	9	10
1	2	3	4	5	6	7	8	9
10	9	8	7	6	5	4	3	2	1
1	4	7	10

Process finished with exit code 0

```

</details>

### Основы — задачи
[66f12d265040133e8429e1c4](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345142)

Во всех приведенных ниже задачах предусмотреть возможные ошибки пользователей при вводе данных и осуществить их обработку. Например, в задаче 4 пользователь может ввести не только числа. Или их будет больше двух, или же символов операции будет более одного.

Также, во всех задачах, пользователь должен получать подсказку, что ему необходимо ввести или сделать. То есть для задачи 5 в консоли должно быть примерно следующее (см. рис.)

#### 1. Задача 1.

Создать приложение, которое подсчитывает количество подряд идущих одинаковых символов во введенной строке. На вход подается, например, строка `AAADSSSRRTTHAAAA`. На выходе получаем `A3DS3R2T2HA4`. То есть, если количество подряд идущих символов меньше двух, то мы не пишем единицу

[Решение](src/02_BasicSyntax/Task_01/src/Main.kt)

#### 2. Задача 2.

Создать приложение, которое подсчитывает количество различных символов во введенной строке. Символы в ответе расположить в алфавитном порядке. Например, дана строка `AASADDSS`. На выходе получаем:
```
A - 3
D - 2
S - 3
```

[Решение](src/02_BasicSyntax/Task_02/src/Main.kt)

#### 3. Задача 3.

Создать приложение, которое преобразует введенное пользователем натуральное число из 10-ичной системы в двоичную.

[Решение](src/02_BasicSyntax/Task_03/src/Main.kt)

#### 4. Задача 4.

Создать приложение, с помощью которого пользователь, введя два числа и символ операции, узнает результат. Символами операции могут быть: `/` — деление, `*` — умножение, `+` — сложение, `-` — вычитание. Числа могут быть вещественными. Числа и знак операции разделяются между собой одним пробелом. Ввод производится в формате — `ЧИСЛО1 ЧИСЛО2 ОПЕРАЦИЯ`

[Решение](src/02_BasicSyntax/Task_04/src/Main.kt)

#### 5. Задача 5.

Создать приложение, с помощью которого пользователь, введя целое число $n$ и основание степени $x$ узнает, существует ли целочисленный показатель степени $y$ для которого выполняется равенство $x^y = n$. В случае, если показатель существует – вычислить его и вывести. В противном случае вывести текст – «Целочисленный показатель не существует».

[Решение](src/02_BasicSyntax/Task_05/src/Main.kt)

#### 6. Задача 6.

Создать приложение, в котором пользователь вводит две различных цифры. На выходе приложение выдает, если это возможно, из введенных цифр, нечетное число. Результат выводится в консоль. При невозможности создать нечетное число выводится сообщение – «Создать нечетное число невозможно». Каждое число вводится на отдельной строке

[Решение](src/02_BasicSyntax/Task_06/src/Main.kt)

Решение предоставить в виде ссылки на GitHub.

## 03 Массивы, коллекции
[66f429275040133e8429e1fb](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-3)

### Массивы
[670284635040133e8429e33e](https://e-learn.petrocollege.ru/mod/url/view.php?id=345143)

Массивы в Kotlin представлены классом `Array`, обладающим функциями `get` и `set` (которые обозначаются `[]` согласно соглашению о перегрузке операторов), и свойством `size`, а также несколькими полезными встроенными функциями.
```kotlin
class Array<T> private constructor() {
    val size: Int
    operator fun get(index: Int): T
    operator fun set(index: Int, value: T): Unit

    operator fun iterator(): Iterator<T>
    // ...
}
```

Как отмечено выше, оператор `[]` используется вместо вызовов встроенных функций `get()` и `set()`.

Обратите внимание: в отличие от Java массивы в Kotlin являются *инвариантными*. Это значит, что Kotlin запрещает нам присваивать массив `Array<String>` переменной типа `Array<Any>`, предотвращая таким образом возможный отказ во время исполнения (хотя вы можете использовать `Array<out Any>`, см. [Проекции типов](https://kotlinlang.ru/docs/generics.html#type-projections)).

!!! example [Example](samples/02_Syntax/15_Arrays/src/Main.kt)
```kotlin
fun main() {
    var testArray = arrayOf("1", 2, true)
    testArray.forEach { print(it.toString() + "\t") }
    println("\n")
    val testArrayNum = Array(5) { i -> (i * i).toString() }
    testArrayNum.forEach { println(it) }
    println(testArrayNum.get(3))
    testArrayNum.set(0, "99")
    testArrayNum.forEach { print(it + "\t") }
}
```

Массив можно создать двумя способами — через конструктор `Array()` или через методы `arrayOf()`, `arrayOfNulls()`, `emptyArray()`.

#### Объявление массива с использованием библиотечного метода `arrayOf()`
Для создания массива используйте функцию `arrayOf()`, которой в качестве аргумента передаются элементы массива, т.е. выполнение `arrayOf(1, 2, 3)` создаёт массив `[1, 2, 3]`.

Создадим массив и получим значение третьего элемента.
```kotlin
val myArray = arrayOf(1, 2, 3, 4, 5)
println(myArray[2])
```

Узнать длину массива можно при помощи свойства **`size`**.

```kotlin
println(myArray.size) // 5
```

А что случится, если мы добавим в массив строки?

```kotlin
val myArray = arrayOf(1, 2, 3, 4, 5, "зайчик", "вышел", "погулять")
println(myArray[5])
```

Ничего страшного, у нас получился массив смешанного типа. Всё работает, ничего не ломается.

Если мы хотим строгого поведения и не хотим смешивать разные типы, то используем обобщения.

```kotlin
val myArray = arrayOf<Int>(1, 2, 3, 4, 5) // только числа Integer
```

Таким образом, в Kotlin имеются "классические" массивы, когда в одном массиве могут быть данные только одного типа, и в массив нельзя добавлять элементы, как в список.[^younglinux]

[^younglinux]: [Массивы в Kotlin](https://younglinux.info/kotlin/array)

Объявление массива в Kotlin:
```kotlin
val имя: Array<тип>
```

Массивы обычно объявляют с помощью `val`, но это не значит, что нельзя изменять значения элементов массива. Это лишь значит, что неизменяемой переменной нельзя присвоить другой массив. Однако необходимость в подобном действии возникает редко.

Существует также синонимы метода, когда уже в имени содержится подсказка: `intArrayOf()`, `charArrayOf()`, `booleanArrayOf()`, `longArrayOf()`, `shortArrayOf()`, `byteArrayOf()`.

Перепишем пример.

```kotlin
val myArray = intArrayOf(1, 2, 3, 4, 5)
```

Пройтись по элементам массива и узнать значение индекса можно с помощью метода **`withIndex()`**:

```kotlin
val numbersArray = intArrayOf(1, 2, 3, 4, 5)
for ((index, value) in numbersArray.withIndex()) {
    println("Значение индекса $index равно $value")
}
```

!!! example [Example](./samples/03_Arrays/01_ArrayOf/src/Main.kt)
```kotlin
fun main() {
    val arrNum: Array<Int>
    arrNum = arrayOf(12, 25, 37, 84, 95)    // преобразует перечисляемые значения в целочисленный массив

    val arrTest = arrayOf(4,7, 9.65, 7.82)  // получаем массив указанного типа
    val arrD: Array<Double> = arrayOf(65.98, 32.81, 83.96, 73.65)

    val testN = arrNum[1]                   // присваиваем значение
    val testU = arrNum.get(4)               // элементу массива

    arrNum[0] = 56                          // получаем значение
    arrNum.set(3, 97)                       // элемента массива
}
```

<details>
<summary><em>Output</em></summary>

```
1	2	true

0
1
4
9
16
9
99	1	4	9	16

```

</details>

#### Свойство `indices`
https://developer.alexanderklimov.ru/android/kotlin/array.php

У массива есть свойство **`indices`** и мы можем переписать пример по другому.

```kotlin
val numbers = intArrayOf(1, 2, 3, 4, 5)
for (index in numbers.indices) {
    println("Значение индекса $index равно ${numbers[index]}")
}
```

Свойство возвращает интервал (`Range`), который содержит все индексы массива. Это позволяет не выйти за пределы массива и избежать ошибки `ArrayIndexOutOfBoundsException`.

Но у свойства есть очень интересная особенность. Взгляните на код:

```kotlin
val numbers = intArrayOf(1, 2, 3, 4, 5)
for(index in numbers.indices - 2) {
    println(numbers[index])
}

// 1 2 4 5
```

Из интервала индексов массива мы убрали третий элемент (отсчёт от 0). И теперь при выводе элементов массива мы не увидим числа 3.

Можно сложить два массива.

```kotlin
val numbers = intArrayOf(1, 2, 3)
val numbers3 = intArrayOf(4, 5, 6)
val foo2 = numbers3 + numbers
println(foo2[5]) // 3
```

#### Объявление массива неустановленных ("пустых"/"нулевых") значений и его инициализация (`arrayOfNulls()`)
Для создания массива заданного размера, заполненного значениями `null`, можно использовать отдельную функцию `arrayOfNulls()`.

```kotlin
val array = arrayOfNulls<Number>(5)
```

Создадим массив с тремя элементами.

```kotlin
val array = arrayOfNulls(3) // [null, null, null]
// равносильно
// arrayOf(null, null, null)
```

Присвоим значения пустым элементам.

```kotlin
var arr2 = arrayOfNulls<String>(2)
arr2.set(0, "1")
arr2.set(1, "2")

// или
arr2[0] = "1"
arr2[1] = "2"

// получить значения
println(arr2[0]) // или arr2.get(0)
println(arr2[1])
```

После создания экземпляра мы можем получить доступ к полям массива и установить их. Есть несколько способов сделать это, но наиболее распространенным является использование свойства `indices`. Это свойство возвращает диапазон допустимых индексов для массива. Мы можем использовать диапазон для доступа и установки значений массива в цикле `for`.

!!! example [Example](samples/03_Arrays/03_ArrayOfNulls/src/Main.kt)
```kotlin
import kotlin.math.pow

fun main() {
    val arrNum = arrayOfNulls<Number>(6)

    arrNum.forEach { print(it.toString() + "\t") }

    println()

    for (i in arrNum.indices) {
        print("before: ${arrNum[i]}, ")
        arrNum[i] = i * i
        print("after: ${arrNum[i]}\n")
    }

    for (i in 0..arrNum.size - 1) {
        arrNum[i] = i.toDouble().pow(i)
    }

    arrNum.forEach { print(it.toString() + "\t") }
}

```

<details>
<summary><em>Output</em></summary>

```
null	null	null	null	null	null
before: null, after: 0
before: null, after: 1
before: null, after: 4
before: null, after: 9
before: null, after: 16
before: null, after: 25
1.0	1.0	4.0	27.0	256.0	3125.0
```

</details>

#### Создание пустого массива (`emptyArray()`)
Создадим пустой массив и заполним его данными.

```kotlin
var arr = emptyArray<String>()
arr += "1"
arr += "2"
arr += "3"
arr += "4"
arr += "5"
```

#### `val` vs `var`
https://developer.alexanderklimov.ru/android/kotlin/array.php

Нужно уяснить разницу между **`var`** и **`val`** при работе с массивами.

```kotlin
// Создали новый массив
var myArray = arrayOf(1, 2, 3)

// Это совершенно новый массив
myArray = arrayOf(4, 5)
```

Фактически мы уничтожили первый массив и создали вместо него второй массив.

Если мы попытаем написать такой же код с использованием `val`, то компилятор запретит такое действие.

```kotlin
// Создали новый массив
val myArray = arrayOf(1, 2, 3)

// Нельзя. Компилятор не пропустит
myArray = arrayOf(4, 5)
```

Но при этом вы можете менять значения элементов массива, созданного через `val`.

```kotlin
val myArray = arrayOf(1, 2)
myArray[0] = 3 // меняем первый элемент массива
myArray[1] = 4 // меняем второй элемент массива
```

#### Генерация значений с помощью инициализатора. Конструктор `Array()`
Также для создания массива можно использовать фабричную функцию, которая принимает размер массива и функцию, возвращающую начальное значение каждого элемента по его индексу.
```kotlin
// создаёт массив типа Array<String> со значениями ["0", "1", "4", "9", "16"]
val asc = Array(5) { i -> (i * i).toString() }
asc.forEach { println(it) }
```

При использовании конструктора нужно указать размер массива в первом параметре и лямбда-выражение во втором.

```kotlin
val myArray = Array(5, { i -> i * 2 })
println(myArray[3])
```

Мы задали пять элементов и каждый элемент в цикле умножаем на 2. В итоге получим массив чисел 0, 2, 4, 6, 8.

Создадим массив строк от "A" до "Z"

```kotlin
val letters = Array<String>(26) { i -> ('A' + i).toString() }
println(letters.joinToString(""))
```

Лямбда-выражение принимает индекс элемента массива и возвращает значение, которое будет помещено в массив с этим индексом. Значение вычисляется путём сложения индекса с кодом символа и преобразованием результата в строку.

Можно опустить тип массива и написать `Array(26)`, компилятор самостоятельно определит нужный тип.

Есть отдельные классы для каждого примитивного типа — `IntArray`, `ByteArray`, `CharArray` и т.д.

```kotlin
val zeros = IntArray(3) // первый способ
val zeros = intArrayOf(0, 0, 0) // второй способ при помощи фабричного метода
println(zeros.joinToString())
```

Можно использовать лямбда-выражение.

```kotlin
val intArray = IntArray(4){i -> i + i}
println(intArray.joinToString())
```

!!! example Example
```kotlin
import kotlin.math.pow
import kotlin.math.sqrt

fun main() {
    val arrGenerate = IntArray(7) { i -> i }
    arrGenerate.forEach { print(it.toString() + "\t") }
    println()

    val arrGenerateFloat = FloatArray(10) { i -> sqrt(i.toFloat()) }
    arrGenerateFloat.forEach { print(it.toString() + "\t") }
    println()

    val arrGenerateDouble = DoubleArray(11) { i -> i.toDouble().pow(1/(i+1).toDouble()) }
    arrGenerateDouble.forEach { print("%.2f".format(it) + "\t") }
    println()

    val arrGenerateStr = Array(3) { i -> "Элемент $i = ${i * i}" }
    arrGenerateStr.forEach { print(it.toString() + "\t") }
    println()

    println(8.0.pow(1 / 3))
    println(8.0.pow(1 / 3.0))
}
```

<details>
<summary><em>Output</em></summary>

```
0	1	2	3	4	5	6
0.0	1.0	1.4142135	1.7320508	2.0	2.236068	2.4494898	2.6457512	2.828427	3.0
0.00	1.00	1.26	1.32	1.32	1.31	1.29	1.28	1.26	1.25	1.23
Элемент 0 = 0	Элемент 1 = 1	Элемент 2 = 4
1.0
2.0
```

</details>

> `println(8.0.pow(1 / 3))` выводит 1, поскольку результатом операции `1 / 3` является `0` как следствие операций с целочисленными типами, а любое число в нулевой степени даёт 1.

#### Вывод значений массива. Класс `Arrays`
Для вывода значений массива используйте класс **`Arrays`** с методом `toString()`, который вернёт результат в удобном и читаемом виде. Сейчас в Kotlin появилась функция **`contentToString()`**, которая является предпочтительным вариантом.

```kotlin
println(Arrays.toString(arr)) // старый способ
println(arr.contentToString()) // рекомендуемый способ
```

#### Массивы примитивных типов
Kotlin автоматически упаковывает примитивные значения в соответствующие им классы-оболочки объектов, что будет иметь пагубные последствия для производительности. Чтобы избежать этих накладных расходов, в Котлине предусмотрена широкая поддержка примитивных массивов.

Так, в Kotlin есть особые классы для представления массивов примитивных типов без дополнительных затрат на оборачивание: `ByteArray`, `ShortArray`, `IntArray` и т.д. Данные классы не наследуют класс `Array`, хотя и обладают тем же набором методов и свойств. У каждого из них есть соответствующая фабричная функция:
```kotlin
val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2]
```

```kotlin
// int массив, размером 5 со значениями [0, 0, 0, 0, 0]
val arr = IntArray(5)

// инициализация элементов массива константой
// int массив, размером 5 со значениями [42, 42, 42, 42, 42]
val arr = IntArray(5) { 42 }

// инициализация элементов массива лямбда-выражением
// int массив, размером 5 со значениями [0, 1, 2, 3, 4] (элементы инициализированы своим индексом)
var arr = IntArray(5) { it * 1 }
```

!!! example [Example](samples/02_Syntax/16_PrimitivesArrays/src/Main.kt)
```kotlin
import kotlin.math.pow

fun main() {
    val testArrayInt: IntArray = intArrayOf(1, 2, 3)
    testArrayInt[0] = testArrayInt[1] + testArrayInt[2]
    testArrayInt.forEach { print(it.toString() + "\t") }
    println()
    val testArrayInit = IntArray(5)
    testArrayInit.forEach { print(it.toString() + "\t ") }
    println()
    val testArrayConst = IntArray(5) { 79 }
    testArrayConst.forEach { print(it.toString() + "\t ") }
    println()
    var testArrayLambda = DoubleArray(9) { 2.0.pow(it) }
    testArrayLambda.forEach { print(it.toString() + "\t ") }
    println()
}
```

> Существуют специальные методы `arrayOf` для следующих типов: `double`, `float`, `long`, `int`, `char`, `short`, `byte`, `boolean`.

Мы можем легко инициализировать примитивный массив `int`, используя специальный метод `arrayOf`:

```kotlin
val integers = intArrayOf(1, 2, 3, 4)
```

!!! example [Example](samples/03_Arrays/02_PrimitivesArrays/src/Main.kt)
```kotlin
fun main() {
    val arrInt = intArrayOf(9, 6, 3, 6, 1)
    val arrDouble = doubleArrayOf(3.7, 3.4, 9.1)
    val arrLogic = booleanArrayOf(true, true, false)
    val arrFloatOne = floatArrayOf(2F, 5.78F, 78.91F, 105F)
    // val arrFloatTwo = floatArrayOf(2, 5.78, 78.91, 105) // => Kotlin: Argument type mismatch
    val arrChar = charArrayOf('E', 'G', 'k', 'p', 'Z')
    val arrLongOne = longArrayOf(78L, 62L, 100_456_891L)
    val arrLongTwo = longArrayOf(78, 62, 100_456_891)
    val arrByte = byteArrayOf(-23, 127, 17, -98)
    val arrShort = shortArrayOf(-32000, 4500, 491, -9837)
}
```

!!! error Error
```kotlin
val arrFloatTwo = floatArrayOf(2, 5.78, 78.91, 105)
```

<details>
<summary><em>Output</em></summary>

```
Kotlin: Argument type mismatch: actual type is 'kotlin/Int' but 'kotlin/Float' was expected
```

</details>

#### Двумерные массивы
https://developer.alexanderklimov.ru/android/kotlin/array.php

Часто одного массива недостаточно. В некоторых случаях удобно использовать двумерные массивы. Визуально их легко представить в виде сетки. Типичный пример — зал в кинотеатре. Чтобы найти нужно место в большом зале, нам нужно знать ряд и место.

<dfn title="двумерный массив">Двумерный массив</dfn> — это массив, который содержит другие массивы. Создадим двумерный массив 5х5 и заполним его нулями.

```kotlin
// Создаём двумерный массив
var cinema = arrayOf<Array<Int>>()

// заполняем нулями
for (i in 0..4) {
    var array = arrayOf<Int>()
    for (j in 0..4) {
        array += 0
    }
    cinema += array
}

// выводим данные массива
for (array in cinema) {
    for (value in array) {
        print("$value ")
    }
    println()
}
// Результат
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
```

Сейчас в кинотеатре пусто. Первый зритель берёт билет в центре зала.

```kotlin
// центр зала
cinema[2][2] = 1

// три места во втором ряду
for (i in 1..3) {
    cinema[3][i] = 1
}

// весь первый ряд
for (i in 0..4) {
    cinema[4][i] = 1
}

// выводим данные массива
for (array in cinema) {
    for (value in array) {
        print("$value ")
    }
    println()
}

// Результат
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 1 1 1 0
1 1 1 1 1
```

!!! example Example
```kotlin
fun main() {
    val arrOneDimens: Array<Int> = Array(10) { (0..255).random() }
    arrOneDimens.forEach { print(it.toString() + "\t") }
    println()

    val arrTwoDimens: Array<Array<Int>> = Array(10) {
        Array(10) {
            (0..255).random()
        }
    }

    for (i in 0..9) {
        for (j in 0..9) {
            print(arrTwoDimens[i][j].toString() + "\t\t")
        }
        println()
    }
}
```

<details>
<summary><em>Output</em></summary>

```
23	181	59	133	173	58	176	55	7	202
126		95		7		107		94		229		152		237		73		232
177		236		242		168		142		65		84		92		84		201
187		63		112		134		22		240		160		0		87		157
71		88		43		28		147		6		153		113		79		206
79		43		4		145		121		196		255		99		125		126
76		119		195		211		114		193		116		16		216		21
35		88		138		56		216		218		80		246		31		196
57		29		126		21		105		18		29		180		133		238
121		229		89		84		108		201		20		191		24		146
203		236		161		122		34		38		95		133		136		209
```

</details>

#### Многомерный массив с базовыми типами
https://developer.alexanderklimov.ru/android/kotlin/array.php

По такому же принципу строится трёхмерный массив. На этот раз его можно представить не в виде сетки, а в виде куба. В этом случае сетки идут как бы друг за другом, образуя слои.

```kotlin
var rubikCube = arrayOf<Array<Array<Int>>>()
for (i in 0..2) {
    var piece = arrayOf<Array<Int>>()
    for (j in 0..2) {
        var array = arrayOf<Int>()
        for (k in 0..2) {
            array += 0
        }
        piece += array
    }
    rubikCube += piece
}

// второй слой, третий ряд, первое место
rubikCube[1][2][0] = 1
println(Arrays.deepToString(rubikCube))

// Результат
0, 0, 0 | 0, 0, 0 | 0, 0, 0
0, 0, 0 | 0, 0, 0 | 0, 0, 0
0, 0, 0 | 1, 0, 0 | 0, 0, 0
```

Если нам приходится обрабатывать многомерный массив базовых типов Kotlin, мы можем полагаться на различные примитивные библиотечные функции и дополнительные классы. Фактически, Kotlin определяет дополнительные классы, как `IntArray`, `BooleanArray`, `LongArray` и т.д., а также библиотечные функции для создания экземпляров этих типов.

В качестве примера давайте посмотрим, как можно определить простой двумерный массив целых чисел, используя методы `arrayOf` и `intArrayOf`.

Используя `arrayOfNulls`, можно инициализировать массив нулевыми значениями. Таким образом, с помощью этого метода можно инициализировать каждую строку разным размером массива.

!!! example Example
```kotlin
fun main() {
    val arrOne: Array<IntArray> = arrayOf(
        intArrayOf(2, 7, 8, 1),
        intArrayOf(5, 2, 9, 3),
    )

    val arrTwo = arrayOfNulls<Array<Int>>(2)
    arrTwo[0] = Array(3) {0}
    arrTwo[1] = Array(2) {1}
}
```

#### Обход (перебор элементов) массивов
https://developer.alexanderklimov.ru/android/kotlin/array.php

Обычный перебор через **`for`**.

```kotlin
val arr = arrayOf(1, 2, 3, 4, 5)

for (i in arr) {
    println("Значение элемента равно $i")
}
```

Можно одной строкой через **`forEach`**.

```kotlin
arr.forEach { i -> println("Значение элемента равно $i") }
```

Если нужна информация не только о значении элемента, но и его индексе, то используем **`forEachIndexed`**.

```kotlin
arr.forEachIndexed { index, element ->
    println("$index : $element")
}

// Результат
0 : 1
1 : 2
2 : 3
3 : 4
4 : 5
```

`forEachIndexed` дает нам и индекс, и значение по этому индексу в массиве.

!!! example [Example](samples/03_Arrays/08_IterationOverArray/src/Main.kt)

```kotlin
fun main() {
    val arrOne = IntArray(10) { i -> i * 3 }

    arrOne.forEach { item -> print(item.toString() + "\t") }
    println()

    arrOne.forEachIndexed { index, item -> println("Элемент с индексом $index равен $item") }
}

```


<details>
<summary><em>Output</em></summary>

```
0	3	6	9	12	15	18	21	24	27
Элемент с индексом 0 равен 0
Элемент с индексом 1 равен 3
Элемент с индексом 2 равен 6
Элемент с индексом 3 равен 9
Элемент с индексом 4 равен 12
Элемент с индексом 5 равен 15
Элемент с индексом 6 равен 18
Элемент с индексом 7 равен 21
Элемент с индексом 8 равен 24
Элемент с индексом 9 равен 27
```

</details>

#### Итераторы
https://kotlinlang.ru/docs/iterators.html

Для обхода элементов коллекции стандартная библиотека Kotlin поддерживает механизм <dfn title="итератор">итераторов</dfn> — объектов, которые предоставляют доступ к элементам последовательно, не раскрывая базовую структуру коллекции. Итераторы полезны, когда вам нужно обработать все элементы коллекции один за другим, например, вывести в лог их значения или обновить.

##### Использование итератора (интерфейс)
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/

```kotlin
interface Iterator<out T>
(Common source) (Native source)
```

###### Functions
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/#functions

- `hasNext`

    Returns true if the iteration has more elements.

    ```kotlin
    abstract operator fun hasNext(): Boolean
    ```

- `next`

    Returns the next element in the iteration.
    ```kotlin
    abstract operator fun next(): T
    ```

###### Extension Functions
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/#extension-functions

- `asSequence`

    Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.
    ```kotlin
    fun <T> Iterator<T>.asSequence(): Sequence<T>
    ```

- `forEach`

    Performs the given operation on each element of this Iterator.
    ```kotlin
    fun <T> Iterator<T>.forEach(operation: (T) -> Unit)
    ```

- `iterator`

    Returns the given iterator itself. This allows to use an instance of iterator in a `for` loop.
    ```kotlin
    operator fun <T> Iterator<T>.iterator(): Iterator<T>
    ```

- `withIndex`

    Returns an Iterator that wraps each element produced by the original iterator into an IndexedValue containing the index of that element and the element itself.
    ```kotlin
    fun <T> Iterator<T>.withIndex(): Iterator<IndexedValue<T>>
    ```

Итераторы доступны всем наследникам интерфейса `Iterable<T>`, включая `Set` и `List`, путём вызова функции `iterator()`.

При получении итератора он сначала указывает на первый элемент коллекции; вызов функции `next()` возвращает этот элемент и перемещает позицию итератора на следующий элемент, если такой существует.

Как только итератор проходит через последний элемент, его больше нельзя использовать для извлечения элементов; его также нельзя вернуть в предыдущее положение. Чтобы снова перебрать коллекцию, нужно создать новый итератор.
```kotlin
fun main() {
    val numbers = listOf("one", "two", "three", "four")
    val numbersIterator = numbers.iterator()
    while (numbersIterator.hasNext()) {
        println(numbersIterator.next())
    }
}

// В логе будет:
// one
// two
// three
// four
```

Другой способ перебрать `Iterable` коллекцию — это всем известный цикл `for`. При использовании `for` вы неявно получаете итератор. Поэтому, приведённый ниже код эквивалентен предыдущему примеру:
```kotlin
fun main() {
    val numbers = listOf("one", "two", "three", "four")
    for (item in numbers) {
        println(item)
    }
}

// В логе будет:
// one
// two
// three
// four
```

!!! example [Example](samples/03_Arrays/07_ArrayIteration/src/Main.kt)

```kotlin
fun main() {
    val arrOne = IntArray(10) { i -> i * 3 }

    for (item in arrOne) {
        print(item.toString() + "\t")
    }
    println()

    var iter = arrOne.iterator()
    while (iter.hasNext()) {
        val item = iter.next()
        print(item.toString() + "\t")
    }
}

```


<details>
<summary><em>Output</em></summary>

```
0	3	6	9	12	15	18	21	24	27
0	3	6	9	12	15	18	21	24	27
```

</details>

Также, есть полезная функция `forEach()`, которая позволяет автоматически перебирать коллекцию и выполнять заданный код для каждого элемента. Перепишем пример выше:
```kotlin
fun main() {
    val numbers = listOf("one", "two", "three", "four")
    numbers.forEach {
        println(it)
    }
}

// В логе будет:
// one
// two
// three
// four
```

#### Операции с массивами

##### Переворачивание массива

###### Перевернуть массив: `reversedArray()`
Для операции создадим дополнительную переменную для нового массива с перевёрнутыми значениями. Оригинал останется без изменений.

```kotlin
val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
var reversedArray = numbers.reversedArray()

println(Arrays.toString(reversedArray))
```

###### Перевернуть массив: `reverse()`
Если оригинал массива нам точно не понадобится, то мы можем перевернуть его без создания нового массива.

```kotlin
val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9)
numbers.reverse()

println(Arrays.toString(numbers))
```

!!! example [Example](samples/03_Arrays/09_Reverse/src/Main.kt)

```kotlin
fun main() {
    val arrOne = IntArray(10) { i -> i * 3 }
    arrOne.forEach { i -> print(i.toString() + "\t") }
    println()
    arrOne.reverse()
    arrOne.forEach { i -> print(i.toString() + "\t") }
    println()
    arrOne.reversed()
    arrOne.forEach { i -> print(i.toString() + "\t") }
    println()
    val arrTwo = arrOne.reversed()
    arrTwo.forEach { i -> print(i.toString() + "\t") }
    println()
    arrOne.reverse(3, 6)
    arrOne.forEach { i -> print(i.toString() + "\t") }
    // arrTwo.reverse(3, 6) // => Kotlin: Unresolved reference: reverse
    // Reversed возвращает тип List, у которого отсутствует метод reverse, т.е.
    // val arrTwo: List<Int> = arrOne.reversed()
}

```


<details>
<summary><em>Output</em></summary>

```
0	3	6	9	12	15	18	21	24	27
27	24	21	18	15	12	9	6	3	0
27	24	21	18	15	12	9	6	3	0
0	3	6	9	12	15	18	21	24	27
27	24	21	12	15	18	9	6	3	0
```

</details>

Стоит обратить внимание на тип `arrTwo`. Метод `reversed` возвращает тип `List`, у которого отсутствует метод `reverse`, т.е. присвоение в примере ниже эквивалентно `val arrTwo: List<Int> = arrOne.reversed()`. Поэтому попытка обращения к несуществующему методу вызовет ошибку `Unresolved reference`.

!!! error Error

```kotlin
fun main() {
    val arrOne = IntArray(10) { i -> i * 3 }
    val arrTwo = arrOne.reversed()
    arrTwo.reverse(3, 6)
}

```

<details>
<summary><em>Output</em></summary>

```
Kotlin: Unresolved reference: reverse
```

</details>

##### Сортировка элементов массива
В Kotlin очень просто сортировать элементы.

Вызываем метод **`sort()`**. Мы меняем существующий массив, а не создаём новый.

```kotlin
val numbers: IntArray = intArrayOf(7, 5, 8, 4, 9, 6, 1, 3, 2)
numbers.sort()

// println(Arrays.toString(numbers)) // старый способ
println("Sorted array: ${numbers.contentToString()}")
```

Сортировать можно не весь массив, а только определённый диапазон. Указываем начало и размер диапазона. Допустим, нам нужно отсортировать только первые три элемента из предыдущего примера.

```kotlin
numbers.sort(0, 3)

// 5, 7, 8, 4, 9, 6, 1, 3, 2
```

Сортировка в обратном порядке от наибольшего значения к наименьшему.

```kotlin
numbers.sortDescending()
```

!!! example [Example](samples/03_Arrays/10_Sorting/src/Main.kt)

```kotlin
fun main() {
    var arrOne = intArrayOf(7, 9, 1, 15, 8, 1, 24, 5, 78)
    arrOne.sort()
    arrOne.forEach { print(it.toString() + "\t") }
    println()
    arrOne = intArrayOf(7, 9, 1, 15, 8, 1, 24, 5, 78)
    arrOne.sort(4)
    arrOne.forEach { print(it.toString() + "\t") }
    println()
    arrOne = intArrayOf(7, 9, 1, 15, 8, 1, 24, 5, 78)
    arrOne.sort(3, 6)
    arrOne.forEach { print(it.toString() + "\t") }
}

```

<details>
<summary><em>Output</em></summary>

```
1	1	5	7	8	9	15	24	78
7	9	1	15	1	5	8	24	78
7	9	1	1	8	15	24	5	78
```

</details>

Если нужно сохранить исходный массив, то вызываем другие функции, которые создадут новый массив.

```kotlin
val numbers: IntArray = intArrayOf(7, 5, 8, 4, 9, 6, 1, 3, 2)
val sortedNumbers: IntArray = numbers.sortedArray() // новый сортированный массив
val descendingSortedNumber: IntArray = numbers.sortedArrayDescending() // новый сортированный массив в обратном порядке

println("Original array ${numbers.contentToString()}:Sorted array ${sortedNumbers
        .contentToString()}")
// Original array [7, 5, 8, 4, 9, 6, 1, 3, 2]:Sorted array [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Для сортировки объектов указываем компаратор и условие сравнения. Например, мы хотим сравнить котов по их возрастам.

```kotlin
val cats = arrayOf(Cat("Барсик", 8), Cat("Мурзик", 4), Cat("Васька", 9))
// массив до сортировки
cats.forEach { println(it) }

// сортируем по возрасту
cats.sortWith(Comparator { c1: Cat, c2: Cat -> c1.age - c2.age })
cats.forEach { println(it) }


data class Cat(val name: String, val age: Int)
```

Вместо компаратора можно использовать функцию **`sortBy()`** с указанием условия. Сравним теперь котов не по возрасту, а по их именам.

```kotlin
val cats = arrayOf(Cat("Барсик", 8), Cat("Мурзик", 4), Cat("Васька", 9))
cats.forEach { println(it) }
cats.sortBy { cat -> cat.name }
cats.forEach { println(it) }


data class Cat(val name: String, val age: Int)
```

##### Перемешивание элементов массива: `shuffle()` (Kotlin 1.40)
Перемешать элементы массива в случайном порядке можно при помощи метода `shuffle()`.

```kotlin
val numbers = arrayOf(1, 2, 3, 4, 5)
numbers.shuffle()
println(numbers.contentToString())
```

!!! example [Example](samples/03_Arrays/11_Shuffle/src/Main.kt)

```kotlin
import kotlin.random.Random

fun main() {
    var arrOne = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
    arrOne.shuffle()
    arrOne.forEach { print(it.toString() + "\t") }
    println()
    arrOne = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
    arrOne.shuffle(Random(2))
    arrOne.forEach { print(it.toString() + "\t") }
    println()
    arrOne = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
    arrOne.shuffle(Random(2)) // => The same seed number gives the same sequence
    arrOne.forEach { print(it.toString() + "\t") }
    println()
    arrOne = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
    arrOne.shuffle(Random(5))
    arrOne.forEach { print(it.toString() + "\t") }
}

```

<details>
<summary><em>Output</em></summary>

```
1	6	13	10	8	3	4	7	14	9	11	2	5	15	12
4	15	7	6	11	2	9	3	1	10	14	12	13	8	5
4	15	7	6	11	2	9	3	1	10	14	12	13	8	5
4	2	10	11	14	13	3	6	8	15	5	7	9	1	12
```

</details>

##### Наличие элемента в массиве: `contains()`
Если элемент содержится в массиве, то метод **`contains()`** возвращает `true`.

```kotlin
val array = arrayOf(1, 2, 3, 4, 5)
val isContains = array.contains(9)
println(isContains) // false
```

##### Найти среднее значение чисел в массиве: `average()`
Используем функцию **`average()`**. Возвращается `Double`.

```kotlin
val array = arrayOf(1, 3, 5)
println(array.average()) // 3.0
```

##### Подсчитать сумму чисел в массиве: `sum()`

```kotlin
val array = arrayOf(1, 2, 3, 4, 5)
println(array.sum()) // 15
```

##### Найти наибольшее и наименьшее число в массиве
В цикле сравниваем каждое число с эталоном, которые вначале принимает значение первого элемента. Если следующее число массива больше эталона, то берём его значение. В итоге после перебора получим наибольшее число в массиве.

```kotlin
val numbers: IntArray = intArrayOf(4, 9, 3, 2, 6)
var largestElement = numbers[0]

for (number in numbers){
    if(largestElement < number)
        largestElement = number
}

println("Наибольшее число в массиве: $largestElement")
```

Но можно не писать свой код, а вызвать готовые функции **`min()`** и **`max()`**.

```kotlin
println(numbers.min())
println(numbers.max())
```

##### Функция `intersect()`: найти общие элементы двух массивов
Есть два массива с числами. Нужно сравнить их и найти у них общие числа. Поможет нам функция **`intersect()`**

```kotlin
val firstArray = arrayOf(1, 2, 3, 4, 5)
val secondArray = arrayOf(3, 5, 6, 7, 8)

val intersectedArray = firstArray.intersect(secondArray.toList()).toIntArray()
println(Arrays.toString(intersectedArray))

//[3, 5]
```

##### Выбрать случайную строку из массива
Имеется массив строк. Сначала вычисляем размер массива. Затем генерируем случайное число в диапазоне от 0 до (почти) 1, которое умножаем на количество элементов в массиве. После этого результат преобразуется в целое число вызовом `toInt()`. Получается выражение типа `0.811948208873101 * 5 = 4`. В Kotlin есть свой класс `Random`, поэтому случайное число можно получить другим способом.

```kotlin
val cats = arrayOf("Барсик", "Мурзик", "Васька", "Рыжик", "Персик")
val arraySize = cats.size

// Java-style
val rand = (Math.random() * arraySize).toInt()
val name = "${cats[rand]}}"
println(name)

// Kotlin-style
val rand = Random.nextInt(arraySize)
val name = "${cats[rand]}"
println(name)
```

По этому принципу можно создать игру "Камень, Ножницы, Бумага".

```kotlin
private fun getChoice(optionsParam: Array<String>) =
    optionsParam[Random.nextInt(optionsParam.size)]

val options = arrayOf("Камень", "Ножницы", "Бумага")
val choice = getChoice(options)
println(choice)
```

##### `onEach()`: Операция с каждым элементом массива по очереди (Kotlin 1.40)
В коллекциях мы можем пройтись по всем элементам и что-то с каждым сделать. Теперь такое возможно и с элементами массива. Пройдёмся по всем числам массива, удвоим каждое число и конвертируем в строку.

```kotlin
var str = ""
val numbers = arrayOf(1, 2, 3, 4, 5)
numbers.onEach {str += it * 2}
println(str)
```

##### Удалить дубликаты
Удалить дубликаты можно несколькими способами. Например, через **`toSet()`**

```kotlin
val myArray = arrayOf(1, 1, 2, 3, 4, 5, 5, 4, 3, 2)

println(myArray.toSet().joinToString())
```

Мы получим множество, которое не допускает дубликатов. Порядок элементов сохраняется. Обратно в массив можно преобразовать через `toIntArray()` или схожие функции.

Аналогично можно использовать **`toHashSet()`**, получив `HashSet`, который тоже не допускает дубликатов, но не гарантирует очерёдность элементов.

Другой вариант — **`toMutableSet()`**. Порядок сохранится.

Самый простой вариант — вызвать функцию **`distinct()`**, который вернёт новый массив без дубликатов.

```kotlin
val myArray = arrayOf(1, 1, 2, 3, 4, 5, 5, 4, 3, 2)
println(myArray.joinToString())

val newArray = myArray.distinct()
println(newArray.joinToString())
```

### Коллекции
https://kotlinlang.ru/docs/collections-overview.html

Стандартная библиотека Kotlin предоставляет большой набор инструментов для работы с <dfn title="коллекция">коллекциями</dfn> — группами с переменным количеством элементов (или нулём элементов), которые используются для решения какой-либо задачи.

Коллекции — это общая концепция для большинства языков программирования, поэтому если вы знакомы с коллекциями, например, в Java или Python, то можете пропустить данное введение и перейти к разделам с более подробным описанием.

Обычно в коллекции находится несколько объектов одного типа (но также коллекция может быть пустой). Эти объекты называются <dfn title="элемент коллекции">элементами</dfn> или <dfn title="item collection">items</dfn>. Например, все студенты одного факультета образуют коллекцию, которую можно использовать для расчёта их среднего возраста.

#### Виды коллекций в Kotlin
* <dfn title="List">List</dfn> (<dfn title="список">список</dfn>) — упорядоченная коллекция, в которой к элементам можно обращаться по индексам — целым числам, отражающим положение элементов в коллекции. Идентичные элементы (дубликаты) могут встречаться в списке более одного раза. Примером списка является предложение: это группа слов, их порядок важен, и они могут повторяться.
* <dfn title="Set">Set</dfn> (<dfn title="множество">множество</dfn>) - коллекция уникальных элементов. Отражает математическую абстракцию множества: группа объектов без повторов. Как правило, порядок расположения элементов здесь не имеет значения. Примером множества является алфавит.
* <dfn title="Map">Map</dfn> (<dfn title="словарь">словарь</dfn>, <dfn title="ассоциативный список">ассоциативный список</dfn>) — набор из пар “ключ-значение”. Ключи уникальны и каждый из них соответствует ровно одному значению. Значения могут иметь дубликаты. Ассоциативные списки полезны для хранения логических связей между объектами, например, ID сотрудников и их должностей.

Kotlin позволяет управлять коллекциями независимо от того, какой именно тип объектов в них хранится: будь то `String`, `Int` или какой-то собственный класс, общие принципы работы с коллекцией всегда неизменны. Стандартная библиотека Kotlin предоставляет общие интерфейсы, классы и функции для создания, заполнения и управления коллекциями любого типа.

Интерфейсы коллекций и связанные с ними функции находятся в пакете `kotlin.collections`. Давайте рассмотрим его содержимое.

#### Использование коллекций
- `List` — **когда важен порядок**

    `List` хранит и отслеживает позицию элементов. Она знает, в какой позиции списка находится тот или иной элемент, и несколько элементов могут содержать ссылки на один объект.

- `Set` — **когда важна уникальность**

    `Set` не разрешает дубликаты и не отслеживает порядок, в котором хранятся значения. Коллекция не может содержать несколько элементов, ссылающихся на один и тот же объект, или несколько элементов, ссылающихся на два объекта, которые считаются равными.

- `Map` — **когда важен поиск по ключу**

    `Map` использует пары «ключ-значение». Этот тип коллекции знает, какое значение связано с заданным ключом. Два ключа могут ссылаться на один объект, но дубликаты ключей невозможны. Хотя ключи обычно представляют собой строковые имена (например, для составления списков свойств в формате «имя-значение»), ключом также может быть произвольный объект.

#### Типы коллекций
Стандартная библиотека Kotlin предоставляет реализации для основных типов коллекций: `Set`, `List`, `Map`. Есть два вида интерфейсов, предоставляющих каждый из этих типов:
* *неизменяемый* (*read-only*) — предоставляет операции, которые дают доступ к элементам коллекции.
* *изменяемый* (*mutable*) — расширяет предыдущий интерфейс и дополнительно даёт доступ к операциям добавления, удаления и обновления элементов коллекции.

Обратите внимание, что изменяемую коллекцию не требуется объявлять с помощью ключевого слова `var`. Связано это с тем, что изменения вносятся в изначальные объекты коллекции без изменения ссылки на саму коллекцию. Но если вы объявите коллекцию с помощью `val` и попытаетесь ее перезаписать, то получите ошибку компиляции.
```kotlin
fun main() {
    val numbers = mutableListOf("one", "two", "three", "four")
    numbers.add("five") // this is OK
    //numbers = mutableListOf("six", "seven") // compilation error
}
```

Неизменяемые типы коллекций [ковариантны](https://kotlinlang.ru/docs/generics.html). Это означает, что если класс `Rectangle` наследуется от `Shape`, вы можете использовать `List<Rectangle>` там, где требуется `List<Shape>`. Другими словами, типы коллекций имеют такое же отношение подтипов, что и типы элементов. `Map`-ы ковариантны по типу значения, но не по типу ключа.

В свою очередь, изменяемые коллекции не являются ковариантными; в противном случае это привело бы к сбоям во время выполнения. Если `MutableList<Rectangle>` был подтипом `MutableList<Shape>`, вы могли добавить в него других наследников `Shape` (например, `Circle`), таким образом нарушая изначальный тип коллекции — `Rectangle`.

!!! info [Ковариантность и контравариантность](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B8_%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))

    **Ковариа́нтность** и **контравариа́нтность** в программировании — способы переноса наследования типов на производные от них типы — контейнеры, обобщённые типы, делегаты и т. п. Термины произошли от аналогичных понятий теории категорий «ковариантный» и «контравариантный функтор».

    <dfn title="ковариантность">Ковариантностью</dfn> называется сохранение иерархии наследования исходных типов в производных типах в том же порядке. Так, если класс `Cat` наследуется от класса `Animal`, то естественно полагать, что перечисление `IEnumerable<Cat>` будет потомком перечисления `IEnumerable<Animal>`. Действительно, «список из пяти кошек» — это частный случай «списка из пяти животных». В таком случае говорят, что тип (в данном случае обобщённый интерфейс) `IEnumerable<T>` *ковариантен* своему параметру-типу `T`.

    <dfn title="контравариантность">Контравариантностью</dfn> называется обращение иерархии исходных типов на противоположную в производных типах. Так, если класс `String` наследуется от класса `Object`, а делегат `Action<T>` определён как метод, принимающий объект типа `T`, то `Action<Object>` наследуется от делегата `Action<String>`, а не наоборот. Действительно, если «все строки — объекты», то «всякий метод, оперирующий произвольными объектами, может выполнить операцию над строкой», но не наоборот. В таком случае говорят, что тип (в данном случае обобщённый делегат) `Action<T>` контравариантен своему параметру-типу `T`.

    Отсутствие наследования между производными типами называется <dfn title="инвариантность">инвариантностью</dfn>.

    Контравариантность позволяет корректно устанавливать тип при *создании подтипов* (subtyping), то есть, установить множество функций, позволяющее заменить другое множество функций в любом контексте. В свою очередь, ковариантность характеризует *специализацию кода*, то есть замену старого кода новым в определённых случаях. Таким образом, ковариантность и контравариантность являются независимыми механизмами типобезопасности, не исключающими друг друга, и могут и должны применяться в объектно-ориентированных языках программирования.


Ниже представлена ​​схема интерфейсов коллекций Kotlin:

![](./img/collections-diagram.png)

#### `Collection`
`Collection<T>` является корнем в иерархии коллекций. Этот интерфейс представляет собой обычное поведение неизменяемой коллекции: операции типа `size`, `get` и т. д. Collection наследуется от интерфейса `Iterable<T>`, который определяет операции для итерации элементов. Вы можете использовать `Collection` как параметр функции, которая может работать с разными типами коллекций. Для более конкретных случаев следует использовать наследников `Collection`: `List` и `Set`.
```kotlin
fun printAll(strings: Collection<String>) {
        for(s in strings) print("$s ")
        println()
    }

fun main() {
    val stringList = listOf("one", "two", "one")
    printAll(stringList) // one two one

    val stringSet = setOf("one", "two", "three")
    printAll(stringSet) // one two three
}
```

`MutableCollection<T>` — это `Collection` с операциями записи, такими как `add` и `remove`.

```kotlin
fun List<String>.getShortWordsTo(shortWords: MutableList<String>, maxLength: Int) {
    this.filterTo(shortWords) { it.length <= maxLength }
    // throwing away the articles
    val articles = setOf("a", "A", "an", "An", "the", "The")
    shortWords -= articles
}

fun main() {
    val words = "A long time ago in a galaxy far far away".split(" ")
    val shortWords = mutableListOf<String>()
    words.getShortWordsTo(shortWords, 3)
    println(shortWords) // [ago, in, far, far]
}
```

#### `List`
`List<T>` хранит элементы в определённом порядке и обеспечивает к ним доступ по индексу. Индексы начинаются с нуля (0 — индекс первого элемента) и идут до `lastIndex`, который равен (`list.size - 1`).
```kotlin
fun main() {
    val numbers = listOf("one", "two", "three", "four")
    println("Number of elements: ${numbers.size}") // 4
    println("Third element: ${numbers.get(2)}") // three
    println("Fourth element: ${numbers[3]}") // four
    println("Index of element \"two\" ${numbers.indexOf("two")}") // 1
}
```

!!! example [Объявление коллекции `List`](samples/03_Arrays/12_List/src/Main.kt)

```kotlin
fun main() {
    val testListStr = listOf("один", "два", "три", 97)
    val testListNum = listOf(3, 7, 9)
    val testListSum: List<Int>

    testListSum = testListNum + listOf(6, 8, 2)

    println(testListStr)
    println(testListNum)
    println(testListSum)
}
```

<details>
<summary><em>Output</em></summary>

```
[один, два, три, 97]
[3, 7, 9]
[3, 7, 9, 6, 8, 2]
```

</details>

В неизменяемых коллекциях нельзя менять количество элементов и изменять значение элементов. Это сделано с целью защиты данных.

!!! error Попытка измененить значение

```kotlin
fun main() {
    val testListStr = listOf("один", "два", "три", 97)
    val testListNum = listOf(3, 7, 9)
    val testListSum: List<Int>

    testListSum = testListNum + listOf(6, 8, 2)

    println(testListStr[2])
    testListNum[2] = 78 // => Error: No set method providing array access
}

```

<details>
<summary><em>Output</em></summary>

```
Kotlin: No set method providing array access
```

</details>

Нельзя к массиву с элементами одного типа прибавлять массив с элементами другого типа.

!!! error `List` с разными типами

```kotlin
fun main() {
    val testListStr = listOf("один", "два", "три", 97)
    val testListNum = listOf(3, 7, 9)
    val testListSum: List<Int>

    testListSum = testListNum + listOf(6.0, 8, 2) // => Error: Assignment type mismatch
}

```

<details>
<summary><em>Output</em></summary>

    Kotlin: Assignment type mismatch: actual type is 'kotlin/collections/List<it(kotlin/Number & kotlin/Comparable<*>)>' but 'kotlin/collections/List<kotlin/Int>' was expected


</details>

Элементы списка (в том числе `null`) могут дублироваться: список может содержать любое количество одинаковых объектов. Два списка считаются равными, если они имеют одинаковый размер и их элементы в одних и тех позициях [структурно равны](https://kotlinlang.ru/docs/equality.html).
```kotlin
data class Person(var name: String, var age: Int)

fun main() {
    val bob = Person("Bob", 31)
    val people = listOf(Person("Adam", 20), bob, bob)
    val people2 = listOf(Person("Adam", 20), Person("Bob", 31), bob)
    println(people == people2) // true
    bob.age = 32
    println(people == people2) // false
}
```

`MutableList<T>` — это `List` с операциями записи, специфичными для списка, например, для добавления или удаления элемента в определённой позиции.
```kotlin
fun main() {
    val numbers = mutableListOf(1, 2, 3, 4)
    numbers.add(5)
    numbers.removeAt(1)
    numbers[0] = 0
    numbers.shuffle()
    println(numbers) // [4, 0, 3, 5]
}
```

!!! example [Работа с `MutableList`](samples/03_Arrays/13_MutableList/src/Main.kt)

```kotlin
fun main() {
    val testListNum = mutableListOf(3, 9, 7, 9)
    println(testListNum)

    testListNum.add(798) // Добавили элемент в конец List
    println(testListNum)

    testListNum.add(0, 641) // Добавили элемент на место с индексом
    testListNum.forEach { println(it.toString() + "\t") }
    println(testListNum)

    testListNum.removeAt(0) // Удалили элемент по индексу
    testListNum.remove(9) // Удалили первое вхождение элемента со значением
    println(testListNum)
}

```

<details>
<summary><em>Output</em></summary>

```
[3, 9, 7, 9]
[3, 9, 7, 9, 798]
641
3
9
7
9
798
[641, 3, 9, 7, 9, 798]
[3, 7, 9, 798]
```

</details>

Как видите, в некоторых аспектах списки очень похожи на массивы. Однако есть одно важное отличие: размер массива определяется при инициализации и никогда не изменяется; в свою очередь список не имеет предопределённого размера; размер списка может быть изменён в результате операций записи: добавления, обновления или удаления элементов.

По умолчанию в Kotlin реализацией `List` является `ArrayList`, который можно рассматривать как массив с изменяемым размером.

!!! example [`mutableListOf` и `ArrayList`](samples/03_Arrays/14_ArrayList/src/Main.kt)

```kotlin
fun main() {
    val testListNum = mutableListOf<Int>() // Вызываем метод
    testListNum.add(97)
    testListNum.add(85)
    testListNum.add(17)
    println(testListNum)

    val testArrList = ArrayList<String>() // Вызываем конструктор класса
    testArrList.add("один")
    testArrList.add("два")
    testArrList.add("три")
    println(testArrList)
}

```

<details>
<summary><em>Output</em></summary>

```
[97, 85, 17]
[один, два, три]
```

</details>

Как видно из примера выше, в обоих случаях получаем `ArrayList`, который можно использовать для получения динамических массивов.

#### `Set`
`Set<T>` хранит уникальные элементы; их порядок обычно не определён. `null` также является уникальным элементом: `Set` может содержать только один `null`. Два множества равны, если они имеют одинаковый размер и для каждого элемента множества есть равный элемент в другом множестве.
```kotlin
fun main() {
    val numbers = setOf(1, 2, 3, 4)
    println("Number of elements: ${numbers.size}") // Number of elements: 4
    if (numbers.contains(1)) println("1 is in the set")

    val numbersBackwards = setOf(4, 3, 2, 1)
    println("The sets are equal: ${numbers == numbersBackwards}") // true
}
```

!!! example [Неизменяемый `Set`](samples/03_Arrays/15_Set/src/Main.kt)

```kotlin
fun main() {
    val testSetNum = setOf(1, 4, 8, 5, 4)
    println(testSetNum)
    val testSetTwo: Set<Int>
    testSetTwo = setOf(2, 4, 9, 3, 5)
    for (item in testSetNum) {
        print(testSetTwo.contains(item).toString() + "\t")
    }
    println()

    println(testSetNum.intersect(testSetTwo))       // пересечение наборов
    val testNewSet = testSetNum.union(testSetTwo)   // объединение
    println(testNewSet)
    val testPlusSet = testSetNum.plus(789)
    println(testPlusSet)
}

```

<details>
<summary><em>Output</em></summary>

```
[1, 4, 8, 5]
false	true	false	true
[4, 5]
[1, 4, 8, 5, 2, 9, 3]
[1, 4, 8, 5, 789]
```

</details>

`MutableSet` — это `Set` с операциями записи из `MutableCollection`.

!!! example [Изменяемый `Set`](samples/03_Arrays/16_MutableSet/src/Main.kt)

```kotlin
fun main() {
    val testSetNum = mutableSetOf(1, 9, 6, 4, 7)
    val testSetTwo: MutableSet<Int> = mutableSetOf()
    for (i in 9..16) {
        testSetTwo.add(i * (105..145).random())
    }
    println(testSetNum)
    println(testSetTwo)
    testSetNum.remove(1)
    println(testSetNum)
    println(testSetNum.dropWhile { it > 6 })
}

```

<details>
<summary><em>Output</em></summary>

```
[1, 9, 6, 4, 7]
[1080, 1130, 1408, 1332, 1482, 1638, 1935, 2064]
[9, 6, 4, 7]
[6, 4, 7]
```

</details>

По умолчанию реализацией `Set` является `LinkedHashSet`, который сохраняет порядок вставки элементов. Следовательно, функции, которые зависят от порядка элементов, такие как `first()` или `last()`, возвращают предсказуемые результаты для таких множеств.
```kotlin
fun main() {
    val numbers = setOf(1, 2, 3, 4)  // по умолчанию LinkedHashSet
    val numbersBackwards = setOf(4, 3, 2, 1)

    println(numbers.first() == numbersBackwards.first()) // false
    println(numbers.first() == numbersBackwards.last()) // true
}
```

Альтернативная реализация — `HashSet` — не сохраняет порядок элементов, поэтому при вызове функций `first()` или `last()` вернётся непредсказуемый результат. Однако `HashSet` требует меньше памяти для хранения того же количества элементов.

Можно преобразовывать изменяемые коллекции в неизменяемые и наоборот:

!!! example [Конверсия](samples/03_Arrays/17_Conversion/src/Main.kt)

```kotlin
fun main() {
    val testSetNum = mutableSetOf(1, 9, 6, 4, 7)
    println(testSetNum)
    testSetNum.add(47)
    println(testSetNum)
    val testNoMutableSet = testSetNum.toSet() // Можно преобразовывать изменяемые коллекции в неизменяемые и наоборот
    testSetNum.add(59)
    println(testNoMutableSet)
    // testNoMutableSet.add(39) // Нельзя добавить элемент, так как мы вернули неизменяемую коллекцию
    println(testSetNum)
}

```

<details>
<summary><em>Output</em></summary>

```
[1, 9, 6, 4, 7]
[1, 9, 6, 4, 7, 47]
[1, 9, 6, 4, 7, 47]
[1, 9, 6, 4, 7, 47, 59]
```

</details>

#### `Map`
`Map<K, V>` не является наследником интерфейса `Collection`; однако это один из типов коллекций в Kotlin. `Map` хранит пары “ключ-значение” (или *entries*); ключи уникальны, но разные ключи могут иметь одинаковые значения. Интерфейс `Map` предоставляет такие функции, как доступ к значению по ключу, поиск ключей и значений и т. д.
```kotlin
fun main() {
    val numbersMap = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key4" to 1)

    println("All keys: ${numbersMap.keys}") // [key1, key2, key3, key4]
    println("All values: ${numbersMap.values}") // [1, 2, 3, 1]
    if ("key2" in numbersMap) println("Value by key \"key2\": ${numbersMap["key2"]}")
    if (1 in numbersMap.values) println("The value 1 is in the map")
    if (numbersMap.containsValue(1)) println("The value 1 is in the map") // аналогичен предыдущему условию
}
```

Две `Map`-ы, содержащие равные пары, равны независимо от порядка пар.
```kotlin
fun main() {
    val numbersMap = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key4" to 1)
    val anotherMap = mapOf("key2" to 2, "key1" to 1, "key4" to 1, "key3" to 3)

    println("The maps are equal: ${numbersMap == anotherMap}") // The maps are equal: true
}
```

!!! example [Словари `Map`](samples/03_Arrays/18_Map/src/Main.kt)

```kotlin
fun main() {
    val num = mapOf(1 to "one", 2 to "two", 3 to "three", 4 to "three")
    val k = num.keys
    val v = num.values
    val e = num.entries

    println(k)
    println(v)
    println(e)

    for ((i, j) in e)
        println("The $i is $j!")
}

```

<details>
<summary><em>Output</em></summary>

```
[1, 2, 3, 4]
[one, two, three, three]
[1=one, 2=two, 3=three, 4=three]
The 1 is one!
The 2 is two!
The 3 is three!
The 4 is three!
```

</details>

`MutableMap` — это `Map` с операциями записи, например, можно добавить новую пару “ключ-значение” или обновить значение, связанное с указанным ключом.
```kotlin
fun main() {
    val numbersMap = mutableMapOf("one" to 1, "two" to 2)
    numbersMap.put("three", 3)
    numbersMap["one"] = 11

    println(numbersMap) // {one=11, two=2, three=3}
}
```

По умолчанию реализацией `Map` является `LinkedHashMap` — сохраняет порядок элементов. Альтернативная реализация — `HashMap` — не сохраняет порядок элементов.

!!! example [Изменяемый `Map`](samples/03_Arrays/19_MutableMap/src/Main.kt)

```kotlin
fun main() {
    val num = mutableMapOf(1 to "один", 2 to "два", 3 to "три", 4 to "три")
    num.remove(3)
    println(num)
    num[1] = "восемь"
    num[55] = "пятьдесят пять"
    println(num)
    num.putAll(setOf(6 to "шесть", 9 to "девять"))
    num.putAll(mapOf(16 to "десять и шесть", 29 to "двадцать и девять"))
    println(num)
}

```

<details>
<summary><em>Output</em></summary>

```
{1=один, 2=два, 4=три}
{1=восемь, 2=два, 4=три, 55=пятьдесят пять}
{1=восемь, 2=два, 4=три, 55=пятьдесят пять, 6=шесть, 9=девять, 16=десять и шесть, 29=двадцать и девять}
```

</details>

### Массивы, коллекции — задачи
[6702850f5040133e8429e340](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345144)

**Задача 1, 3 и 5 ОБЯЗАТЕЛЬНЫ к решению.**

Решить задачи на обработку массивов и коллекций. Программы выполняются в консоли. Осуществить обработку ошибок, которые пользователь может сделать при вводе данных. Выполненное задание представить в виде ссылки на GitHub

#### Задача 1.

Создать программу, выполняющую следующий функционал:
- запрашивается количество строк и столбцов для двумерного массива
- вводится необходимое количество трехзначных чисел (числа могут повторяться)
- подсчитывается количество различных цифр в полученном массиве
- на консоль выводится двумерный массив из введенных чисел и количество различных цифр используемых в данном массиве

Например, для массива

<table>
<tr><td>100</td><td>951</td><td>101</td><td>950</td></tr>
<tr><td>519</td><td>999</td><td>155</td><td>501</td></tr>
<tr><td>510</td><td>911</td><td>144</td><td>554</td></tr>
</table>

выведется результат:
```
В массиве использовано 5 различных цифр
```

[Решение](src/03_ArraysCollections/Task_01/src/Main.kt)

#### Задача 2.

Имеется массив целых чисел из 5-и строк и 5-и столбцов. Выяснить, симметричен ли он относительно главной диагонали. То есть — элемент 1,2 равен элементу 2,1. Элемент 1,3 равен элементу 3,1 и т.д. Например массив

<table>
<tr><td>5</td><td>9</td><td>6</td><td>7</td><td>2</td></tr>
<tr><td>9</td><td>8</td><td>4</td><td>5</td><td>3</td></tr>
<tr><td>6</td><td>4</td><td>3</td><td>8</td><td>7</td></tr>
<tr><td>7</td><td>5</td><td>8</td><td>4</td><td>8</td></tr>
<tr><td>2</td><td>3</td><td>7</td><td>8</td><td>1</td></tr>
</table>

является симметричным относительно главной диагонали

[Решение](src/03_ArraysCollections/Task_02/src/Main.kt)

#### Задача 3.

Имеется массив из символов русского алфавита (все 33 символа, могут быть не по порядку). Символы алфавита нумеруются от 1 до 33. Каждое число используется только один раз.  Сообщение шифруется с помощью ключевого слова, задаваемого пользователем. Номер символа ключевого слова показывает, на сколько нужно сдвинуться по массиву из символов русского алфавита. Составить программу шифровки строкового выражения. Первый массив считать закольцованным. Регистр букв не имеет значения. Например:

| А  | Б  | В | Г  | Д  | Е | Ё  | Ж  | З  | И  | Й | К  | Л | М  | Н | О  | П | Р  | С  | Т  | У  | Ф | Х  | Ц  | Ч | Ш  | Щ  | Ь  | Ы  | Ъ  | Э  | Ю | Я  |
| -- | -- | - | -- | -- | - | -- | -- | -- | -- | - | -- | - | -- | - | -- | - | -- | -- | -- | -- | - | -- | -- | - | -- | -- | -- | -- | -- | -- | - | -- |
| 21 | 13 | 4 | 20 | 22 | 1 | 25 | 12 | 24 | 14 | 2 | 28 | 9 | 23 | 3 | 29 | 6 | 16 | 15 | 11 | 26 | 5 | 30 | 27 | 8 | 18 | 10 | 33 | 31 | 32 | 19 | 7 | 17 |

- Ключевое слово - `ПОЛЕ`
- Исходный текст - `СООБЩЕНИЕ`
- Зашифрованный текст - `АЁФИРХЖСЮ`

[Решение](src/03_ArraysCollections/Task_03/src/Main.kt)

#### Задача 4.

Создать приложение, в котором пользователь дает на вход два числовых массива, числа в массиве могут повторяться. На выходе приложение выдает пересечение этих массивов. Например, на входе [1, 2, 3, 2, 0] и [5, 1, 2, 7, 3, 2, 2]. На выходе должны получить [1, 2, 2, 3]. То есть учитывается количество повторений чисел в массиве. Число 2 в одном массиве повторялось два раза, в другом - три. Значит в итоговом массиве число два должно быть два раза

[Решение](src/03_ArraysCollections/Task_04/src/Main.kt)

#### Задача 5.

Создать приложение, в котором пользователь вводит массив из различных слов. На выходе приложение должно показать слова сгруппированные по признаку "состоят из одинаковых букв". Например, на входе ["eat", "tea", "tan", "ate", "nat", "bat"].

Получаем группы:
- "ate", "eat", "tea"
- "nat", "tan"
- "bat"

[Решение](src/03_ArraysCollections/Task_05/src/Main.kt)

## 04 Функции
[67117e5d5040133e8429e4e5](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-4)

### Функции
[6755716c5040133e8429e7cb](https://e-learn.petrocollege.ru/mod/url/view.php?id=345145)

<dfn title="функция">Функция</dfn> — это группа взаимосвязанных блоков кода, которая выполняет определенную задачу. Функция используется для разбиения программы на разные вспомогательные модули. Это упрощает повторное использование кода и делает программу более управляемой.

[Source](samples/04_Functions/01_NoFun/src/Main.kt)

![Function refactoring](./img/fun-refactor-1.png "refactor")

[Source](samples/04_Functions/02_Fun/src/Main.kt)

![Function refactoring](./img/fun-refactor-2.png "refactor")

![Function refactoring](./img/fun-refactor-3.png "refactor")

![Function refactoring](./img/fun-refactor-4.png "refactor")

![Function refactoring](./img/fun-refactor-5.png "refactor")

![Function refactoring](./img/fun-refactor-7.png "refactor")

В Kotlin функциями называют не только обычные функции, определенные за пределами класса, но и те, что находятся внутри класса, и которые в других языках принято называть методами. В Kotlin функции, определенные внутри классов, называют функциями-членами. Кроме них есть функции-расширения, которые как и функции-члены относятся к классам, но определены за их пределами как и обычные функции. Вместе функции-члены и функции-расширения можно считать методами класса.

Обычные функции и функции-расширения определяются за пределами класса. Их отличие заключается в наличии имени класса в нотации через точку перед именем функции-расширения.

Все функции по умолчанию, то есть без модификатора видимости, являются `public`. Их можно использовать отовсюду. Если функция верхнего уровня (не находится внутри класса) объявлена с модификатором private, ее можно использоватьтолько в данном файле.

![Function declaration](./img/fun-declaration-1.png "declaration")

![Function declaration](./img/fun-declaration-2.png "declaration")

По умолчанию функция получает глобальную видимость (public) — это означает, что все остальные функции (даже функции, объявленные в других файлах проекта) могут использовать эту функцию. Другими словами, если вы не указали модификатор, будет считаться, что используется модификатор "public".

Параметры определяют имена и типы входных данных, необходимых функции для решения задачи. Функции могут требовать от нуля до нескольких и более параметров. Их количество зависит от того, для какой задачи они были спроектированы.

Обратите внимание, что параметры функции всегда доступны только для чтения, то есть в теле функции они не могут менять свои значения. Другими словами, в теле функции параметры — это `val`, а не `var`.

Ключевое слово `return` указывает компилятору, что функция завершила работу и готова передать выходные данные.

Для вызова функции нужно указать ее имя и данные, соответствующие параметрам, как определено в заголовке.

Функции можно определять в файле вне других функций или классов, сами по себе, как например, определяется функция `main`. Такие функции еще называют функциями верхнего уровня (top-level functions).

В Kotlin функции объявляются с помощью ключевого слова `fun`.

Существует два типафункций в зависимости от того, доступнали она в стандартной библиотеке илиопределена пользователем.

- Стандартная библиотечная функция
- Определяемая пользователем функция

!!! example [Использование стандартных библиотечных функций](samples/04_Functions/03_FunTypes/src/Main.kt)

*Пример использования стандартных библиотечных функций `sqrt()` и `log()`.*

```kotlin
import kotlin.math.log
import kotlin.math.sqrt

fun main() {
    val number = 81
    println(sqrt(number.toFloat()))

    val base = 10
    println(log(1000F, base.toFloat()))
}
```

<details>
<summary><em>Output</em></summary>

```
9.0
3.0
```

</details>

**Определяемая пользователем функция** — это функция, которая создается пользователем. Определяемая пользователем функция принимает параметры, выполняет действие и возвращает результат этого действия в виде значения.

Функции Kotlin объявляются с использованием ключевого слова `fun`. Например:

!!! example [Example](samples/04_Functions/04_UserFun/src/Main.kt)

```kotlin
fun main() {
    println(prediction("Афанасий", 45))
}

private fun prediction(name: String, age: Int): String {
    return if (name.count() > 7 && age % 5 == 0) {
        "Все будет ОЧЕНЬ хорошо"
    } else {
        "Все будет отлично"
    }
}

```

<details>
<summary><em>Output</em></summary>

```
Все будет ОЧЕНЬ хорошо
```

</details>

Функции также принимают параметры в качестве аргументов и возвращают значение. Функции Kotlin определяются с использованием нотации Pascal, т.е. `имя:тип` (имя параметра и его тип). Параметры в функции разделяются запятыми.

Если функция не возвращает никакого значения, то ее возвращаемый тип равен `Unit`. Необязательно указывать возвращаемый тип определения функции, который не возвращает никакого значения.

![Function params](./img/fun_01.png "Function params")

#### Функции – обязательные и необязательные параметры (значения по умолчанию)
Мы можем определить какие-то параметры функции как необязательные и установить для них значения по умолчанию.

Необязательные параметры обязательно идут в конце списка параметров.

!!! example [Example](samples/04_Functions/05_OptionalParams/src/Main.kt)

```kotlin
fun main() {
    println(sumThree(15, 25, 44))
    println(sumThree(16, 18))
}

fun sumThree(koefA: Int, koefB: Int, koefC: Int = 5): String {
    return "$koefA + $koefB + $koefC = ${koefA + koefB + koefC}"
}

```

<details>
<summary><em>Output</em></summary>

```
15 + 25 + 44 = 84
16 + 18 + 5 = 39
```

</details>

#### Функции – именованные параметры
Используя именованные аргументы, мы можем переопределить порядок их передачи параметрам.

Часть аргументов могут передаваться параметрам по позиции. Но если какой-то аргумент передан по имени, то остальные аргументы после него также должны передаваться по имени соответствующих параметров.

Если до обязательного параметра функции идут необязательные параметры, то для обязательного параметра значение передается по имени.

!!! example [Example](samples/04_Functions/06_NamedParams/src/Main.kt)

```kotlin
fun main() {
    println(sumThree(koefC = 15, koefA = 25, koefB = 44))
    println(sumThree(16, koefB = 18))
    println(sumThree(16, koefC = 18, koefB = 75))
    println(myIncrease(koefB = 73, koefC = 64))
}

fun sumThree(koefA: Int, koefB: Int, koefC: Int = 5): String {
    return "$koefA + $koefB + $koefC = ${koefA + koefB + koefC}"
}

fun myIncrease(koefA: Int = 42, koefB: Int, koefC: Int): String {
    return "$koefA + $koefB + $koefC = ${koefA + koefB + koefC}"
}

```

<details>
<summary><em>Output</em></summary>

```
25 + 44 + 15 = 84
16 + 18 + 5 = 39
16 + 75 + 18 = 109
42 + 73 + 64 = 179
```

</details>

#### Функции – изменение параметров
По умолчанию все параметры функции равносильны `val`-переменным, поэтому их значение нельзя изменить.

Однако если параметр представляет какой-то сложный объект, то можно изменять отдельные значения в этом объекте.

Изменение элемента массива внутри функции приведет к тому, что также будет изменено значение элемента в том массиве, который передается в качестве аргумента в функцию, так как этот один и тот же массив.

!!! example [Example](samples/04_Functions/07_MutableParams/src/Main.kt)

```kotlin
fun main() {
    val testArr = intArrayOf(9, 7, 6)
    doubleArray(testArr)
    println()
    testArr.forEach { print(it.toString() + "\t") }
}

fun doubleArray(numArr: IntArray) {
    for (i in 0..numArr.size - 1) {
        numArr[i] = numArr[i] * 2
    }
    print("Печать из функции\t")
    numArr.forEach { print(it.toString() + "\t") }
}

```

<details>
<summary><em>Output</em></summary>

```
Печать из функции	18	14	12
18	14	12
```

</details>

#### Функции – переменное число параметров
Функция может принимать переменное количество параметров одного типа. Для определения таких параметров применяется ключевое слово `vararg`.

В самой функции мы можем работать с параметром как с последовательностью.

Только один параметр может быть помечен как `vararg`.

!!! example [Example](samples/04_Functions/08_Vararg/src/Main.kt)

```kotlin
fun main() {
    prnStr("Иван", "Петр", "Афанасий", "Владимир", "Дмитрий")
    println()
    prnStr("C++", "Kotlin", "Golang")
    println()
    print(prnSum(1, 9, 5, 16, 73))
}

fun prnStr(vararg name: String) {
    for (item in name) {
        print(item + "\t")
    }
}

fun prnSum(vararg itemNum: Int):Int {
    var result = 0
    for (item in itemNum) result += item
    return result
}

```

<details>
<summary><em>Output</em></summary>

```
Иван	Петр	Афанасий	Владимир	Дмитрий
C++	Kotlin	Golang
104
```

</details>

Если функция принимает несколько параметров, то обычно `vararg`-параметр является последним.

!!! example [Example](samples/04_Functions/09_Vararg/src/Main.kt)

```kotlin
fun main() {
    if(myCount(7, "Иван", "Петр", "Сергей")) {
        println("Людей больше, чем мест")
    }
    else {
        println("Мест хватает для всех")
    }
}

fun myCount(counts: Int, vararg users: String) = if (counts > users.size) {
    false
} else {
    true
}

```

<details>
<summary><em>Output</em></summary>

```
Мест хватает для всех
```

</details>

Однако это необязательно, и, если после `vararg`-параметра идут еще какие-нибудь параметры, то при вызове функции значения этим параметрам передаются через именованные аргументы.

!!! example [Example](samples/04_Functions/10-Vararg/src/Main.kt.kt)

```kotlin
fun main() {
    if(myCount("Иван", "Петр", "Сергей", counts = 2)) {
        println("Людей больше, чем мест")
    }
    else {
        println("Мест хватает для всех")
    }
}

fun myCount(vararg users: String, counts: Int) = if (counts > users.size) {
    false
} else {
    true
}

```

<details>
<summary><em>Output</em></summary>

```
Людей больше, чем мест
```

</details>

#### Оператор `*` — spread operator
Оператор `*` (spread operator) (не стоит путать со знаком умножения) позволяет передать параметру в качестве значения элементы из массива.

Обратите внимание на звездочку перед `nums` при вызове функции:
```kotlin
myCount(5, *testArr)
```

Без применения данного оператора мы столкнулись бы с ошибкой, поскольку параметры функции представляют не массив, а неопределенное количество значений типа `Int`.

!!! example [Example](samples/04_Functions/11_SpreadOperator/src/Main.kt)

```kotlin
fun main() {
    val testArr = intArrayOf(8, 9, 6, 7, 3, 4)
    println(myCount(5, *testArr))
}

fun myCount(koef: Int, vararg numbers: Int): Int {
    var summa = 0
    for (item in numbers) summa += item * koef
    return summa
}

```

<details>
<summary><em>Output</em></summary>

```
185
```

</details>

#### Функции – оператор `return`

![Return operator](./img/fun_02.png "Return operator")

### Функции – вернули `Unit`
Если функция возвращает значение `Unit`, мы также можем использовать оператор `return` для возврата из функции.

![Unit type](./img/fun_03.png "Unit type")

### Функции – однострочные функции
Однострочные функции (single expression function) используют сокращенный синтаксис определения функции в виде одного выражения. Эта форма позволяет опустить возвращаемый тип и оператор `return`.

После списка параметров не указывается возвращаемый тип. Возвращаемый тип будет выводится компилятором. Далее через оператор присвоения `=` определяется тело функции в виде одного выражения.

!!! example [Example](samples/04_Functions/12_SingleExpressionFun/src/Main.kt)

```kotlin
import java.lang.Math.pow
import kotlin.math.pow

fun main() {
    val testBasis = 7.0
    val testDegree = 4.0
    println(nthDegreeRoot(testBasis, testDegree))
    println(nthDegreeRootKotlin(testBasis, testDegree))
}

fun nthDegreeRoot(basis: Double, degree: Double) = pow(pow(basis, degree), 1 /2.0)

fun nthDegreeRootKotlin(basis: Double, degree: Double) = basis.pow(degree).pow(1 / 2.0)

```

<details>
<summary><em>Output</em></summary>

```
49.0
49.0
```

</details>

#### Функции – локальная функция
Одни функции могут быть определены внутри других функций. Внутренние или вложенные функции еще называют локальными.

Локальные функции могут определять действия, которые используются только в рамках какой-то конкретной функции и нигде больше не применяются.

![Local function](./img/fun_04.png "Local function")

#### Функции – рефакторинг кода

![Function refactoring](./img/fun_05.png "Function refactoring")

#### Функции – перегрузка
Каждый раз при вызове функции должно быть понятно, какая функция будет выполняться.

Обычно это достигается через разницу в списке параметров:
- разное количество параметров;
- разные типы у параметров;
- разный порядок параметров.

Одного возвращаемого типа недостаточно для различия двух функций. Т.е. если одна функция возвращает Int, а другая возвращает строку — этого будет недостаточно, чтобы компилятор понял, какую из них вызвать, ведь тип у параметров один и тот же.

!!! example [Example](samples/04_Functions/13_Overloading/src/Main.kt)

```kotlin
fun main() {
    println("7 < 9 < 16 => " + ascSequence(7, 9, 16))
    println("7.8 < 7.81 < 16.85 => " + ascSequence(7.8, 7.81, 16.85))
    println("7.8f < 7.81f < 16.85f => " + ascSequence(7.8f, 7.81f, 16.85f))
    println("87 < 69.3F < 56.15 => " + ascSequence(87, 69.3F, 56.15))
}

fun ascSequence(a: Int, b: Int, c: Int) = b in (a + 1)..c

fun ascSequence(a: Double, b: Double, c: Double) = a < b && b < c

fun ascSequence(a: Float, b: Float, c: Float) = a < b && b < c

fun ascSequence(a: Int, b: Float, c: Double) = a < b && b < c

```

<details>
<summary><em>Output</em></summary>

```
7 < 9 < 16 => true
7.8 < 7.81 < 16.85 => true
7.8f < 7.81f < 16.85f => true
87 < 69.3F < 56.15 => false
```

</details>

> Почему перегруженные функции для типов `Double`, `Float` и смешанных нельзя записать так же, как функцию для типа `Int`?
>
> Тело функции для типа `Int` можно записать как проверку диапазона в силу дискретности проверяемых значений. Если записать остальные функции так же, то при равенстве некоторых из входящих параметров функция будет выдавать неверный результат.

#### Функции – присвоение переменной
Переменная может представлять функцию. С помощью типа функции можно определить, какие именно функции переменная может представлять.

Чтобы передать функцию, перед названием функции ставится оператор `::`.

Затем через имя переменной фактически можно обращаться к функции.

!!! example [Example](samples/04_Functions/14_AssigningToVar/src/Main.kt)

```kotlin
fun main() {
    val operationFun: (Int, Int) -> Int
    val testA = (100..999).random()
    val testB = (100..999).random()
    if (testA < testB) {
        operationFun = ::addFun
    } else {
        operationFun = ::myDiff
    }
    print("$testA $testB => ")
    printResult(operationFun(testA, testB))
}

fun myDiff(a: Int, b: Int) = a - b

fun addFun(a: Int, b: Int) = a + b

fun printResult(function: Int) {
    println(function)
}

```

<details>
<summary><em>Output</em></summary>

```
870 767 => 103
```

</details>

#### Функции – примеры использования
Примеры использования функции как переменной или в качестве параметра для другой функции.

!!! example [Example](samples/04_Functions/15_UsageExamples/src/Main.kt)

```kotlin
fun main() {
    val operationFun = ::myFun
    printResult(operationFun, 5, 67)
    printResult(::addFun, 72, 28)
    println(myDiff(addFun(67, 45), 67))
}

fun myDiff(a: Int, b: Int) = a - b

fun addFun(a: Int, b: Int) = a + b

fun myFun(a: Int, b: Int) = a * b

fun printResult(function: (Int, Int) -> Int, a: Int, b: Int) {
    println(function(a, b))
}

```

<details>
<summary><em>Output</em></summary>

```
335
100
45
```

</details>

#### Функции высокого порядка
Функции высокого порядка (high order function) — это функции, которые либо принимают функцию в качестве параметра, либо возвращают функцию, либо и то, и другое.

![High order function](./img/fun_06.png "High order function")

!!! example [Example](samples/04_Functions/16_HighOrderFun/src/Main.kt)

```kotlin
fun main() {
    printResult(::addFun, 72, 28)
    prnRes(::myFun)
}

fun addFun(a: Int, b: Int) = a + b

fun myFun() {
    println("Вы распечатали строку")
}

fun printResult(function: (Int, Int) -> Int, a: Int, b: Int) {
    println(function(a, b))
}

fun prnRes(function: () -> Unit) {
    function()
}

```

<details>
<summary><em>Output</em></summary>

```
100
Вы распечатали строку
```

</details>

#### Возвращение функции из функции
В более редких случаях может потребоваться возвратить функцию из другой функции. В этом случае для функции в качестве возвращаемого типа устанавливается тип другой функции. А в теле функции возвращается лямбда выражение.

!!! example [Example](samples/04_Functions/17_ReturnFun/src/Main.kt)

```kotlin
fun main() {
    val actionOne = selectAction(1)
    println(actionOne(15, 95))
    val actionTwo = selectAction(2)
    println(actionTwo(43, 67))
}

fun selectAction(key: Int): (Int, Int) -> Int {
    return when (key) {
        1 -> ::sumFun
        2 -> ::subtractionFun
        else -> ::emptyFun
    }
}

fun sumFun(a: Int, b: Int) = a + b

fun subtractionFun(a: Int, b: Int) = a - b

fun emptyFun(a: Int, b: Int) = 0

```

<details>
<summary><em>Output</em></summary>

```
110
-24
```

</details>

#### Анонимные функции
Анонимные функции выглядят как обычные за тем исключением, что они не имеют имени.

!!! example [Example](samples/04_Functions/18_AnonymousFun/src/Main.kt)

```kotlin
fun main() {
    val message = fun() = println("Hello, World!!!")
    message()

    val sumFun = fun(x: Int, y: Int) = x + y
    println(sumFun(18, 37))
}

```

<details>
<summary><em>Output</em></summary>

```
Hello, World!!!
55
```

</details>

#### Анонимные функции как аргумент
Анонимную функцию можно передавать в функцию, если параметр соответствует типу этой функции.

!!! example [Example](samples/04_Functions/19_AnonymousFunAsArg/src/Main.kt)

```kotlin
fun main() {
    doOperation(9, 5, fun(x: Int, y: Int): Int = x + y)
    doOperation(9, 5, fun(x: Int, y: Int): Int = x - y)

    val action = fun(x: Int, y: Int): Int = x * y
    doOperation(9, 5, action)
}

fun doOperation(x: Int, y: Int, op: (Int, Int) -> Int) {
    val result = op(x, y)
    println(result)
}

```

<details>
<summary><em>Output</em></summary>

```
14
4
45
```

</details>

#### Возвращение анонимной функции из функции
Фунция может возвращать анонимную функцию в качестве результата.

!!! example [Example](samples/04_Functions/20_ReturnAnonymousFun/src/Main.kt)

```kotlin
fun main() {
    val action1 = selectAction(1)
    val result1 = action1(4, 5)
    println(result1)
    val action2 = selectAction(2)
    println(action2(4, 5))
    val action3 = selectAction(3)
    println(action3(4, 5))
    val action = selectAction(9)
    println(action(4, 5))
}

fun selectAction(key: Int): (Int, Int) -> Int {
    return when (key) {
        1 -> fun(x: Int, y: Int): Int = x + y
        2 -> fun(x: Int, y: Int): Int = x - y
        3 -> fun(x: Int, y: Int): Int = x * y
        else -> fun(_: Int, _: Int): Int = 0
    }
}

```

<details>
<summary><em>Output</em></summary>

```
9
-1
20
0
```

</details>

#### Функции – лямбда-выражения
Лямбда-выражения представляют небольшие кусочки кода, которые выполняют некоторые действия. Фактически лямбды преставляют сокращенную запись функций. При этом лямбды, как и обычные и анонимные функции, могут передаваться в качестве значений переменным и параметрам функции.

![Lambda statement](./img/fun_07.png "Lambda statement")

#### Лямбда-выражения. Передача параметров
Лямбды как и функции могут принимать параметры. Для передачи параметров используется стрелка `->`. Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки.

![Lambda params](./img/fun_08.png "Lambda params")

#### Лямбда-выражения как аргументы функций

![Lambda as arg](./img/fun_09.png "Lambda as arg")

#### Ключевые особенности функций в Kotlin
- Функция используется для определения задачи, которую можно выполнять столько раз, сколько потребуется без необходимости повторно писать код;
- Функции могут принимать ноль или более параметров и, при необходимости, возвращать значение;
- Для ясности при вызове функции можно использовать именованные аргументы;
- Указание значений функций по умолчанию может упростить работу и сократить объем кода;
- Функции могут обладать одним и тем же названием с разными параметрами. Это называется перегрузкой;
- Можно назначать функции переменным и передавать их другим функциям;
- У функций может быть специальный возвращаемый тип `Nothing`, который сообщает Kotlin, что эта функция никогда не завершится;
- Стремитесь создавать функции с четкими и понятными названиями;
- Одна функция должна выполнять ОДНУ задачу которая соответствует её названию.

### Функции — задачи
[675197445040133e8429e7a7](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345146)

**Обязательно выполняется задача 1 и одна из задач на шифрование сообщения**

#### 1. Камень-Ножницы-Бумага (три события)
Создать консольную игру "Камень-Ножницы-Бумага" (три события). На консоль выводится выбор компьютера (случайное значение) и выбор игрока. Для ускорения ввода выбора игрока можно условиться, что, например, 1 — это камень, 2 — ножницы, 3 — бумага. Выполненное задание представить в виде ссылки на GitHub

Победитель определяется по следующим правилам:

- Бумага побеждает камень («бумага обёртывает камень»).
- Камень побеждает ножницы («камень затупляет или ломает ножницы»).
- Ножницы побеждают бумагу («ножницы разрезают бумагу»).

Если игроки показали одинаковый знак, то засчитывается ничья и игра переигрывается.

[Решение](src/04_Functions/Task_01/src/Main.kt)

#### 2. Биграммный шифр Порты
Создать программу, для шифровки и расшифровки сообщений. Программа запрашивает исходное сообщение, вспомогательный символ и спрашивает — использовать типовую таблицу или генерировать случайную. Типовая таблица предоставлена на экране. При генерации случайной таблицы каждой паре букв сопоставляется случайное число от 1 до 999. Числа в таблице не повторяются. Каждое число состоит из трех знаков. Если число меньше 100, то оно дописывается до трех знаков путем добавления нулей перед числом.

В результате работы на консоль выводится исходное сообщение разбитое по парам букв с пробелами между парами, зашифрованное сообщение состоящее из цифр разбитых в группы по три цифры и пробела между группами и шифровальная таблица. Группа цифр из зашифрованного сообщения пишется под соответствующей парой символов исходного сообщения.

Шифр Порты, представленный им в виде таблицы, является первым известным биграммным шифром. Размер его таблицы составлял 20 х 20 ячеек; наверху горизонтально и слева вертикально записывался стандартный алфавит (в нем не было букв J, К, U, W, X и Z). В ячейках таблицы могли быть записаны **любые числа, буквы или символы** — сам Джованни Порта пользовался символами — **при условии, что содержимое ни одной из ячеек не повторялось**. Применительно к русскому языку таблица шифрозамен может выглядеть следующим образом.

| А     | Б   | В   | Г   | Д   | Е (Ё) | Ж   | 3   | И (Й) | К   | Л   | М   | Н   | О   | П   | Р   | С   | Т   | У   | Ф   | X   | Ц   | Ч   | Ш   | Щ   | Ъ   | Ы   | Ь   | Э   | Ю   | Я   |     |
| ----- | --- | --- | --- | --- | ----- | --- | --- | ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| А     | 1   | 2   | 3   | 4   | 5     | 6   | 7   | 8     | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  | 19  | 20  | 21  | 22  | 23  | 24  | 25  | 26  | 27  | 28  | 29  | 30  | 31  |
| Б     | 32  | 33  | 34  | 35  | 36    | 37  | 38  | 39    | 40  | 41  | 42  | 43  | 44  | 45  | 46  | 47  | 48  | 49  | 50  | 51  | 52  | 53  | 54  | 55  | 56  | 57  | 58  | 59  | 60  | 61  | 62  |
| В     | 63  | 64  | 65  | 66  | 67    | 68  | 69  | 70    | 71  | 72  | 73  | 74  | 75  | 76  | 77  | 78  | 79  | 80  | 81  | 82  | 83  | 84  | 85  | 86  | 87  | 88  | 89  | 90  | 91  | 92  | 93  |
| Г     | 94  | 95  | 96  | 97  | 98    | 99  | 100 | 101   | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 123 | 124 |
| Д     | 125 | 126 | 127 | 128 | 129   | 130 | 131 | 132   | 133 | 134 | 135 | 136 | 137 | 138 | 139 | 140 | 141 | 142 | 143 | 144 | 145 | 146 | 147 | 148 | 149 | 150 | 151 | 152 | 153 | 154 | 155 |
| Е (Ё) | 156 | 157 | 158 | 159 | 160   | 161 | 162 | 163   | 164 | 165 | 166 | 167 | 168 | 169 | 170 | 171 | 172 | 173 | 174 | 175 | 176 | 177 | 178 | 179 | 180 | 181 | 182 | 183 | 184 | 185 | 186 |
| Ж     | 187 | 188 | 189 | 190 | 191   | 192 | 193 | 194   | 195 | 196 | 197 | 198 | 199 | 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214 | 215 | 216 | 217 |
| 3     | 218 | 219 | 220 | 221 | 222   | 223 | 224 | 225   | 226 | 227 | 228 | 229 | 230 | 231 | 232 | 233 | 234 | 235 | 236 | 237 | 238 | 239 | 240 | 241 | 242 | 243 | 244 | 245 | 246 | 247 | 248 |
| И (Й) | 249 | 250 | 251 | 252 | 253   | 254 | 255 | 256   | 257 | 258 | 259 | 260 | 261 | 262 | 263 | 264 | 265 | 266 | 267 | 268 | 269 | 270 | 271 | 272 | 273 | 274 | 275 | 276 | 277 | 278 | 279 |
| К     | 280 | 281 | 282 | 283 | 284   | 285 | 286 | 287   | 288 | 289 | 290 | 291 | 292 | 293 | 294 | 295 | 296 | 297 | 298 | 299 | 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308 | 309 | 310 |
| Л     | 311 | 312 | 313 | 314 | 315   | 316 | 317 | 318   | 319 | 320 | 321 | 322 | 323 | 324 | 325 | 326 | 327 | 328 | 329 | 330 | 331 | 332 | 333 | 334 | 335 | 336 | 337 | 338 | 339 | 340 | 341 |
| М     | 342 | 343 | 344 | 345 | 346   | 347 | 348 | 349   | 350 | 351 | 352 | 353 | 354 | 355 | 356 | 357 | 358 | 359 | 360 | 361 | 362 | 363 | 364 | 365 | 366 | 367 | 368 | 369 | 370 | 371 | 372 |
| Н     | 373 | 374 | 375 | 376 | 377   | 378 | 379 | 380   | 381 | 382 | 383 | 384 | 385 | 386 | 387 | 388 | 389 | 390 | 391 | 392 | 393 | 394 | 395 | 396 | 397 | 398 | 399 | 400 | 401 | 402 | 403 |
| О     | 404 | 405 | 406 | 407 | 408   | 409 | 410 | 411   | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 425 | 426 | 427 | 428 | 429 | 430 | 431 | 432 | 433 | 434 |
| П     | 435 | 436 | 437 | 438 | 439   | 440 | 441 | 442   | 443 | 444 | 445 | 446 | 447 | 448 | 449 | 450 | 451 | 452 | 453 | 454 | 455 | 456 | 457 | 458 | 459 | 460 | 461 | 462 | 463 | 464 | 465 |
| Р     | 466 | 467 | 468 | 469 | 470   | 471 | 472 | 473   | 474 | 475 | 476 | 477 | 478 | 479 | 480 | 481 | 482 | 483 | 484 | 485 | 486 | 487 | 488 | 489 | 490 | 491 | 492 | 493 | 494 | 495 | 496 |
| С     | 497 | 498 | 499 | 500 | 501   | 502 | 503 | 504   | 505 | 506 | 507 | 508 | 509 | 510 | 511 | 512 | 513 | 514 | 515 | 516 | 517 | 518 | 519 | 520 | 521 | 522 | 523 | 524 | 525 | 526 | 527 |
| Т     | 528 | 529 | 530 | 531 | 532   | 533 | 534 | 535   | 536 | 537 | 538 | 539 | 540 | 541 | 542 | 543 | 544 | 545 | 546 | 547 | 548 | 549 | 550 | 551 | 552 | 553 | 554 | 555 | 556 | 557 | 558 |
| У     | 559 | 560 | 561 | 562 | 563   | 564 | 565 | 566   | 567 | 568 | 569 | 570 | 571 | 572 | 573 | 574 | 575 | 576 | 577 | 578 | 579 | 580 | 581 | 582 | 583 | 584 | 585 | 586 | 587 | 588 | 589 |
| Ф     | 590 | 591 | 592 | 593 | 594   | 595 | 596 | 597   | 598 | 599 | 600 | 601 | 602 | 603 | 604 | 605 | 606 | 607 | 608 | 609 | 610 | 611 | 612 | 613 | 614 | 615 | 616 | 617 | 618 | 619 | 620 |
| X     | 621 | 622 | 623 | 624 | 625   | 626 | 627 | 628   | 629 | 630 | 631 | 632 | 633 | 634 | 635 | 636 | 637 | 638 | 639 | 640 | 641 | 642 | 643 | 644 | 645 | 646 | 647 | 648 | 649 | 650 | 651 |
| Ц     | 652 | 653 | 654 | 655 | 656   | 657 | 658 | 659   | 660 | 661 | 662 | 663 | 664 | 665 | 666 | 667 | 668 | 669 | 670 | 671 | 672 | 673 | 674 | 675 | 676 | 677 | 678 | 679 | 680 | 681 | 682 |
| Ч     | 683 | 684 | 685 | 686 | 687   | 688 | 689 | 690   | 691 | 692 | 693 | 694 | 695 | 696 | 697 | 698 | 699 | 700 | 701 | 702 | 703 | 704 | 705 | 706 | 707 | 708 | 709 | 710 | 711 | 712 | 713 |
| Ш     | 714 | 715 | 716 | 717 | 718   | 719 | 720 | 721   | 722 | 723 | 724 | 725 | 726 | 727 | 728 | 729 | 730 | 731 | 732 | 733 | 734 | 735 | 736 | 737 | 738 | 739 | 740 | 741 | 742 | 743 | 744 |
| Щ     | 745 | 746 | 747 | 748 | 749   | 750 | 751 | 752   | 753 | 754 | 755 | 756 | 757 | 758 | 759 | 760 | 761 | 762 | 763 | 764 | 765 | 766 | 767 | 768 | 769 | 770 | 771 | 772 | 773 | 774 | 775 |
| Ъ     | 776 | 777 | 778 | 779 | 780   | 781 | 782 | 783   | 784 | 785 | 786 | 787 | 788 | 789 | 790 | 791 | 792 | 793 | 794 | 795 | 796 | 797 | 798 | 799 | 800 | 801 | 802 | 803 | 804 | 805 | 806 |
| Ы     | 807 | 80S | 809 | 810 | 811   | 812 | 813 | 814   | 815 | 816 | 817 | 818 | 819 | 820 | 821 | 822 | 823 | 824 | 825 | 826 | 827 | 828 | 829 | 830 | 831 | 832 | 833 | 834 | 835 | 836 | 837 |
| Ь     | 838 | 839 | 840 | 841 | 842   | 843 | 844 | 845   | 846 | 847 | 848 | 849 | 850 | 851 | 852 | 853 | 854 | 855 | 856 | 857 | 858 | 859 | 860 | 861 | 862 | 863 | 864 | 865 | 866 | 867 | 868 |
| Э     | 869 | 870 | 871 | 872 | 873   | 874 | 875 | 876   | 877 | 878 | 879 | 880 | 881 | 882 | 883 | 884 | 885 | 886 | 887 | 888 | 889 | 890 | 891 | 892 | 893 | 894 | 895 | 896 | 897 | 898 | 899 |
| Ю     | 900 | 901 | 902 | 903 | 904   | 905 | 906 | 907   | 908 | 909 | 910 | 911 | 912 | 913 | 914 | 915 | 916 | 917 | 918 | 919 | 920 | 921 | 922 | 923 | 924 | 925 | 926 | 927 | 928 | 929 | 930 |
| Я     | 931 | 932 | 933 | 934 | 935   | 936 | 937 | 938   | 939 | 940 | 941 | 942 | 943 | 944 | 945 | 946 | 947 | 948 | 949 | 950 | 951 | 952 | 953 | 954 | 955 | 956 | 957 | 958 | 959 | 960 | 961 |

Шифрование выполняется парами букв исходного сообщения. Первая буква пары указывает на строку шифрозамены, вторая — на столбец. В случае нечетного количества букв в исходном сообщении к нему добавляется вспомогательный символ («пустой знак»). Например, исходное сообщение «АБ РА МО В», зашифрованное — «002 466 355 093». В качестве вспомогательного символа использована буква «Я».

[Решение](src/04_Functions/Task_02/src/main.kt)

#### 3. Программа шифрования методом Вижинера
Написать программу, реализующую шифровку и расшифровку сообщения с помощью шифра Виженера. Программа запрашивает исходное сообщение, ключ и спрашивает, использовать типовую таблицу или генерировать случайную. Типовая таблица предоставлена на экране.

В результате работы на консоль выводится исходное сообщение, под ним ключ (повторяющийся столько раз, сколько это необходимо). Третьей строкой выводится зашифрованное сообщение. Буквы должны находиться друг под другом согласно порядкового номера (первая буква ключа под первой буквой исходного сообщения. Под ними же первая буква зашифрованного сообщения и т.д.). Также выводится шифровальная таблица.

Случайная шифровальная таблица получается путем случайного перемешивания символов первой строки. Все последующие строки сдвигаются относительно первой строки. Вторая строка — на одну ячейку, третья строка — на две ячейки и т.д.  Для усложнения задачи можно каждую последующую строку сдвигать на случайную величину относительно первой строки, с условием, что величина сдвига для каждой строки различна (не повторяется).

Шифр Виженера состоит из последовательности нескольких шифров Цезаря с различными значениями сдвига. Для зашифровывания может использоваться таблица алфавитов, называемая tabula recta или квадрат (таблица) Виженера. Применительно к русскому алфавиту таблица Виженера составляется из строк по 33 символов (начальная строка может быть перемешана), причём каждая следующая строка сдвигается на несколько позиций. Таким образом, в таблице получается 33 различных шифров Цезаря. На каждом этапе шифрования используются различные алфавиты, выбираемые в зависимости от символа ключевого слова.

| А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я |   |
| - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
| А | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я |
| Б | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А |
| В | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б |
| Г | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В |
| Д | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г |
| Е | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д |
| Ё | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е |
| Ж | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё |
| З | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж |
| И | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З |
| Й | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И |
| К | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й |
| Л | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К |
| М | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л |
| Н | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М |
| О | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н |
| П | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О |
| Р | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П |
| С | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р |
| Т | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С |
| У | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т |
| Ф | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У |
| Х | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф |
| Ц | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х |
| Ч | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц |
| Ш | Ш | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч |
| Щ | Щ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш |
| Ъ | Ъ | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ |
| Ы | Ы | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ |
| Ь | Ь | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы |
| Э | Э | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь |
| Ю | Ю | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э |
| Я | Я | А | Б | В | Г | Д | Е | Ё | Ж | З | И | Й | К | Л | М | Н | О | П | Р | С | Т | У | Ф | Х | Ц | Ч | Ш | Щ | Ъ | Ы | Ь | Э | Ю |

Например, предположим, что исходный текст и ключ имеют следующий вид:

- Текст: `ШИФРВИЖЕНЕР`
- Ключ:  `КОД`

Чтобы зашифровать текст необходимо записать ключевое слово «КОД» циклически до тех пор, пока его длина не будет соответствовать длине исходного текста.

- Текст: `ШИФРВИЖЕНЕР`
- Ключ:  `КОДКОДКОДКО`
- Итог:  `ГЧШЫРМСУСПЯ`

Первый символ исходного текста ("Ш") зашифрован последовательностью К, которая является первым символом ключа. Первый символ зашифрованного текста ("К") находится на пересечении строки К и столбца Ш в таблице Виженера. Точно так же для второго символа исходного текста используется второй символ ключа; то есть второй символ зашифрованного текста ("И") получается на пересечении строки О и столбца И. Остальная часть исходного текста шифруется подобным способом.

[Решение](src/04_Functions/Task_03/src/main.kt)

#### 4. Программа шифрования методом омофонической замены
Написать программу, реализующую шифровку и расшифровку сообщения методом омофонической замены. На входе программа запрашивает исходное сообщение. В результате работы программа выводит на консоль исходное сообщение, зашифрованное сообщение состоящее из цифр разбитых в группы по три цифры и пробела между группами и шифровальную таблицу. Шифровальную таблицу допускается выводить на консоль в виде строк, где каждая строка состоит из символа алфавита и соответствующего набора чисел разделенных пробелами. Каждое число состоит из трех знаков. Если число меньше 100, то оно дописывается до трех знаков путем добавления нулей перед числом.

Шифровальная таблица составляется путем сопоставления букве алфавита набора случайных неповторяющихся чисел от 0 до 999. Количество случайных чисел для каждой буквы алфавита равно коэффициенту вероятности умноженному на 1000. Числа также не повторяются для всей таблицы. Можно использовать типовую таблицу — то есть для символа 'А' используются строки от "000" до "068", так как вероятность появления символа 'А' равна 0.069. Для символа 'Б' используются строки от "069" до "081" и т.д. Для символа 'Я' используются строки от "837" до "853". Для символа ПРОБЕЛ используются строки от "854" до "999".

Каждая буква шифруется набором из трех цифр. Если букве сопоставляется число, состоящее менее, чем из трех знаков, то перед числом дописываются нули. Если одна и та же буква повторяется в исходном сообщении несколько раз, то для ее замены используются разные и не повторяющиеся числа из соответствующего набора. В случае, если количество повторений буквы больше, чем чисел в наборе, то возможно повторное использование чисел из соответствующего набора, но до тех пор, пока набор не исчерпает себя и т.д.

Для дешифровки можно использовать типовую таблицу в которой строки из чисел расположены по порядку. Естественно, что шифруем тогда тоже с использованием типовой таблицы.

Шифрование методом омофонической замены известно с 15 века.

Симеоне де Крема в 1401 году впервые использовал таблицы омофонов для равномерной частотности гласных букв при помощи многозначной замены.

Леон Баттиста Альберти в своей книге «Трактат о шифрах», опубликованной в 1466 году, описал шифр замены, в котором одной букве сопоставляется несколько элементов.

В 1401 г. Симеоне де Крема стал использовать таблицы омофонов для сокрытия частоты появления гласных букв в тексте при помощи более чем одной шифрозамены. Такие шифры позже стали называться шифрами многозначной замены или омофонами. Они получили развитие в XV веке. В книге «Трактат о шифрах» Леона Баттисты Альберти (итальянский ученый, архитектор, теоретик искусства, секретарь папы Климентия XII), опубликованной в 1466 г., приводится описание шифра замены, в котором каждой букве ставится в соответствие несколько эквивалентов, число которых пропорционально частоте встречаемости буквы в открытом тексте. Так, если ориентироваться на то число шифрозамен для буквы О должно составлять 94, для буквы Е — 71 и т.д. При этом каждая шифрозамена должна состоять из 3 цифр и их общее количество равно 1000. На рис. представлен фрагмент таблицы шифрозамен.

При шифровании символ исходного сообщения заменяется на любую шифрозамену из своего столбца. Если символ встречается повторно, то, как правило, используют разные шифрозамены. Например, исходное сообщение «АБРАМОВ» после шифрования может выглядеть «357 990 374 678 037 828 175».

*Вероятность появления букв русского алфавита*
| Буква | Вероятность | Буква | Вероятность | Буква | Вероятность | Буква | Вероятность |
| ----- | ----------- | ----- | ----------- | ----- | ----------- | ----- | ----------- |
| А     | 0,069       | И     | 0,064       | Р     | 0,042       | Ш     | 0,006       |
| Б     | 0,013       | Й     | 0,010       | С     | 0,046       | Щ     | 0,004       |
| В     | 0,038       | К     | 0,029       | Т     | 0,054       | Ъ     | 0,001       |
| Г     | 0,014       | Л     | 0,039       | У     | 0,023       | Ы     | 0,015       |
| Д     | 0,024       | М     | 0,027       | Ф     | 0,003       | Ь     | 0,013       |
| Е,Ё   | 0,071       | Н     | 0,057       | Х     | 0,008       | Э     | 0,002       |
| Ж     | 0,007       | О     | 0,094       | Ц     | 0,005       | Ю     | 0,005       |
| З     | 0,016       | П     | 0,026       | Ч     | 0,012       | Я     | 0,017       |

(*) (В таблице представлены результаты частотного анализа художественных и научно-технических текстов общим объёмом более 1 млн символов. При этих же условиях вероятность «пробела» составляет 0,146.)

Так как вероятность встретить самую редкую букву примерно равна одной тысячной, шифрование методом омофонической замены открытого текста можно осуществить по таблице шифрозамен, где каждая шифрозамена состоит из 3 цифр и их общее количество равно 1000. В таком случае для самого редкого элемента понадобится ровно один символ.

Пример такой таблицы представлен ниже.

| №  | А   | Б   | В   | … | Е   | … | О   | П   | Р   | … | Э   | Ю   | Я   |
| -- | --- | --- | --- | - | --- | - | --- | --- | --- | - | --- | --- | --- |
| 1  | 12  | 128 | 325 | … | 37  | … | 64  | 58  | 265 | … | 501 | 64  | 106 |
| 2  | 659 | 556 | 26  | … | 700 | … | 149 | 73  | 333 | … | 248 | 749 | 98  |
| …  | …   | …   | …   | … | …   | … | …   | …   | …   | … |     | …   | …   |
| 17 | 111 |     | 61  | … | 144 | … | 903 | 656 | 476 | … |     |     | 453 |
| …  | …   |     | …   | … | …   | … | …   | …   | …   | … |     |     |     |
| 38 | 366 |     | 804 | … | …   | … | 123 |     | 865 | … |     |     |     |
| …  | …   |     |     | … | …   | … | …   |     | …   | … |     |     |     |
| 69 | 95  |     |     |   | …   |   | 10  |     |     |   |     |     |     |
| …  |     |     |     |   | …   |   | …   |     |     |   |     |     |     |
| 71 |     |     |     |   | 541 |   | 268 |     |     |   |     |     |     |
| …  |     |     |     |   |     |   | …   |     |     |   |     |     |     |
| 94 |     |     |     |   |     |   | 479 |     |     |   |     |     |     |

Некоторые поля в таблице пусты, так как для каждого символа исходного алфавита количество замен различно. Например, по этому фрагменту можно зашифровать слово «ВЕРА». Каждую букву исходного сообщения, в данном случае слова, следует заменить на одну из шифрозамен в столбце этой буквы. Если буквы заменить такими шифрозаменами: «В» — 325, «Е» — 700, «Р» — 865, «А» — 095, тогда зашифрованное слово имеет вид числовой последовательности «325 700 865 095».

[Решение](src/04_Functions/Task_04/src/main.kt)

## 05 Введение в классы
[6754462b5040133e8429e7c4](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-5)

### Введение в классы
[675446925040133e8429e7c5](https://e-learn.petrocollege.ru/mod/url/view.php?id=345147)

https://wywiwyg.ru/learn_kotlin/lesson05.html

#### ООП (объектно-ориентированное программирование)
Существуют два главных подхода к написанию программ:
- Процедурное программирование
- Объектно-ориентированное программирование (оно же ООП)

Оба подхода объединены общей целью -сделать процесс программирования максимально эффективным. Это значит, что благодаря им разработка программного обеспечения становится более простой для понимания, легко масштабируемой и содержащей минимальное количество ошибок.

По сути любая программа представляет собой совокупность данных и операций по их обработке. Но что важнее, сами данные или операции над ними? В языках, в основе работы которых лежит принцип процедурного программирования (Basic, C, Pascal, Go), главным является код для обработки данных. При этом сами данные имеют второстепенное значение.

![Classes Intro 1](/img/oop_01.png)

В чем суть процедурного подхода? <dfn title="процедурное программирование">Процедурное программирование</dfn> – это написание функций и их последовательный вызов в некоторой главной(main) функции.

![Classes Intro 2](/img/oop_02.png)

Для каких проектов подходит процедурное программирование? Идеальные условия для применения данного подхода — простые программы, где весь функционал можно реализовать несколькими десятками процедур/функций. Функции аккуратно вложены друг в друга и легко взаимодействуют посредством передачи данных из одной функции в другую.

!!! example [Example](samples/05_ClassesIntro/01_Procedural/src/main.kt)

```kotlin
fun main() {
    doOperation(9, 5, fun(x: Int, y: Int): Int = x + y)
    doOperation(9, 5, fun(x: Int, y: Int): Int = x - y)

    val action = fun(x: Int, y: Int): Int = x * y
    doOperation(9, 5, action)
}

fun doOperation(x: Int, y: Int, op: (Int, Int) -> Int) {
    val result = op(x, y)
    println(result)
}

```

<details>
<summary><em>Output</em></summary>

```
Площадь = 80
Периметр = 42
S = 1139
P = 168
```

</details>

Однако проблема в том, что когда мы выходим за пределы этих идеальных условий, выплывают наружу многие недостатки данного подхода:

- В больших проектах приходится создавать огромное количество процедур и функций. В свою очередь, это неизбежно ведет к возникновению множества ошибок и снижает читаемость кода программы.

- Все данные внутри процедуры видны только локально, а значит их нельзя использовать в другом месте. Как следствие, код наполняется дубликатами.

- Высокий порог вхождения — по статистике начинающим данный поход дается сложнее, чем ООП.

Долгое время процедурный подход был довольно популярным и считался самым прогрессивным. Однако объемы кода программ росли, и ему на смену пришло объектно-ориентированное программирование.

![Classes Intro 3](/img/oop_03.png)

Вот как определяет данный подход Википедия:

*[ООП]: объектно-ориентированное программирование
<dfn title="объектно-ориентированное программирование">Объектно-ориентированное программирование</dfn> (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

В основе ООП лежит простая и элегантная идея, в соответствии с которой главное в программе — это данные. Именно они определяют, какие методы будут использоваться для их обработки. Т. е. данные первичны, код для обработки этих данных — вторичен.

Итак, чем же хорош подход ООП?

- Программа разбивается на объекты. Каждый объект отвечает за собственные данные и их обработку. Как результат — код становится проще и читабельней.
- Уменьшается дупликация кода. Нужен новый объект, содержимое которого на 90% повторяет уже существующий? Давайте создадим новый класс и унаследуем эти 90% функционала от родительского класса!
- Упрощается и ускоряется процесс написания программ. Можно сначала создать высокоуровневую структуру классов и базовый функционал, а уже потом перейти к их подробной реализации.

<dfn title="класс">Класс</dfn> — в объектно-ориентированном программировании, представляет собой шаблон для создания объектов, обеспечивающий начальные значения состояний: инициализация полей-переменных и реализация поведения функций или методов.

<dfn title="класс">Класс</dfn> – это языковая конструкция, которая объединяет в себе функции и переменные, относящиеся к какой-либо сущности. Например, класс Rectangle (прямоугольник) может содержать переменные с шириной и высотой прямоугольника, а также метод для вычисления площади.

<dfn title="объект">Объект</dfn> — некоторая сущность в цифровом пространстве, обладающая определённым состоянием и поведением, имеющая определенные свойства (поля) и операции над ними (методы). Как правило, при рассмотрении объектов выделяется то, что объекты принадлежат одному или нескольким классам, которые определяют поведение (являются моделью) объекта. Термины «экземпляр класса» и «объект» взаимозаменяемы.

На что необходимо обратить внимание?

- Класс описывает множество объектов, имеющих общую структуру и обладающих одинаковым поведением. <dfn title="класс">Класс</dfn> — это шаблон кода, по которому создаются объекты. Т. е. сам по себе класс ничего не делает, но с его помощью можно создать объект и уже его использовать в работе.
- Данные внутри класса делятся на свойства и методы. <dfn title="свойство класса">Свойства класса</dfn> (они же поля) — это характеристики объекта класса.
- <dfn title="метод класса">Методы класса</dfn> — это функции, с помощью которых можно оперировать данными класса.
- <dfn title="объект">Объект</dfn> — это конкретный представитель класса.
- Объект класса и <dfn title="экземпляр класса">экземпляр класса</dfn> — это одно и то же.

![Classes Intro 4](/img/oop_04.png)

Приведем пример объектно-ориентированного подхода для решения предыдущей задачи.

Если мы в свойствах класса укажем ключевое слово `val`, то получим свойство только для чтения. Если `var` — для чтения и изменения.

В данном случае свойства прямоугольника публичные:

!!! example Example

[Rectangle.kt](samples/05_ClassesIntro/02_Classes/src/Rectangle.kt)
```kotlin
class Rectangle(val width: Int, val height: Int) {
    fun calcArea() = width * height

    fun calcPerimeter() = 2 * (width + height)
}

```

[main.kt](samples/05_ClassesIntro/02_Classes/src/main.kt)
```kotlin
fun main() {
    val rectOne = Rectangle(5, 19)

    println("Ширина - ${rectOne.width}, высота - ${rectOne.height}")
    println("Площадь - ${rectOne.calcArea()}")
    println("Площадь - ${rectOne.calcPerimeter()}")

    val rectTwo = Rectangle(7, 14)
    println("S = ${rectTwo.calcArea()}")
    println("P = ${rectTwo.calcPerimeter()}")
}

```

<details>
<summary><em>Output</em></summary>

```
Ширина - 5, высота - 19
Площадь - 95
Площадь - 48
S = 98
P = 42
```

</details>

#### Принципы ООП — инкапсуляция
<dfn title="инкапсуляция">Инкапсуляция</dfn> — свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. Одни языки (например, C++, Java или Ruby) отождествляют инкапсуляцию с сокрытием, но другие (Smalltalk, Eiffel, OCaml) различают эти понятия.

Абстракция утверждает следующее: "Объект может быть рассмотрен с общей точки зрения". А инкапсуляция от себя добавляет: "И это единственная точка зрения, с которой вы вообще можете рассмотреть этот объект.". А если вы внимательно посмотрите на название, то увидите в нем слово "капсула". В этой самой "капсуле" спрятаны данные, которые мы хотим защитить от изменений извне.

Дадим определение:

<dfn title="инкапсуляция">Инкапсуляция</dfn> — принцип ООП, согласно которому сложность реализации программного компонента должна быть спрятана за его интерфейсом.

На что обратить внимание?

- Отсутствует доступ к внутреннему устройству программного компонента.
- Взаимодействие компонента с внешним миром осуществляется посредством интерфейса, который включает публичные методы и поля.

Инкапсуляция очень тесно связана с понятием "сокрытие". Класс является как бы капсулой, которая содержит в себе свойства и методы для работы с этими свойствами, которые позволяют их объединить.

На примере класса Человек мы видим публичные данные и приватные, в данном случае, методы. На приватные методы мы повлиять никак не можем. Они скрыты от нас. В качестве примера приватного свойства можно привести размер зарплаты. Для того, чтобы делать методы и свойства публичными или приватными существуют модификаторы доступа (видимости).

![Classes Intro 5](/img/oop_05.png)

##### Модификаторы видимости
Бывает удобно хранить данные в переменных, которые не видны извне класса. Для этого используются модификаторы видимости – ключевые слова, которые разрешают или ограничивают доступ к полям и методам класса. В Kotlin предусмотрены четыре типа видимости:

- **`public`** – поле или метод видимы из любой точки кода
- **`private`** – поле или метод видимы только внутри класса
- **`protected`** – поле или метод видимы только внутри класса, или из класса-наследника
- **`internal`** – поле или метод видимы только внутри модуля (всех файлов, которые компилируются вместе, как правило это весь проект).

Если модификатор видимости у поля или метода не указан, то подразумевается публичный доступ (`public`).

сли мы не хотим, чтобы пользователь напрямую обращался к свойствам объекта, то перепишем код для прямоугольника следующим образом.

![Classes Intro 6](/img/oop_06.png)

Теперь, при попытке обратиться к свойству экземпляра класса мы получим сообщение об ошибке.

![Classes Intro 7](/img/oop_07.png)

Код должен выглядеть следующим образом:

[main.kt](samples/05_ClassesIntro/02_Classes/src/main.kt)
```kotlin
fun main() {
    val rectOne = Rectangle(5, 19)

    println("Ширина - ${rectOne.width}, высота - ${rectOne.height}")
    println("Площадь - ${rectOne.calcArea()}")
    println("Площадь - ${rectOne.calcPerimeter()}")

    val rectTwo = Rectangle(7, 14)
    println("S = ${rectTwo.calcArea()}")
    println("P = ${rectTwo.calcPerimeter()}")
}

```

Чаще всего все свойства делают приватными (за редким исключением). А чтобы получать и изменять их используют геттеры и сеттеры.

#### Принципы ООП — наследование
<dfn title="наследование">Наследование</dfn> — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.

![Classes Intro 8](/img/oop_08.png)

![Classes Intro 9](/img/oop_09.png)

![Classes Intro 10](/img/oop_10.png)

![Classes Intro 11](/img/oop_11.png)

Для того, чтобы создать наследуемый класс мы должны воспользоваться ключевым словом `open`. Также мы должны воспользоваться данным ключевым словом при описании всех свойств и методов родительского класса. В этом случае свойства и методы родительского класса будут видны снаружи. Чтобы избежать этого, но при этом передать свойства и методы в наследуемый класс следует воспользоваться модификатором доступа `protected` – поле или метод видимы только внутри класса, или из класса-наследника.

![Classes Intro 12](/img/oop_12.png)

![Classes Intro 13](/img/oop_13.png)

![Classes Intro 14](/img/oop_14.png)

Теперь в классе `Person` создадим метод `fullName`, который выводит на экран полное имя сотрудника и покажем, что данный метод доступен для любого наследника класса `Person`.

![Classes Intro 15](/img/oop_15.png)

![Classes Intro 16](/img/oop_16.png)

#### Принципы ООП — полиморфизм
<dfn title="полиморфизм подтипов">Полиморфизм подтипов</dfn> (в ООП называемый просто "полиморфизмом") — свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. Другой вид полиморфизма — параметрический — в ООП называют <dfn title="обобщенное программирование">обобщенным программированием</dfn>.

В контексте ООП полиморфизм можно воспринимать как некоторый принцип, который позволяет одному и тому же фрагменту кода работать с разными типами данных.

Пример ad-hoc (мнимого) полиморфизма:

![Classes Intro 17](/img/oop_17.png)

Рассмотрим теперь параметрический, или истинный полиморфизм.

Нам необходимо, чтобы любой объект, который мы создали используя класс `Person`, `Employee` или `Developer`, мог сказать приветственные слова и объяснить, кто он. То есть объект `Person` должен сказать -"Привет, я человек ...", объект `Employee` - "Привет, я работник ...", объект `Developer` — "Привет, я прогер ..."

![Classes Intro 18](/img/oop_18.png)

![Classes Intro 19](/img/oop_19.png)

![Classes Intro 20](/img/oop_20.png)

![Classes Intro 21](/img/oop_21.png)

Решили задачу более правильно. Создали функцию для массового приветствия. Теперь, независимо от того, сколько в ней будет различных экземпляров от классов `Person`, `Employee`, `Developer` – каждый назовет себя и свой статус.

![Classes Intro 22](/img/oop_22.png)

Данное поведение называется полиморфизмом. Мы работаем с объектами, у которых функция `greeting()` работает по разному.

#### Выводы
Подведем некоторые итоги:

- Объектно-ориентированное программирование в Kotlin имеет ряд особенностей, связанных с появлением первичного конструктора, у полей – геттеров и сеттеров по-умолчанию. Есть возможность определять методы за пределами класса.
- В Kotlin по-умолчанию классы и их функции имеют модификатор `final`. Это значит, что от таких классов нельзя наследовать, а функции нельзя переопределять в дочерних классах. Чтобы разрешить наследование и переопределение необходимо это указать явно – писать модификатор `open` у родительского класса и его методов. В дочернем классе переопределяемые методы должны иметь модификатор `override`.
- В Kotlin есть абстрактные классы и интерфейсы, они являются открытыми по-умолчанию.
- Дочерние классы могут наследовать от одного родительского и от множества интерфейсов.
- Функции, которые входят в класс, называют <dfn title="метод">методами</dfn>. Поэтому обычно говорят «метод, вычисляющий площадь прямоугольника», а не «функция, вычисляющая площадь  прямоугольника». Хотя это одно и то же, и, в принципе, оба варианта не будут ошибкой. То же самое относится и к переменным – они называются полями: «поле содержит ширину  прямоугольника».
- Из классов воздаются объекты – конкретные экземпляры класса. В этом смысле класс можно сравнить с чертежом или схемой, по которой будет произведено устройство, а объекты – это сами  устройства, которые штампуются на конвейере на основе схемы. Объектов из одного класса можно произвести много, и каждый из них будет независим от другого такого объекта.
- Свойство — это переменная, локальная для объекта.

![Classes Intro 23](/img/oop_23.png)

### Классы — основы
[67571b1a5040133e8429e7ee](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345148)

**Задачи решаются с использованием классов. Задача 4 и задача 5 - сложные. Поэтому вы можете решить или 4-ю задачу, или 5-ю задачу, или комплект из 1-ой, 2-ой и 3-ей задач**

#### 1. Точка и треугольник (создать класс Точка и класс Треугольник)
Треугольник описан координатами трех своих вершин. Указаны координаты отдельной точки. Составить программу, показывающую где находится точка — внутри или вне треугольника. Треугольник и точка находятся на координатной плоскости.

Обратить внимание на обработку ошибок при вводе координат. Программа не должна "падать" при вводе неправильных значений.

[Решение](src/05_ClassesIntroduction/Task_01/src/main.kt)

#### 2. Расстояние между точками (с использованием класса Точка)
Две точки находятся на координатной плоскости. Каждая точка описана своими координатами. Найти расстояние между указанными точками.

[Решение](src/05_ClassesIntroduction/Task_02/src/main.kt)

#### 3. Выбор наибольшего и наименьшего расстояний (обязательно использовать класс Точка)
Множество точек расположено на координатной плоскости. Количество точек задается в консоли при запуске программы и оно должно быть больше двух. Каждая точка задается своими координатами. Точки не совпадают друг с другом. Требуется найти минимальное и максимальное расстояние между точками.

[Решение](src/05_ClassesIntroduction/Task_03/src/main.kt)

#### 4. Треугольник в окружности (обязательно использование класса Точка и класса Треугольник. Класс Окружность и другие классы — по желанию)
Треугольник расположен на координатной плоскости и описан координатами своих вершин. Написать программу вычисляющую координаты центра описанной вокруг треугольника окружности и ее радиус.

[Решение](src/05_ClassesIntroduction/Task_04/src/main.kt)

#### 5. Окружность в треугольнике (обязательно использование класса Точка и класса Треугольник. Класс Окружность и другие классы — по желанию)
Треугольник расположен на координатной плоскости и описан координатами своих вершин. Написать программу вычисляющую координаты центра вписанной в треугольник окружности и ее радиус.

[Решение](src/05_ClassesIntroduction/Task_05/src/main.kt)

## 06 Классы. Конструкторы. Get-еры. Set-еры
[67595ee75040133e8429e818](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-6)

### Классы. Конструкторы. Get-еры. Set-еры
[67598c985040133e8429e821](https://e-learn.petrocollege.ru/mod/url/view.php?id=345149)

https://wywiwyg.ru/learn_kotlin/lesson06.html

#### Kotlin. Классы
Синтаксис определения класса состоит из ключевого слова `class`, за которым следует имя класса, и блока кода, содержащего свойства и функции класса:

```kotlin
class ClassName {
    // свойства
    // функции
}
```

- Имя класса должно начинаться с заглавной буквы и быть существительным (например, `Dog`, `Person`, `BankAccount`).
- Класс может иметь свойства (данные) и функции (поведение).
- Свойства и функции класса могут быть общедоступными (доступными откуда угодно) или частными (доступными только внутри класса). По умолчанию они общедоступны в Котлине.
- Класс может иметь первичный конструктор и/или один или несколько вторичных конструкторов. Первичный конструктор определяется в заголовке класса, а вторичные конструкторы определяются с помощью ключевого слова `constructor`.
- Класс может иметь модификатор `open`, `abstract`, `sealed` или `final`. Модификатор `open` позволяет классу создавать подклассы, модификатор `abstract` позволяет классу иметь абстрактные (нереализованные) функции, модификатор `sealed` позволяет классу иметь подклассы, но только в том же файле, а модификатор `final` предотвращает создание подклассов класса.
- Класс может иметь модификатор `inner`, `nested`, или `static` вложенный. Модификатор `inner` позволяет классу получать доступ к членам внешнего класса, модификатор `nested` позволяет классу быть `static` вложенным классом, а вложенный модификатор `static` позволяет классу быть статическим вложенным классом и получать доступ только к статическим членам внешнего класса.
- Класс может иметь сопутствующий объект, который является одноэлементным объектом, связанным с классом.
- Класс может расширять один или несколько суперклассов и реализовывать один или несколько интерфейсов.
- Класс может переопределять и/или перегружать функции и свойства своего суперкласса и/или интерфейсов.

![Classes](./img/class_01.png)

![Classes](./img/class_02.png)

![Classes](./img/class_03.png)

![Classes](./img/class_04.png)

![Classes](./img/class_05.png)

![Classes](./img/class_06.png)

#### Kotlin. Классы. Конструкторы
<dfn title="конструктор">Конструктор</dfn> — это специальная функция-член, которая вызывается при создании объекта класса в первую очередь для инициализации переменных или свойств. Класс должен иметь конструктор, и если мы не объявим конструктор, компилятор генерирует конструктор по умолчанию. В Kotlin есть два типа конструкторов:
- Первичный конструктор
- Вторичный конструктор

Класс в Kotlin может иметь не более одного первичного конструктора и одного или нескольких вторичных конструкторов. Первичный конструктор инициализирует класс, а вторичный конструктор используется для инициализации класса и введения дополнительной логики.

Первичный конструктор инициализируется в заголовке класса и идет после имени класса с использованием ключевого слова `constructor`. Параметры являются необязательными в основном конструкторе.

```kotlin
class AddValue constructor(val a: Int, val b: Int) {
    val c = a + b
}
```

Ключевое слово `constructor` можно опустить , если не указаны аннотации или модификаторы доступа.

```kotlin
class AddValue(val a: Int, val b: Int) {
    val c = a + b
}
```

Первичный конструктор не может содержать какой-либо код, код инициализации может быть помещен в отдельный блок инициализатора с префиксом ключевого слова `init`.

Он действует как блок инициализатора, в котором инициализируются переменные-члены. Этот блок выполняется всякий раз, когда создается экземпляр этого класса. Блоков инициализации может быть несколько, и они вызываются в том порядке, в котором они записаны внутри класса.

Блоки инициализации вызываются **ДО** вызова конструктора этого класса.

[Example](samples/06_Constructors/01_Constructors/src/main.kt)
```kotlin
class InitOrderDemo(name: String) {
    val firstProperty = "Первое свойство: $name"

    init {
        println("Первый блок инициализации: $name")
    }

    val secondProperty = "Второе свойство: ${name.length}"

    init {
        println("Второй блок инициализации: ${name.length}")
    }
}

fun main() {
   val demo = InitOrderDemo("User")
}

```

<details>
<summary><em>Output</em></summary>

```
Первый блок инициализации: User
Второй блок инициализации: 4
```

</details>

В примере выше блоки `init` выполнились при создании объекта класса.

Подобно значениям по умолчанию в функциях, мы можем инициализировать параметры конструктора некоторыми значениями по умолчанию.

[Example](samples/06_Constructors/02_Constructors/src/main.kt)
```kotlin
class InitOrderDemo (emp_id: Int = 100, emp_name: String = "User") {
    val id: Int
    val name: String
    init {
        id = emp_id
        name = emp_name

        println("Значение id: $id")
        println("Значение name: $name")
        println()
    }
}

fun main() {
    val empOne = InitOrderDemo(249857, "Александр")
    val empTwo = InitOrderDemo(372648)
    val empThree = InitOrderDemo()
}

```

<details>
<summary><em>Output</em></summary>

```
Значение id: 249857
Значение name: Александр

Значение id: 372648
Значение name: User

Значение id: 100
Значение name: User
```

</details>

#### Kotlin. Классы. Вторичные конструкторы
Котлин может иметь один или несколько вторичных конструкторов. Вторичные конструкторы позволяют инициализировать переменные, а также предоставляют некоторую логику классу. Им предшествует ключевое слово `constructor`. В данном случае мы используем конструктор по умолчанию. Поэтому все вторичные конструкторы наследуются от него.

[Example](samples/06_Constructors/03_SecondaryConstructors/src/main.kt)
```kotlin
class AddValue {
    constructor(a: Int, b: Int) {
        println("Складываем целые числа: $a + $b = ${a + b}")
    }
    constructor(a: String, b: Int) {
        println("Складываем строку и число: $a + $b = ${a.toInt() + b}")
    }
    constructor(a: Int, b: String) {
        println("Складываем число и строку: $a + $b = ${a + b.toInt()}")
    }
    constructor(a: String, b: String) {
        println("Складываем строки: $a + $b = ${a.toInt() + b.toInt()}")
    }
}

fun main() {
    val one = AddValue(25, 35)
    val two = AddValue("65", 75)
    val three = AddValue(45, "85")
    val four = AddValue("95", "75")
}

```

<details>
<summary><em>Output</em></summary>

```
Складываем целые числа: 25 + 35 = 60
Складываем строку и число: 65 + 75 = 140
Складываем число и строку: 45 + 85 = 130
Складываем строки: 95 + 75 = 170
```

</details>

![Classes](./img/class_07.png)

![Classes](./img/class_08.png)

![Classes](./img/class_09.png)

![Classes](./img/class_10.png)

[Примеры](samples/06_Constructors/04_Examples/src/main.kt)
```kotlin
fun main() {
    println("ParentClass(25, 35)===========================")
    val one = ParentClass(25, 35)
    println("\nParentClass(65, 75, 50)=====================")
    val two = ParentClass(65, 75, 50)
    println("\nDescendantClassOne(5, 15)===================")
    val three = DescendantClassOne(5, 15)
    println("\nDescendantClassOne(5, 25, 15, 47)===========")
    val four = DescendantClassOne(5, 25, 15, 47)
    println("\nDescendantClassTwo(5, 9, 6)=================")
    val five = DescendantClassTwo(5, 9, 6)
    println("\nDescendantClassThree(9, 7, 6)===============")
    val six = DescendantClassThree(9, 7, 6)
    println("\nDescendantClassFour(18, 78)=================")
    val seven = DescendantClassFour(18, 78)
    println("\nDescendantClassFour(18, 78, 75)=============")
    val eight = DescendantClassFour(18, 78, 75)
    println("\nDescendantClassFour(15, 78, 96, 34)=========")
    val nine = DescendantClassFour(15, 78, 96, 34)
    println("\nDescendantClassFour(46, 78, \"99\")=========")
    val ten = DescendantClassFour(15, 78, "99")
}

open class ParentClass(a: Int, b: Int) {
    init {
        println("init-блок от ParentClass")
    }

    constructor(a: Int, b: Int, c: Int) : this(a, b) {
        println("Вторичный конструктор от ParentClass")
    }
}

class DescendantClassOne(a: Int, b: Int) : ParentClass(a, b) {
    init {
        println("init-блок от DescendantClassOne")
    }

    // constructor(a: Int, b: Int, c: Int):super(a,b)
    constructor(a: Int, b: Int, c: Int, d: Int) : this(a, b) {
        println("Вторичный конструктор от DescendantClassOne")
    }
}

class DescendantClassTwo(a: Int, b: Int, c: Int) : ParentClass(a, b) {
    init {
        println("init-блок от DescendantClassTwo")
    }
    // constructor(a: Int, b: Int, c: Int):super(a, b)
}

class DescendantClassThree(a: Int, b: Int, c: Int) : ParentClass(a, b, c) {
    init {
        println("init-блок от DescendantClassThree")
    }
    // constructor(a: Int, b: Int, c: Int) : super(a, b, c)
}

class DescendantClassFour : ParentClass {
    init {
        println("init-блок от DescendantClassFour")
    }

    constructor(a: Int, b: Int) : super(a, b) {
        println("Вторичный конструктор от DescendantClassFour constructor(a: Int, b: Int) : super(a, b)")
    }

    constructor(a: Int, b: Int, c: Int) : super(a, b) {
        println("Вторичный конструктор от DescendantClassFour constructor(a: Int, b: Int, c: Int) : super(a, b)")
    }

    constructor(a: Int, b: Int, c: Int, d: Int) : super(a, b, c) {
        println("Вторичный конструктор от DescendantClassFour constructor(a: Int, b: Int, c: Int, d: Int) : super(a, b, c)")
    }

    constructor(a: Int, b: Int, c: String) : super(a, b, c.toInt()) {
        println("Вторичный конструктор от DescendantClassFour constructor(a: Int, b: Int, c: String) : super(a, b, c)")
    }
}

```

<details>
<summary><em>Output</em></summary>

```
ParentClass(25, 35)===========================
init-блок от ParentClass

ParentClass(65, 75, 50)=====================
init-блок от ParentClass
Вторичный конструктор от ParentClass

DescendantClassOne(5, 15)===================
init-блок от ParentClass
init-блок от DescendantClassOne

DescendantClassOne(5, 25, 15, 47)===========
init-блок от ParentClass
init-блок от DescendantClassOne
Вторичный конструктор от DescendantClassOne

DescendantClassTwo(5, 9, 6)=================
init-блок от ParentClass
init-блок от DescendantClassTwo

DescendantClassThree(9, 7, 6)===============
init-блок от ParentClass
Вторичный конструктор от ParentClass
init-блок от DescendantClassThree

DescendantClassFour(18, 78)=================
init-блок от ParentClass
init-блок от DescendantClassFour
Вторичный конструктор от DescendantClassFour constructor(a: Int, b: Int) : super(a, b)

DescendantClassFour(18, 78, 75)=============
init-блок от ParentClass
init-блок от DescendantClassFour
Вторичный конструктор от DescendantClassFour constructor(a: Int, b: Int, c: Int) : super(a, b)

DescendantClassFour(15, 78, 96, 34)=========
init-блок от ParentClass
Вторичный конструктор от ParentClass
init-блок от DescendantClassFour
Вторичный конструктор от DescendantClassFour constructor(a: Int, b: Int, c: Int, d: Int) : super(a, b, c)

DescendantClassFour(46, 78, "99")=========
init-блок от ParentClass
Вторичный конструктор от ParentClass
init-блок от DescendantClassFour
Вторичный конструктор от DescendantClassFour constructor(a: Int, b: Int, c: String) : super(a, b, c)
```

</details>

#### Kotlin. Классы. Get-еры и Set-еры
Если необходимо внести изменения в прочитанное значение свойства или проверить значение перед тем, как оно будет записано в свойство, следует написать собственные get-и set-методы.

Get- и set-методы предназначены для чтения и записи значений свойств.

Единственное предназначение get-метода — вернуть значение, запрошенное для данного свойства. А set-методы получают значение аргумента и используют его для записи значения в свойство.

Специализированные get-и set-методы позволяют защитить значения свойств и управлять тем, какие значения читаются или записываются в свойства.

Геттеры (getter) и сеттеры (setter) (еще их называют методами доступа) позволяют управлять доступом к переменной. Их формальный синтаксис:
```kotlin
var имя_свойства[: тип_свойства] [= инициализатор_свойства]
    [getter]
    [setter]
```

Инициализатор, геттер и сеттер свойства необязательны. Указывать тип свойства также необязательно, если он может быть выведен из значения инициализатора или из возвращаемого значения геттера.

Геттеры и сеттеры необязательно определять именно для свойств внутри класса, они могут также применяться к переменным верхнего уровня.

[Example](samples/06_Constructors/05_GettersSetters/src/main.kt)
```kotlin
fun main() {
    val personOne = Person()
    val personTwo = Person()
    val personThree = Person()

    personOne.age = 19
    println(personOne.age)

    personTwo.age = 166
    println(personTwo.age)

    personThree.age = -19
    println(personTwo.age)
}

class Person() {
    var age = 0
        set(value) {
            if ((value > 0) and (value < 124)) {
                field = value
            } else {
                field = 45
                println("Неправильный возраст")
            }
        }
}

```

<details>
<summary><em>Output</em></summary>

```
19
Неправильный возраст
45
Неправильный возраст
45
```

</details>


[Example](samples/06_Constructors/06_GettersSetters/src/main.kt)
```kotlin
fun main() {
    val personOne = Person(19)
    val personTwo = Person(166)
    val personThree = Person(-19)

    personOne.age = 55
    println(personOne.age)
    personOne.prnAge()
    println()

    println(personTwo.age)
    personTwo.prnAge()
    println()

    personThree.age = -19
    println(personTwo.age)
    personThree.prnAge()
}

class Person(_age: Int) {
    var age = _age
        set(value) {
            if ((value > 0) and (value < 124)) {
                field = value
            } else {
                field = 45
                println("Неправильный возраст")
            }
        }
        get() {
            if ((field > 0) and (field < 124)) {
                return field
            } else {
                println("Установленный возраст")
                return 85
            }
        }
    fun prnAge() = println("Возраст $age")

}

```

<details>
<summary><em>Output</em></summary>

```
55
Возраст 55

Установленный возраст
85
Установленный возраст
Возраст 85

Неправильный возраст
Установленный возраст
85
Возраст 45
```

</details>

### Поезд
[6759c3e55040133e8429e827](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345151)

Необходимо составить программу, которая помогает пользователю составить план поезда. После запуска программа спрашивает пользователя — хочет ли он закончить работу, или составить поезд.

Есть 4 основных шага в создании плана:
- Создать направление — создает направление для поезда (к примеру Бийск - Барнаул). Маршрут составляется случайным выбором двух городов из списка, состоящего, минимум, из 15-и городов. Начальная и конечная точки маршрута должны быть различны.
- Продать билеты — вы получаете рандомное кол-во пассажиров, которые купили билеты на это направление. Количество пассажиров находится в диапазоне от 5-и до 201.
- Сформировать поезд — вы создаете поезд и добавляете ему столько вагонов (вместительность каждого вагона определяется рандомно и находится в диапазоне от 5 до 25), сколько хватит для перевозки всех пассажиров. То есть вы прибавляете к поезду по одному вагону рандомной вместительности до тех пор, пока не усадите в них всех пассажиров, купивших билеты
- Отправить поезд — вы отправляете поезд, после чего можете снова создать направление. Программа выдает запрос на окончание или продолжение работы. То есть программа работает до тех пор, пока пользователь не введет слово EXIT.

После каждого этапа выдается соответствующая информация. После 4-го шага программа сообщает, что поезд [направление], состоящий из [количество] вагонов отправлен. Также выдается информация о вместимости каждого вагона и количестве пассажиров в каждом вагоне.

Программа не должна "падать" при вводе неправильных значений.

## 07 Абстрактные классы. Интерфейсы
[675c89265040133e8429e83f](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-7)

### Абстрактные классы. Интерфейсы
[675cc3475040133e8429e846](https://e-learn.petrocollege.ru/mod/url/view.php?id=345153)

https://wywiwyg.ru/learn_kotlin/lesson07.html

Абстрактные классы и интерфейсы объединены в одну тему, так как по своей сути они очень похожи. И те и другие имеют отношение к “моделированию” классов. С их помощью мы можем показать, что у определённой группы классов есть что-то общее: то, что их отличает от всех остальных. Ключевая разница между ними лишь в том, как их применять.

#### Абстрактные классы

<dfn title="абстрактный класс">Абстрактный класс</dfn> — это класс, экземпляр которого не может быть создан напрямую и который предназначен для создания подклассов другими классами. Абстрактный класс может иметь как абстрактные, так и конкретные методы, а также переменные экземпляра. Абстрактные методы, объявленные в абстрактном классе, не имеют никакой реализации и должны быть реализованы любым подклассом, расширяющим абстрактный класс.

<dfn title="абстрактный класс">Абстрактный класс</dfn> — это класс, представляющий из себя “заготовку” для целого семейства классов, который описывает для них общий шаблон поведения. Такой класс не может быть создан. Т.е. нельзя создать его экземпляр. Он используются исключительно в качестве суперкласса, а его цель — моделирование поведения своего семейства, а также предоставление функционала для повторного использования. Другими словами абстрактный класс — это средство, для повторного использования кода.

![Abstract classes](./img/abstract_01.png)

![Abstract classes](./img/abstract_02.png)

![Abstract classes](./img/abstract_03.png)

![Abstract classes](./img/abstract_04.png)

![Abstract classes](./img/abstract_05.png)

![Abstract classes](./img/abstract_06.png)

![Abstract classes](./img/abstract_07.png)

![Abstract classes](./img/abstract_08.png)

![Abstract classes](./img/abstract_09.png)

![Abstract classes](./img/abstract_10.png)

**Характеристики абстрактных классов**
- Невозможно создать экземпляр: невозможно создать объект непосредственно из абстрактного класса.
- Могут иметь как абстрактные, так и конкретные члены: это позволяет сочетать предопределенное поведение и поведение, которое должно быть определено путем наследования классов.
- Нет необходимости в ключевом слове `open`: в Котлине, если класс объявлен как `abstract`, он по своей сути открыт. Это означает, что другие классы могут наследовать его без необходимости использования ключевого слова `open`.

**Преимущества абстрактных классов в Котлине**:
- Абстрактные классы могут предоставлять базовую реализацию, которую могут повторно использовать ее подклассы.
- Абстрактные классы могут определять абстрактные методы, которые обеспечивают соблюдение контракта для любого подкласса, расширяющего абстрактный класс.
- Абстрактные классы могут иметь переменные экземпляра, наследуемые его подклассами

**Преимущества внедрения**
- Согласованность: гарантирует, что все подклассы имеют определенные методы или свойства, определенные абстрактным классом.
- Гибкость: придерживаясь структуры, каждый подкласс может иметь свою уникальную реализацию.
- Возможность повторного использования. Конкретные методы и свойства абстрактного класса можно повторно использовать во всех подклассах без переопределения.

**Недостатки абстрактных классов в Котлине**:
- Абстрактные классы не могут быть созданы напрямую, и для их использования необходимо создать подклассы.
- Подкласс может расширять только один абстрактный класс, что ограничивает гибкость наследования.

**Подходящие сценарии использования абстрактных классов в Kotlin**:
- Если вы хотите определить базовую реализацию, которую могут повторно использовать ее подклассы.
- Если вы хотите обеспечить соблюдение контракта для любого подкласса, расширяющего абстрактный класс.

#### Интерфейсы
<dfn title="интерфейс">Интерфейс</dfn> — это совокупность методов и правил, которые определяют поведение класса или общее поведение для группы независимых друг от друга классов. Интерфейсы похожи на абстрактные классы тем, что нельзя создать их экземпляры и они могут определять абстрактные или конкретные функции и свойства. Отличие в том, что интерфейсу не важна связь “родитель-наследник”, он задаёт лишь правила поведения.

В нашем приложении уже есть целое семейство деревьев, информацию о которых можно с лёгкостью получить — их название и краткое описание. Но помимо этого деревья могут цвести и производить кислород. Такие методы можно добавить в абстрактный класс `Tree`, но что если мы решим помимо деревьев предоставлять информацию о, скажем, водорослях. У них тоже есть период цветения и они тоже производят кислород, но они не являются деревьями, а значит мы не можем наследовать их от класса `Tree`. Таким образом мы получили группу независимых друг от друга классов с одинаковым поведением, которое будет реализовываться через интерфейс `Cultivable`.

![Interfaces](./img/interfaces_01.png)

В теле интерфейса можно определять абстрактные свойства и функции. Для этого не требуется использовать ключевое слово `abstract`, так как Kotlin способен сам понять, что свойство и функция без реализации должны быть абстрактными. Также обратите внимание, что единственный способ определить свойство — это определить его в теле интерфейса, так как у интерфейса не бывает конструкторов.

![Interfaces](./img/interfaces_02.png)

![Interfaces](./img/interfaces_03.png)

![Interfaces](./img/interfaces_04.png)

Класс должен реализовывать все абстрактные свойства и функции, определённые в интерфейсе.

При этом если интерфейс реализовывается в абстрактном классе, то свойства и функции интерфейса могут быть в нём опущены. Тогда все наследники абстрактного класса должны будут их переопределять.

В интерфейсе можно определять свойства и функции с конкретной реализацией (по умолчанию). Классы, реализующие этот интерфейс, могут использовать реализацию по умолчанию или определить свою. При этом реализация свойств осуществляется с помощью метода доступа `get()`.

Один интерфейс может реализовать другой интерфейс, при этом будет иметь доступ к его свойствам и функциям.

![Interfaces](./img/interfaces_05.png)

**Преимущества интерфейсов на Kotlin**:
- Интерфейсы могут определять контракты для классов, которые их реализуют.
- Интерфейсы могут предоставлять реализации по умолчанию для своих методов.
- Класс может реализовывать несколько интерфейсов, что обеспечивает большую гибкость, чем абстрактные классы.

**Недостатки интерфейсов в Kotlin**:
- Интерфейсы могут только объявлять методы и не могут предоставлять никаких подробностей реализации своих методов.

> Это утверждение не совсем верно: интерфейсы не могут предоставить полную реализацию своих методов, они могут предоставлять реализации по умолчанию, которые реализующие классы могут использовать как есть или переопределять пользовательскими реализациями.

**Подходящие сценарии использования интерфейсов в Kotlin**:
- Если вы хотите определить контракт для классов, реализующих интерфейс.
- Если вы хотите предоставить реализации по умолчанию для методов в интерфейсе.
- Если вы хотите предоставить классу гибкость для реализации нескольких интерфейсов.

#### Различия между абстрактными классами и интерфейсами в Котлине
Основные различия между абстрактными классами и интерфейсами в Kotlin:
- Абстрактный класс может иметь переменные экземпляра, а интерфейс не может иметь переменные экземпляра.

    > это утверждение верно только до версии Kotlin 1.5. Даже интерфейсы также могут иметь переменные экземпляра.

- Абстрактный класс может предоставить базовую реализацию своих методов, в то время как интерфейс не может предоставить никаких подробностей реализации своих методов.

    > это утверждение также не совсем верно, поскольку интерфейсы могут иметь реализацию по умолчанию.

- Класс может расширять только один абстрактный класс, но может реализовывать несколько интерфейсов.
- Абстрактный класс может иметь как абстрактные, так и конкретные методы, тогда как интерфейс может иметь только абстрактные методы (с реализациями по умолчанию в Котлине).
- Абстрактный класс можно использовать для определения иерархии связанных классов, а интерфейс можно использовать для определения набора несвязанных классов, которые имеют общее поведение.

#### Выбор между абстрактными классами и интерфейсами в Котлине
Выбирая между абстрактными классами и интерфейсами в Kotlin, учитывайте следующие рекомендации:

**Используйте абстрактные классы, когда**:
- Вы хотите определить базовую реализацию, которую могут повторно использовать ее подклассы.
- Вы хотите обеспечить соблюдение контракта для любого подкласса, расширяющего абстрактный класс.
- Вы хотите иметь переменные экземпляра, унаследованные его подклассами.
- Вы хотите определить иерархию связанных классов.

**Используйте интерфейсы, когда**:
- Вы хотите определить контракт для классов, реализующих интерфейс.
- Вы хотите предоставить реализации по умолчанию для методов интерфейса.
- Вы хотите предоставить классу гибкость для реализации нескольких интерфейсов.
- Вы хотите определить набор несвязанных классов, которые имеют общее поведение.

**Шпаргалка: абстрактный класс или интерфейс?**
- У вас есть семейство классов, из которых можно выделить общую сущность? Определите эту сущность в качестве абстрактного класса и она будет “заготовкой” для всего семейства.
- Вам нужно создать более конкретную версию класса? Создайте подкласс этого класса и добавьте недостающее поведение.
- Требует определить общее поведение для группы независимых друг от друга классов? Создайте интерфейс и реализуйте его теми классами, которым необходимо это поведение.

#### Ключевые моменты
- Абстрактный класс — это “заготовка” для целого семейства классов.
- Нельзя создать экземпляр абстрактного класса.
- Абстрактный класс может содержать как абстрактные, так и конкретные реализации свойств и функций.
- Класс, который содержит абстрактное свойство или функцию, должен быть объявлен абстрактным.
- Абстрактный класс может быть без единого абстрактного свойства или функции.
- У класса может быть только один суперкласс.
- Наследники абстрактного класса должны переопределять все его абстрактные свойства и функции.
- Чтобы наследники могли переопределять конкретные реализации свойств и функций, для них в абстрактном классе должен быть явно указан модификатор `open`.
- У абстрактного класса может быть конструктор.
- Интерфейс определяет поведение класса или общее поведение для группы независимых друг от друга классов.
- Нельзя создать экземпляр интерфейса.
- Интерфейс может содержать как абстрактные, так и конкретные реализации функций.
- Свойства интерфейсов могут быть абстрактными, а могут иметь `get()` методы.
- Класс может реализовывать несколько интерфейсов.
- Класс должен реализовывать все абстрактные свойства и функции, определённые в интерфейсе.
- Если интерфейс реализовывается абстрактным классом, то переопределение его абстрактных свойств и функций может быть передана наследникам абстрактного класса.
- Интерфейс может реализовывать другой интерфейс.

### PizzaCity — сеть пиццерий
[675ccefa5040133e8429e849](https://e-learn.petrocollege.ru/mod/url/view.php?id=345154)

https://wywiwyg.ru/learn_kotlin/Task-PizzaCity.html

Описать сеть пиццерий (две пиццерии минимум), которые имеют одинаковый ассортимент, но цены на один и тот же товар различен. Функционал пиццерий одинаков, но они могут иметь некоторые различия, связанные с местоположением. Пиццерии должны выводить некоторую статистику: например, сколько каких пицц и на какую сумму продали.

1. Создадим абстрактный класс, который описывает функционал любой пиццерии сети и принимает на входе цены на предполагаемый ассортимент.

    ![Pizza](./img/pizza_01.png)

2. Создали пиццерию в Санкт-Петербурге. Переопределили методы, которые есть в абстрактном классе.

    ![Pizza](./img/pizza_02.png)

3. Создали пиццерию в Москве. Переопределили методы, которые есть в абстрактном классе.

    ![Pizza](./img/pizza_03.png)

4. Не забываем считать, сколько каких пицц мы продали в Санкт-Петербурге.

    ![Pizza](./img/pizza_04.png)

5. Не забываем считать, сколько пицц мы продали в Москве.

    ![Pizza](./img/pizza_05.png)

6. Написали код для выбора города и обработки ошибки неправильного ввода.

    ![Pizza](./img/pizza_06.png)

7. Создали пиццерии для Москвы и Санкт-Петербурга. Указали для каждой цены на предлагаемый ассортимент.

    ![Pizza](./img/pizza_07.png)

8. Написали код, обрабатывающий выбор пиццы в Москве.

    ![Pizza](./img/pizza_08.png)

9. Обработали выбор пиццы в Санкт-Петербурге.

    ![Pizza](./img/pizza_09.png)

10. Оптимизируем наш код.

    ![Pizza](./img/pizza_10.png)

    ![Pizza](./img/pizza_10a.png)

    ![Pizza](./img/pizza_10b.png)

    ![Pizza](./img/pizza_10c.png)

    ![Pizza](./img/pizza_10d.png)

    ![Pizza](./img/pizza_10e.png)

11. Наш код теперь выглядит следующим образом.

    ![Pizza](./img/pizza_11.png)

    Кода стало намного меньше. Он стал более структурирован. Избавились от множества `if`-ов. Код легче читать. Убрались лишние переменные.

12. Создадим два интерфейса, которые будут различны для московских и санкт-петербургских пиццерий. В Санкт-Петербурге будут предлагать кофе к пицце, а в Москве будут давать скидку в 50 рублей, если покажешь фотографию чека.

    ![Pizza](./img/pizza_12.png)

13. Добавляем интерфейс в класс.

    ![Pizza](./img/pizza_13.png)

14. Переопределили метод `drinkSale()`.

    ![Pizza](./img/pizza_14.png)

15. Добавили интерфейс для класса `PizzaMoscow` и переопределили метод `showCheckPhoto()`.

    ![Pizza](./img/pizza_15.png)

16. Добавили вызов метода в зависимости от наличия определенного интерфеса.

    ![Pizza](./img/pizza_16.png)

17. Обернули выбор в бесконечный цикл.

    ![Pizza](./img/pizza_17.png)

    ![Pizza](./img/pizza_17a.png)

18. Сделали выход из программы.

    ![Pizza](./img/pizza_18.png)

19. Определили в классе `PizzaCity` метод для показа статистики.

    ![Pizza](./img/pizza_19.png)

20. Добавили в меню вызов статистики.

    ![Pizza](./img/pizza_20.png)

    ![Pizza](./img/pizza_20a.png)

21. Создали функцию для выбора дополнительных услуг.

    ![Pizza](./img/pizza_21.png)

    ![Pizza](./img/pizza_21a.png)

    ![Pizza](./img/pizza_21b.png)

22. Добавили функцию выбора дополнительной услуги после выбора пиццы.

    ![Pizza](./img/pizza_22.png)

    ![Pizza](./img/pizza_22a.png)

    ![Pizza](./img/pizza_22b.png)

    ![Pizza](./img/pizza_22c.png)

    ![Pizza](./img/pizza_22d.png)

    ![Pizza](./img/pizza_22e.png)

[Итоговый код](samples/07_Interfaces/PizzaCity/src/Main.kt)

Доработать программу добавив следующий функционал:
1. Учитывается количество показанных чеков и общая сумма скидок.
2. Учитывается количество проданных кофе и общая сумма выручки за кофе.
3. Выручка по пиццерии показывается с учетом скидок и проданных кофе.
4. Подсчитать в процентном соотношении, сколько человек показывают фотографию чека, а сколько – нет. Результат выводить на экран по запросу статистики.
5. Подсчитать в процентном соотношении, сколько человек покупают кофе, а сколько – отказываются. Результат вывести на экран по запросу статистики.
6. Выводить на экран статистику, показывающую, к какой пицце чаще покупают кофе. Статистику выводить в количественном и процентном видах.
7. Определить область видимости для параметров в классе PizzaCity, чтобы не было сообщений об ошибке.
8. Добавить еще одну пиццерию в другом городе, но она должна и делать скидку при предъявлении фотографии чека, и предлагать кофе. Также, в данной пиццерии, должны предлагать к пицце, на выбор, один из двух соусов. Цену соусов установить самостоятельно.
9. В статистику добавить количество проданных соусов и выручку за каждый из видов. Также итоговая сумма по данной пиццерии должна учитывать все скидки и выручку за дополнительные услуги.
10. Если пиццерия не предлагает какую-либо услугу, то статистика по этой услуге не показывается.

### Сеть пиццерий
[675d96245040133e8429e852](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345155)

Расширить функционал программы "Сеть пиццерий" согласно заданию на последнем слайде

**Доработать программу добавив следующий функционал:**

1. Учитывается количество показанных чеков и общая сумма скидок.
2. Учитывается количество проданных кофе и общая сумма выручки за кофе.
3. Выручка по пиццерии показывается с учетом скидок и проданных кофе.
4. Подсчитать в процентном соотношении, сколько человек показывают фотографию чека, а сколько – нет. Результат выводить на экран по запросу статистики.
5. Подсчитать в процентном соотношении, сколько человек покупают кофе, а сколько – отказываются. Результат вывести на экран по запросу статистики.
6. Выводить на экран статистику, показывающую, к какой пицце чаще покупают кофе. Статистику выводить в количественном и процентном видах.
7. Определить область видимости для параметров в классе PizzaCity, чтобы не было сообщений об ошибке.
8. Добавить еще одну пиццерию в другом городе, но она должна и делать скидку при предъявлении фотографии чека, и предлагать кофе. Также, в данной пиццерии, должны предлагать к пицце, на выбор, один из двух соусов. Цену соусов установить самостоятельно.
9. В статистику добавить количество проданных соусов и выручку за каждый из видов. Также итоговая сумма по данной пиццерии должна учитывать все скидки и выручку за дополнительные услуги.
10. Если пиццерия не предлагает какую-либо услугу, то статистика по этой услуге не показывается.

## Data class. Enum class
[678a91db5040133e8429ebca](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-8)

### Data классы
https://e-learn.petrocollege.ru/mod/url/view.php?id=345156

https://wywiwyg.ru/learn_kotlin/lesson08.html

В процессе разработки нам часто приходится создавать классы, предназначенные исключительно для хранения каких-либо данных. При этом, чтобы такой класс стал максимально удобным переопределяются методы `toString()`, `equals()` и `hashCode()`.

Обычно данные методы имеют одинаковую реализацию и чтобы каждый раз не писать один и тот же код можно просто отметить класс ключевым словом `data` — все необходимые методы будут сгенерированы автоматически. В Kotlin такие классы называются классами данных (data classes).

Не каждый класс можно отметить ключевым словом `data`. Для этого он должен соответствовать определённым требованиям:

- В основном конструкторе должен быть как минимум один параметр.
- Все параметры основного конструктора должны быть отмечены ключевыми слова `val` или `var` (рекомендуется `val`).
- Классы данных не могут быть отмечены ключевыми словами **`abstract`**, **`open`**, **`sealed`**, **`inner`**.

#### `toString()`
Часто, особенно при отладке, возникает необходимость вывести в лог информацию об экземпляре класса. Если метод `toString()` не переопределён, то при обращении к экземпляру в лог будет выведена ссылка на него.

![Data classes 01](./img/data_01.png)

Это не очень информативно и вряд ли чем-то поможет. Чтобы исправить ситуацию достаточно переопределить метод toString() и указать в нём, что именно нужно выводить в лог при обращении к экземпляру класса.

![Data classes 02](./img/data_02.png)

![Data classes 03](./img/data_03.png)

Если же мы отметим класс ключевым словом `data`, метод `toString()` будет переопределён автоматически. При этом в лог будут выводиться все поля, указанные в конструкторе, в порядке их добавления.

![Data classes 04](./img/data_04.png)

#### `equals()`
Иногда нам может потребоваться сравнить между собой два объекта таким образом, чтобы они считались равными, если содержат одни и те же данные.

![Data classes 05](./img/data_05.png)

Объекты не равны, потому что по умолчанию сравниваются не данные, которые они хранят, а ссылки на объекты. Чтобы задать свой алгоритм сравнения переопределяется метод `equals()`.

![Data classes 06](./img/data_06.png)

Если же мы отметим класс ключевым словом data, метод `equals()` будет переопределён автоматически. При этом работать будет точно также, как и в примере выше: будет проверять на равенство все значения, указанные в основном конструкторе.

![Data classes 07](./img/data_07.png)

Так как оператор `==` за кулисами вызывает метод `equals()`, для сравнения ссылок объектов используется оператор `===`.

![Data classes 08](./img/data_08.png)

#### `hashCode()`
Экземпляр класса можно использовать как ключ в структурах данных на основе хэш-функций. Это возможно благодаря тому, что каждому объекту присваивается уникальный хэш-код, даже если значения этих объектов идентичны.

Kotlin HashSet — это универсальная неупорядоченная коллекция элементов, не содержащая повторяющихся элементов. Он реализует установленный интерфейс.

**`hashSetOf ()`** — функция, возвращающая изменяемый hashSet, который можно как читать, так и записывать. Класс `HashSet` хранит все элементы, используя механизм хеширования.

<dfn title="хэш-набор">Хэш-набор</dfn> — это неупорядоченная коллекция уникальных элементов, обеспечивающая постоянную производительность при добавлении, удалении и проверке присутствия элемента.

Функция `contains()` возвращает `true`, если в коллекции/последовательности есть определенный элемент.

![Data classes 09](./img/data_09.png)

**Преимущества `hashSetOf()`**:
- Структура данных хэш-набора обеспечивает временную сложность O(1) для добавления, удаления и проверки наличия элемента, что делает ее очень эффективной для обработки больших наборов данных.
- Хэш-набор гарантирует уникальность элементов, поэтому он является хорошим выбором для отслеживания коллекции различных значений.
- Функция `hashSetOf()` проста в использовании и предоставляет простой способ создания нового хеш-набора с начальными элементами.

**Недостатки `hashSetOf()`**:
- Порядок элементов в хеш-наборе не гарантирован, поэтому порядок итерации может не совпадать с порядком вставки.
- Производительность хэш-набора может ухудшиться, если хеш-функция создает множество коллизий, из-за чего набор может работать медленнее, чем другие структуры данных, такие как массив или связанный список.

По логике, если два объекта содержат одинаковые значения, значит и хэш-код у них должен быть одинаковым. Для этого и переопределяется метод `hashCode()`.

![Data classes 10](./img/data_10.png)

Обратите внимание, что метод `hashCode()` работает совместно с методом `equals()`. Это означает, что если переопределить метод `hashCode()` без переопределения метода `equals()`, каждому объекту будет присвоен уникальный хэш-код, даже если значения этих объектов равны.

Связано это с тем, что перед присвоением хэш-кода происходит сравнение объектов. А без метода `equals()` объекты сравниваются по их ссылкам, а не значениям.

![Data classes 11](./img/data_11.png)

Опять же, чтобы обо всём этом не думать, достаточно отметить класс ключевым словом `data` и метод `hashCode()` (и все остальные) будет переопределён автоматически. При этом работать будет точно также, как и в примере выше: будет возвращать значение, зависящее от хэш-кодов всех свойств, объявленных в основном конструкторе.

![Data classes 12](./img/data_12.png)

#### `copy()`
Метод, который генерируется автоматически для всех классов данных. Он позволяет копировать экземпляры класса, изменяя значения некоторых свойств.

Разработчики Kotlin пытаются заложить нам в голову идею о том, что вместо модификации объекта лучше создать новый объект. Поэтому и была добавлена данная функция — упростить создание новых объектов.

![Data classes 13](./img/data_13.png)

![Data classes 14](./img/data_14.png)

#### Мультидекларации
Мультидекларации (destructuring declarations) — это особенность, характерная для классов данных, которая позволяет распаковать объект и использовать его значения для инициализации сразу нескольких переменных.

![Data classes 15](./img/data_15.png)

Достигается это все благодаря тому, что для каждой переменной, объявленной в основном конструкторе, автоматически генерируются функции `componentN()`, где `N` — номер позиции переменной в конструкторе. Что делает данная функция? Возвращает значение переменной. Такую функцию можно создать самому для класса, который не является классом данных.

![Data classes 16](./img/data_16.png)

#### Стандартные классы данных
В стандартной библиотеке Kotlin есть два класса данных: `Pair` и `Triple`. Из названий понятно, что они позволяют хранить две и три переменных разного типа одновременно.

https://blog.mindorks.com/pair-and-triple-in-kotlin/

#### Итоги
При компиляции Data класса компилятор автоматически добавляет в класс функции с определенной реализацией, которая учитывает свойства класса, которые определены в первичном конструкторе:
- `equals()`: сравнивает два объекта на равенство
- `hashCode()`: возвращает хеш-код объекта
- `toString()`: возвращает строковое представление объекта
- `copy()`: копирует данные объекта в другой объект

### Enum классы
В программировании иногда возникает необходимость, чтобы тип имел только определенные значения. Для этого было введено понятие перечисления. <dfn title="перечисление">Перечисление</dfn> — это именованный список констант.

В Котлине, как и во многих других языках программирования, перечисление имеет свой собственный специализированный тип, указывающий, что что-то имеет несколько возможных значений.

В отличие от перечислений Java, перечисления Kotlin являются классами.

**Некоторые важные моменты о классах перечислений в Котлине**:
- Константы перечислений — это не просто коллекции констант: у них есть свойства, методы и т. д.
- Каждая из констант перечисления действует как отдельный экземпляр класса и разделяется запятыми.
- Enums повышает читаемость вашего кода, присваивая константам заранее определенные имена.
- Экземпляр класса перечисления не может быть создан с помощью конструкторов.

Перечисления определяются с помощью ключевого слова `enum` перед классом следующим образом:
```kotlin
enum class DAYS {
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
}
```

В Kotlin перечисления также могут иметь конструктор, такой как перечисления Java. Поскольку константы перечисления являются экземплярами класса `Enum`, константы можно инициализировать, передав определенные значения основному конструктору.

![Enums 01](./img/enum_01.png)

#### Свойства и методы Enum классов
Как и в Java, и в других языках программирования, классы перечислений Kotlin имеют некоторые встроенные свойства и функции, которые может использовать программист.

**Свойства**:
- `ordinal`: это свойство хранит порядковое значение константы, которая обычно представляет собой индекс, отсчитываемый от нуля.
- `name`: это свойство хранит имя константы.

**Методы**:
- `values`: этот метод возвращает список всех констант, определенных в классе перечисления.
- **`valueOf`**: этот метод возвращает константу перечисления, определенную в перечислении, соответствующую входной строке. Если константа отсутствует в перечислении, создается исключение `IllegalArgumentException`.

![Enums 02](./img/enum_02.png)

![Enums 03](./img/enum_03.png)

#### Enum классы
Поскольку класс enum в Котлине определяет новый тип то он может иметь свои собственные свойства и функции.

Свойствам можно присвоить значение по умолчанию, однако, если оно не указано, каждая константа должна определять свое собственное значение для свойства. В случае функций они обычно определяются внутри сопутствующих объектов, чтобы не зависеть от конкретных экземпляров класса. Однако их можно определить и без сопутствующих объектов.

![Enums 04](./img/enum_04.png)

#### Перечисления как анонимные классы
Константы Enum класса также ведут себя как анонимные классы, реализуя свои собственные функции и переопределяя абстрактные функции класса. Самое главное, что каждая константа перечисления должна быть переопределена.

![Enums 05](./img/enum_05.png)

#### Использование выражения When с классом перечисления
Большое преимущество классов перечислений в Котлине проявляется, когда они объединены с выражением `When`.

Преимущество заключается в том, что классы перечислений ограничивают значение, которое может принимать тип, поэтому при использовании с выражением `if` и определением всех констант необходимость в предложении `else` полностью устраняется.

Фактически, это приведет к появлению предупреждения от компилятора.

![Enums 06](./img/enum_06.png)

### Философы
[679f8e375040133e8429ed86](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345157)

Как минимум выполнить одну задачу из предложенного списка.

#### Задание 1
За круглым столом сидит некоторое количество философов (задается при запуске программы). Между ними лежат вилки. По команде каждый из философов пытается взять случайным образом вилку или справа, или слева от него. Если какая-либо вилка будет занята, то философ пытается взять вилку с другой стороны. Философы берут вилки последовательно. То есть сперва один выбирает вилку, потом другой и т.д. Кто из философов начнет выбирать вилку определяется случайным образом. Философ, который уже взял вилку, не участвует в дальнейших выборах. После того, как все философы попытаются взять вилку необходимо вывести на консоль информацию о том, кто обедает, а кто размышляет (ему не досталась вилка). Как вы понимаете, философу может не достаться вилка в том случае, если сидящий справа от него возьмет вилку слева, а сидящий слева — возьмет вилку справа. Но может и случиться такая ситуация, что все философы будут обедать

#### Задание 2
За круглым столом сидит некоторое количество философов (задается при запуске программы). Между ними лежат палочки для еды. Обедать можно только используя две палочки. По команде каждый из философов пытается взять палочки и справа и слева от него. Если какая-либо палочка будет занята, то философ может только размышлять. Он не может обедать. Философы берут палочки последовательно. То есть сперва один берет палочки, потом другой и т.д. Кто из философов начнет брать палочки определяется случайным образом. Философ, который уже взял палочки, не участвует в дальнейших выборах. После того, как все философы попытаются взять палочки необходимо вывести на консоль информацию о том, кто обедает, а кто размышляет (ему не достались палочки).

### Мой банк
[67cec40d5040133e8429f159](https://e-learn.petrocollege.ru/mod/assign/view.php?id=352490)

Создать приложение, реализующее следующий функционал

1. Пользователь может создать несколько банков
2. Пользователь может создать несколько физлиц
3. Банк обладает следующими свойствами: наименование банка (полное и краткое)
4. Физлицо имеет следующие свойства: ФИО, ИНН, номер паспорта, серия паспорта
5. Любой банк имеет следующие виды банковских счетов:
   - текущий счет (используется для пополнения и снятия с него денежных средств физлицами)
   - кредитный счет (используется физлицами для выплаты обязательств по кредиту)
   - депозитный счет (используется физлицами для хранения вкладов и получения дохода)
6. Каждый банк устанавливает свой процент на остаток средств по текущему счету (от 0.1% до 2% годовых). Процент одинаков для любого клиента банка. Проценты начисляются ежемесячно, первого числа, на минимальный остаток в прошедшем месяце или периоде, если счет открывался не первого числа, и зачисляются на текущий счет
7. В случае закрытия текущего счета до истечения месяца проценты начисляются на минимальный остаток в прошедшем периоде
8. Любое физлицо может открыть до трех текущих счетов в каждом из имеющихся банков
9. Физлицо может переводить денежные средства между своими текущими счетами, как в пределах одного банка, так и между банками
10. Любой клиент банка может внести денежные средства в любой сумме на текущий счет и снять их с текущего счета в пределах имеющегося остатка
11. Физлицо может открыть не более одного депозитного счета в каждом из имеющихся банков. При открытии указывается срок депозита (не менее 3-х месяцев), минимальный остаток, пополняемый или не пополняемый, можно с него снимать денежные средства или нет, годовая процентная ставка (от 18% до 25%, может быть различна для разных пользователей даже в пределах одного банка), проценты начисляются ежедневно и с учетом капитализации (в конце текущих суток) или ежемесячно (в последний день месяца), пролонгируемый или не пролонгируемый
12. Депозит с ежедневным начислением процентов всегда является пополняемым
13. Зачисление на депозитный счет может производиться только с текущего счета физлица
14. Ежедневная капитализация обозначает, что начисленные за день проценты участвуют при расчете суммы процентов за следующий день
15. При ежедневном начислении проценты зачисляются первого числа следующего месяца за предыдущий месяц или период от даты открытия депозита, если депозит открывался не первого числа на депозитный счет
16. При ежемесячном начислении сумма процентов вычисляется первого числа следующего месяца на минимальный остаток в прошедшем месяце и зачисляется на депозитный счет в случае, если депозит пополняемый. В случае не пополняемого депозита сумма процентов зачисляется на депозитный счет на следующий день после окончания срока депозита
17. Если депозит открылся не первого числа прошедшего месяца, то сумма процентов вычисляется исходя из периода и условий депозита. В случае ежемесячного начисления процентов их сумма вычисляется пропорционально периода от даты открытия депозита до первого числа следующего месяца на минимальный остаток в прошедшем периоде
18. Если срок окончания депозита не последнее число месяца, то сумма процентов вычисляется пропорционально периода от первого числа месяца закрытия до числа закрытия в случае ежемесячного начисления процентов
19. Физлицо может переводить деньги на депозитные счета со своих текущих счетов, если это не противоречит условиям депозита
20. Если с депозита, имеющего запрет на снятие денежных средств, снимаются деньги, то процент пересчитывается исходя из процентной ставки годовых для текущего счета в данном банке. Денежные средства в данном случае должны сняться полностью
21. Если на депозите, имеющем разрешение на снятие, после снятия денежных средств остается меньше минимального остатка, то депозит закрывается и физлицу выдается вся имеющаяся сумма с учетом процентов
22. В случае окончания срока пролонгируемого депозита данный депозит автоматически продлевается на условиях, при которых он открывался
23. В случае окончания срока не пролонгируемого депозита, если у физлица имеется текущий счет в данном банке, то денежные средства с депозитного счета автоматически переводятся на любой текущий счет (если их несколько)
24. В случае окончания срока не пролонгируемого депозита, если у физлица не имеется текущий счет в данном банке, то депозитный счет автоматически становится текущим с условиями данного банка
25. Любое физлицо может взять не более одного кредита в любом из имеющихся банков. При получении кредита указывается сумма кредита, процент кредита, срок (количество полных месяцев) пользования кредитом, дата взятия кредита
26. Сумма платежа по кредиту рассчитывается как сумма кредита, деленная на количество месяцев плюс сумма процентов на остаток до вычета из тела кредита
27. Кредиты можно гасить досрочно частично или полностью
28. Кредит гасится путем внесения денежных средств с любого текущего счета физлица
29. При частичном погашении сперва гасятся набежавшие на день платежа проценты, остаток от внесенной суммы вычитается из основного долга. Остаток кредита делится на количество оставшихся месяцев
30. Частичное погашение кредита не уменьшает сумму платежа по кредиту в оговоренный день (дата взятия кредита), если досрочное погашение произошло до даты очередного платежа

Пользователь должен иметь возможность получать следующие отчеты

1. Наличие текущих счетов и остатков на них у физлица
2. Наличие кредитных счетов и остатков по ним у физлица
3. Наличие депозитных счетов и остатков на них у физлица

При открытии депозитного счета физлицо получает информацию о предполагаемом доходе

При открытии кредитного счета (взятии кредита) физлицо получает информацию о возможной переплате (сумме процентов) и график погашения кредита

При частичном досрочном погашении кредита физлицо получает информацию об остатке кредита и новый график погашения кредита

Перед полным погашением кредита физлицо получает информацию о сумме платежа, где учитывается остаток основного долга и проценты за пользование кредитом, рассчитанные пропорционально срока с момента последнего платежа

### Пример распределения при использовании одной вилки
[67d0592a5040133e8429f181](https://e-learn.petrocollege.ru/mod/url/view.php?id=345158)

Нажмите на ссылку https://rutube.ru/video/private/55a57f24ef7946ba1b9a35928c9db0f5/?p=sUV-K88iWWDSLw40ZBfViQ, чтобы открыть ресурс.

### Пример распределения при использовании двух палочек
[67d305195040133e8429f1a3](https://e-learn.petrocollege.ru/mod/url/view.php?id=345159)

Нажмите на ссылку https://rutube.ru/video/private/991a7c8bb60a8927e849e063ad2e98e1/?p=HBBAE3I0Lmh8e-Ckbj0oVw, чтобы открыть ресурс.

## 09 Coroutines
[67cec4945040133e8429f15a](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-9)

### Корутины
[687fc5e863e4ad8e0adf4122](https://e-learn.petrocollege.ru/mod/url/view.php?id=345160)

https://wywiwyg.ru/learn_kotlin/lesson09.html

#### Зачем нужны асинхронность и параллельные вычисления?
Параллельные вычисления позволяют выполнять несколько задач одновременно, а асинхронность позволяет не блокировать основной ход приложения во время выполнения задачи, которая занимает продолжительное время. 

В языке Kotlin поддержка асинхронности и параллельных вычислений воплощена в виде корутин (coroutine). По сути корутина представляет блок кода, который может выполняться параллельно с остальным кодом.А базовая функциональность, связанная с корутинами, сосредоточена в библиотеке `kotlinx.coroutines`.

Функциональность корутин (библиотека `kotlinx.coroutines`) по умолчанию не включена в проект. Если мы создаем проект консольного приложения в IntelliJ IDEA, то мы можем добавить соответствующую библиотеку в проект. Для этого в меню File перейдем к пункту *Project Structure*.

![Coroutines 01](./img/coroutines_01.png)

Далее на вкладке "Project Settings" перейдем к пункту *Libraries*. В центральном поле отобразятся библиотеки, добавленные в проект. И для добавления новой библиотеки нажмем на знак плюса и в контекстном меню выберем пункт *From Maven...*

![Coroutines 02](./img/coroutines_02.png)

Откроется окно для добавления библиотеки через Maven. В этом окне в поле ввода введем название нужной нам библиотеки — kotlinx-coroutines-core-jvm и нажмем на кнопку поиска. Если соответствующая библиотека найдена, то нам отобразится выпадающий список с результатами.

![Coroutines 03](./img/coroutines_03.png)

Выберем из него последнюю версию, которая называется наподобие org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm:1.7.3 — в данном случае используется версия 1.7.3, но конкретный номер версии может отличаться.

Отметим все необходимые флажки и нажмем на кнопку OK.

![Coroutines 04](./img/coroutines_04.png)

После установки библиотеки мы сможем найти ее файл в списке библиотек.

![Coroutines 05](./img/coroutines_05.png)

Рассмотрим пример, который не использует корутины.

![Coroutines 06](./img/coroutines_06.png)

Модификатор `suspend` определяет функцию, которая может приостановить свое выполнение и возобновить его через некоторый период времени.

Чтобы использовать внутри функции `main` функцию `delay()`, функция `main` предваряется модификатором `suspend`.

Сама функция `delay()` тоже является подобной функцией, которая определена с модификатором `suspend`. А любая функция с модификатором `suspend` может вызываться либо из другой функции, которая тоже имеет модификатор `suspend`, либо из корутины.

![Coroutines 07](./img/coroutines_07.png)

#### Вынесение кода корутин в отдельную функцию
Вынесем продолжительную работу, то есть цикл, в корутину.

![Coroutines 08](./img/coroutines_08.png)

Прежде всего, для определения и выполнения корутины нам надо определить для нее контекст, так как корутина может вызываться только в **контексте корутины** (coroutine scope). Для этого применяется функция `coroutineScope()` — создает контекст корутины. Кроме того, эта функция ожидает выполнения всех определенных внутри нее корутин. Стоит отметить, что `coroutineScope()` может применяться только в функции с модификатором `suspend`, коей является функция `main`. Сама корутина определяется и запускается с помощью построителя корутин — функции `launch`. Она создает корутину в виде блока кода `launch` запускает эту корутину параллельно с остальным кодом. То есть данная корутина выполняется независимо от прочего кода, определенного в функции `main`.

![Coroutines 09](./img/coroutines_09.png)

![Coroutines 10](./img/coroutines_10.png)

#### Корутины и потоки
В ряде языков программирования есть такие структуры, которые позволяют использовать потоки. Однако между корутинами и потоками нет прямого соответствия.

**Корутина не привязана к конкретному потоку.** Она может приостановить выполнение в одном потоке, а возобновить выполнение в другом.

Когда корутина приостанавливает свое выполнение, например, как в случае выше при вызове задержки с помощью функции `delay()`, эта корутина освобождает поток, в котором она выполнялась, и сохраняется в памяти. А освобожденный поток может быть задействован для других задач. А когда завершается запущенная задача (например, выполнение функции `delay()`), корутина возобновляет свою работу в одном из свободных потоков.

#### Различия между корутинами и потоками
Многозадачность с использованием корутин легко перепутать с многопоточностью. Это выполнение программы в нескольких системных потоках.

Поток — составная часть процесса, который выполняется в операционной системе. Принцип похож: несколько потоков останавливаются и возобновляются, ждут друг друга, общаются. Но есть отличия.

- Потоками управляет операционная система. Переключением корутин — разработчик с помощью кода.
- Переключение потоков сложно контролировать. Корутины контролируются более гибко.
- Потоки отнимают много ресурсов процессора — ему постоянно приходится переключаться между ними. Корутины не требуют переключения контекста, поэтому код потребляет мало ресурсов.
- Потоки выполняются на аппаратном или системном уровне. Корутины — более высокоуровневое решение. Это значит, что они дальше от системы и аппаратных ресурсов, зато ближе к человеческим понятиям.
- Потоки ускоряют выполнение сложной задачи, но отнимают много ресурсов. Корутины не повышают скорость, но помогают оптимизировать нагрузку.
- Корутины выполняются в рамках одного потока или пула потоков.

#### Преимущества использования корутин
1. **Легковесность**: Корутины имеют более низкий уровень накладных расходов по сравнению с потоками. В отличие от потоков, которые требуют выделения отдельного стека и контекстного переключения, корутины используют общий поток выполнения, что делает их более легковесными и экономичными в плане ресурсов.
2. **Асинхронность и удобство программирования**: Корутины облегчают написание асинхронного кода. Они позволяют написать последовательный код, который приостанавливается при выполнении долгих операций ввода-вывода или ожидании результатов других задач. Это улучшает читаемость и поддерживаемость кода, так как не требуется использование сложных конструкций обратных вызовов или цепочек промисов.
3. **Управление потоком выполнения**: Корутины позволяют легко управлять потоком выполнения. Вы можете приостанавливать, возобновлять и передавать управление между корутинами в явном виде, что делает код более понятным и позволяет эффективно управлять конкурентными задачами.
4. **Обработка ошибок**: Корутины обладают мощными механизмами обработки ошибок. Они предоставляют конструкции для обработки исключений и отмены операций, позволяя удобно обрабатывать ошибки и сбои в асинхронном коде.
5. **Интеграция с экосистемой**: В некоторых языках программирования, таких как Kotlin, корутины являются частью официальной стандартной библиотеки или стандарта языка. Они широко поддерживаются и интегрируются с другими библиотеками и фреймворками, что облегчает разработку асинхронных приложений.
6. **Параллелизм и масштабируемость**: Корутины позволяют создавать параллельные задачи и обрабатывать их эффективно. Можно запускать множество корутин и автоматически распределять их выполнение по доступным ресурсам, что позволяет достичь более высокой производительности и масштабируемости.

#### Недостатки сопрограмм
1. **Сложность отладки**: Поскольку корутины выполняются асинхронно и могут приостанавливаться и возобновляться в разных местах, отладка кода, содержащего корутины, может быть сложной. Трассировка стека может быть запутанной, особенно при сложных сценариях взаимодействия между корутинами.
2. **Возможность утечек ресурсов**: Если корутина неправильно управляет ресурсами, такими как открытые файлы или сетевые соединения, это может привести к утечкам ресурсов. Корутины должны быть аккуратно управляемыми и освобождать ресурсы при завершении.
3. **Затраты на память**: Каждая корутина требует дополнительных ресурсов памяти для сохранения своего состояния и контекста выполнения. При большом количестве корутин это может потребовать дополнительного объема памяти.
4. **Потенциальные проблемы с синхронизацией**: Если необходимо обеспечить синхронизацию доступа к общим ресурсам из разных корутин, это может потребовать использования механизмов синхронизации, таких как блокировки или атомарные операции. Неправильное использование синхронизации может привести к проблемам с состоянием гонки или блокировками.
5. **Необходимость библиотеки поддержки**: В большинстве языков программирования для работы с корутинами требуется использование специальной библиотеки, что может добавить зависимости к проекту и усложнить его сборку и обслуживание.

#### Несколько случаев, когда применение корутин может быть особенно полезным
1. **Асинхронные операции ввода-вывода**: Корутины отлично подходят для выполнения асинхронных операций ввода-вывода, таких как сетевые запросы, операции с базой данных или файловой системой. Они позволяют писать последовательный и понятный код, который приостанавливается во время ожидания результатов операций ввода-вывода.
2. **Параллельные задачи**: Корутины позволяют легко запускать параллельные задачи и управлять их выполнением. Вы можете запускать несколько корутин одновременно и асинхронно ожидать их завершения. Это особенно полезно при выполнении независимых операций, таких как параллельная обработка данных или обращение к нескольким сервисам одновременно.
3. **Цепочки обработки данных**: Они позволяют создавать удобные цепочки обработки данных. Вы можете использовать корутины для пошаговой обработки больших объемов данных без блокирования основного потока выполнения. Это особенно полезно при обработке потоков данных, таких как чтение из файлов, обработка и агрегация данных.
4. **Обработка событий**: Корутины могут быть эффективным инструментом для обработки событий, таких как пользовательский ввод, события сети или сигналы операционной системы. Вы можете использовать корутины для асинхронного ожидания и обработки событий, сокращая сложность кода по сравнению с традиционными обратными вызовами или циклами событий.
5. **Таймауты и отмена операций**: Они предоставляют удобные средства для работы с таймаутами и отменой операций. Вы можете использовать механизмы отмены корутин для прерывания долгих операций или установки временных ограничений на выполнение.
6. **Тестирование и отладка**: Корутины облегчают тестирование и отладку асинхронного кода. Вы можете управлять выполнением корутин, приостанавливать и возобновлять их для проверки различных состояний и вариантов выполнения. Это делает код более предсказуемым и тестируемым.

#### Ситуации, когда использование корутин может быть нежелательным или нецелесообразным
1. **Ограниченные ресурсы**: Если у вас есть ограниченное количество ресурсов, таких как потоки или память, и требуется создание огромного количества корутин, это может привести к исчерпанию ресурсов и снижению производительности системы. В таких случаях, использование потоков может быть более подходящим, поскольку они обычно имеют более прямое соответствие с ресурсами операционной системы.
2. **Большие объемы вычислений**: Если вам требуется выполнить вычисления, которые являются вычислительно интенсивными и занимают значительное время процессора, корутины могут не быть самым эффективным решением. В таких случаях использование многопоточности и распределенных вычислений может быть предпочтительнее.
3. **Большой объем данных**: Если вам нужно обрабатывать большие объемы данных, которые не умещаются в память, корутины могут быть не самым подходящим инструментом. Вместо этого, использование потоков и пакетной обработки данных может быть более эффективным.
4. **Интерфейсы с блокирующими операциями**: Если вам нужно работать с внешними интерфейсами, которые требуют блокирования при выполнении операций ввода-вывода, например, синхронные вызовы баз данных или сетевые запросы, то использование корутин может не принести существенных преимуществ. В этом случае можно использовать асинхронные API или потоки.
5. **Сложность программы**: Если ваша программа уже достаточно сложная и содержит сложную логику с параллельными или конкурирующими задачами, использование корутин может усложнить код и управление его состоянием. В таких случаях, возможно, более простые абстракции, такие как потоки или асинхронные функции, могут быть предпочтительнее.

#### Область корутины
Корутина может выполняться только в определенной области корутины (coroutine scope). Область корутин представляет пространство, в рамках которого действуют корутины, она имеет определенный жизненный цикл и сама управляет жизненным циклом создаваемых внутри нее корутин. Для создания области корутин в Kotlin может использоваться ряд функций, которые создают объект интерфейса `CoroutineScope`.

![Coroutines 11](./img/coroutines_11.png)

#### Запуск нескольких корутин

![Coroutines 12](./img/coroutines_12.png)

Кроме функции **`coroutineScope`** для создания контекста корутины может применяться функция **`runBlocking`**.

![Coroutines 13](./img/coroutines_13.png)

Функция `runBlocking` блокирует вызывающий поток, пока все корутины внутри вызова `runBlocking{ ... }` не завершат свое выполнение.

В этом собственно основное отличие `runBlocking` от `coroutineScope`: `coroutineScope` не блокирует вызывающий поток, а просто приостанавливает выполнение, освобождания поток для использования другими ресурсами.

#### Вложенные корутины

![Coroutines 14](./img/coroutines_14.png)

#### launch и job
Для создания корутины нужен построитель корутин. И одним из построителей корутин в пакете `kotlinx.coroutines` является функция `launch`. Прежде всего, `launch()`, как правило, применяется, когда нам не надо возвращать результат из корутины и когда нам ее надо выполнять одновременно с другим кодом.

Построитель корутин `launch` возвращает объект `Job`, с помощью которого можно управлять запущенной корутиной.

Например, его метод `join()` позволяет ожидать, пока корутина не завершится. Например, мы получим следующий результат, если не будем применять интерфейс Job.

![Coroutines 15](./img/coroutines_15.png)

Здесь корутина также запускается с помощью `launch`, однако благодаря методу `join()` полученного объекта `Job` функция `main` остановит выполнение и будет ожидать завершения корутины и только после ее завершения продолжит работу. Соответственно в данном случае консольный вывод будет иным.

![Coroutines 16](./img/coroutines_16.png)

#### Отложенное выполнение
По умолчанию построитель корутин `launch` создает и сразу же запускает корутину. Однако Kotlin также позволяет применять технику отложенного запуска корутины (lazy-запуск), при котором корутина запускается при вызове метода `start()` объекта `Job`.

Для установки отложенного запуска в функцию `launch()` передается значение `start = CoroutineStart.LAZY`.

Чтобы увидеть разницу, сначала возьмем корутину со стандартным выполнением:

![Coroutines 17](./img/coroutines_17.png)

Применим отложенное выполнение.

Теперь корутина только создается с помощью функции `launch`, но непосредственно она запускается только при вызове метода `job.start()`, соответственно мы получим другой результат программы.

![Coroutines 18](./img/coroutines_18.png)

### Звонок
[687fe7b363e4ad8e0adf412a](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345161)

Как минимум выполнить одну задачу из предложенного списка.

#### Задание 1
- Создать три будильника которые начинают работать одновременно. Но первый будильник прозвенит через 5 секунд, второй — через 7, третий — через 10 секунд. После начала работы каждый из будильников каждую секунду производит только ему присущий звук. После того, как будильник прозвенит, он перестает тикать.

#### Задание 2
- Решить первую задачу, но время, через которое прозвенит каждый из будильников, задается через консоль.

### Пример вывода на консоль
[68807e0863e4ad8e0adf412d](https://e-learn.petrocollege.ru/mod/url/view.php?id=345162)

Нажмите на ссылку https://wywiwyg.ru/learn_kotlin/Bombe.png, чтобы открыть ресурс.

![Bombe](./img/Bombe.png)

## 10 Установка, настройка и интерфейс Android Studio
[67cec4b65040133e8429f15b](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-10)

### Файловая структура Android Studio
[68831dd263e4ad8e0adf4176](https://e-learn.petrocollege.ru/mod/page/view.php?id=345163)

Структура папок проекта Android Studio: в Android Studio существует два типа представления файловой структуры проекта. Один из них — Android View (обобщенный), другой — Project View (подробный). Большинство новичков используют Android View (обобщенный). Взгляните на следующее изображение, чтобы увидеть различия между этими представлениями.

#### Структура папок проекта Android
Проект Android содержит различные типы модулей приложений, файлы исходного кода и файлы ресурсов. Мы рассмотрим все папки и файлы в приложении для Android.

1. Папка манифестов
2. Папка *Java*
3. Папка *res* (Ресурсы)
   1. Папка для рисования
   2. Папка макета
   3. Папка *Mipmap*
   4. Папка значений
4. Сценарии Gradle
5. Папка манифестов

Папка манифестов содержит *AndroidManifest.xml* для создания нашего приложения для Android. Этот файл содержит информацию о нашем приложении, такую как версия Android, метаданные, пакет состояний для файла Kotlin и другие компоненты приложения. Он выступает в качестве посредника между ОС Android и нашим приложением.

Эта папка отвечает за хранение файла манифеста приложения, в котором просматривается бизнес-логика основного приложения (Java / Kotlin), файлы для рисования (изображения, векторная графика), файлы макета пользовательского интерфейса приложения, mipmap (файлы значков приложения), цвета (фирменный цвет приложения), строки (все тексты, используемые для локализации приложения), стили (предопределенные или определяемые пользователем стили приложения), файл gradle на уровне приложения (управление зависимостями). Чтобы узнать больше о файловой структуре приложения, прочитайте: Файловая структура приложения Android

Файл манифеста приложения: Файл манифеста является важной частью нашего приложения, поскольку он определяет структуру и метаданные нашего приложения, его компоненты и требования. Этот файл содержит узлы для каждого из действий, служб, поставщиков контента и широковещательного приемника, которые создают приложение, и, используя фильтры намерений и разрешения, определяют, как они координируются друг с другом и другими приложениями. Чтобы получить больше информации о манифесте Android, прочитайте: Файл манифеста приложения. Типичный очень простой файл манифеста выглядит следующим образом:

#### Папка Java
Папка *Java* содержит все файлы исходного кода java и Kotlin (.java), которые мы создаем во время разработки приложения, включая другие тестовые файлы. Если мы создадим какой-либо новый проект с использованием Kotlin, по умолчанию файл класса *MainActivity.kt* будет создан автоматически под именем пакета, как показано ниже.

#### Папка ресурсов (*res*)
Папка ресурсов является самой важной папкой, поскольку она содержит все некодовые источники, такие как изображения, XML-макеты и строки пользовательского интерфейса для нашего приложения Android.

##### папка *res* / *drawable*
Он содержит различные типы изображений, используемых для разработки приложения. Нам нужно добавить все изображения в папку для рисования для разработки приложения.

##### папка *res* / *layout*
Папка *layout* содержит все файлы XML-макетов, которые мы использовали для определения пользовательского интерфейса нашего приложения. Он содержит *activity_main.xml* досье.

##### папка *res* / *mipmap*
Эта папка содержит *launcher.xml* файлы для определения значков, которые используются для отображения на главном экране. Он содержит различные типы значков плотности в зависимости от размера устройства, такие как hdpi, mdpi, xhdpi.

##### папка *res* / *values*
Папка *Values* используется для хранения значений ресурсов, которые используются во многих проектах Android для включения функций цвета, стилей, размеров и т.д. Ниже приведены несколько основных файлов, содержащихся в папке *res* / *values*: *colors.xml* : В *colors.xml* это XML-файл, который используется для хранения цветов для ресурсов. Проект Android содержит 3 основных цвета, а именно:
- `colorPrimary`
- `colorPrimaryDark`
- `colorAccent`

Эти цвета также используются в некоторых предопределенных ресурсах Android studio. Эти цвета по мере необходимости должны быть непрозрачными, иначе это может привести к возникновению некоторых исключений.

##### Папка скриптов Gradle
Gradle означает автоматизированную систему сборки и содержит ряд файлов, которые используются для определения конфигурации сборки, которая может быть применена ко всем модулям нашего приложения. В *build.gradle* (Project) есть buildscripts, а в *build.gradle* (Module) плагины и реализации используются для создания конфигураций, которые могут быть применены ко всем модулям нашего приложения.

##### файл *build.gradle*:
Gradle — это система сборки (с открытым исходным кодом), которая используется для автоматизации сборки, тестирования, развертывания и т.д. Каждому проекту Android требуется Gradle для создания apk из файлов .java и .xml в проекте. Он расположен в корневом каталоге проекта, и его основная функция заключается в определении конфигураций сборки, которые будут применяться ко всем модулям в проекте.

##### Папка *Assets*:
Ресурсы позволяют добавлять в приложение произвольные файлы, такие как текст, XML, HTML, шрифты, музыку и видео. Если кто-то попытается добавить эти файлы в качестве “ресурсов“, Android обработает их в своей системе ресурсов, и вы не сможете получить исходные данные. Папка Assets создается самостоятельно, при необходимости. Ниже вы можете увидеть таблицу, позволяющую понять, когда необходимо создавать папку *Assets*

Scenario | Assets Folder | Res/Raw Folder
-- | -- | --
Гибкое имя файла | YES | NO
Хранить в подкаталоге | YES | NO
Проверка во время компиляции | NO | YES
Список имен файлов во время выполнения | YES | NO
Имя файла, доступное из XML | NO | YES

##### Папка ресурсов *Raw*:
Папка *raw* в Android используется для хранения файлов mp3, mp4, sfb и т. Д. Папка raw создается внутри папки *res*: *main/res /raw*. Поэтому мы просто создадим его внутри папки *res*. Папка *raw* (*res* / *raw*) является одной из самых важных папок и играет очень важную роль при разработке проектов Android в Android studio. Но прежде чем создавать папку *raw*, давайте посмотрим на папку ресурсов в Android, которая выполняет ту же роль, что и папка *raw* в Android Studio. Рекомендации для папки *raw* те же, что и для папки *Assets*.

##### Окно Logcat:
Окно *Logcat* — это место, где при запуске приложения можно печатать различные сообщения. Предположим, вы запускаете свое приложение, и, к сожалению, программа выходит из строя. Затем окно *Logcat* поможет вам отладить вывод, собирая и просматривая все сообщения, которые выдает ваш эмулятор.

##### *debug.keystore* file:
Это один из самых важных файлов, который присутствует практически в каждом приложении, когда мы загружаем это приложение из магазина Google Play. Этот файл в основном рассматривается как сертификат любого приложения, которое проверяется Google каждый раз. Каждое приложение, которое вы используете на своем телефоне, должно быть подписано. Ключ отладки — это случайно сгенерированный сертификат, который генерируется вашими инструментами сборки при первом использовании и будет автоматически использоваться для подписи при создании отладочного apk. Это немного похоже на то, что мы создаем при создании сертификата APK-версии.

*Предварительное условие: у вас должен быть готов проект Android Studio, с помощью которого мы сможем найти вашу отладку.файл хранилища ключей.*

---

## 19 01 Основы XML-разметки пользовательского интерфейса. FrameLayout, LinerLayout, GridLayout

### ЛЕКЦИЯ - 01
[687ddab863e4ad8e0adf40f1](https://e-learn.petrocollege.ru/mod/url/view.php?id=345177)

https://wywiwyg.ru/learn_kotlin/MAD/second_semester/lecture-01/?page=1

Существует три способа создания разметки
1. Стандартный – XML-файлы
2. Программный
3. Jetpack Compose

Для определения визуального интерфейса в проектах под Android используются специальные файлы xml. Эти файлы являются ресурсами разметки и хранят определение визуального интерфейса в виде кода XML. Подобный подход напоминает создание веб-сайтов, когда интерфейс определяется в файлах html, а логика приложения — в коде javascript.

Объявление пользовательского интерфейса в файлах XML позволяет отделить интерфейс приложения от кода. Что означает, что мы можем изменять определение интерфейса без изменения кода java. Например, в приложении могут быть определены разметки в файлах XML для различных ориентаций монитора, различных размеров устройств, различных языков и т.д. Кроме того, объявление разметки в XML позволяет легче визуализировать структуру интерфейса и облегчает отладку.

Файлы разметки графического интерфейса располагаются в проекте в каталоге *res/layout*. По умолчанию при создании проекта с пустой activity уже есть один файл ресурсов разметки *activity_main.xml*, который может выглядеть примерно так:

![Markup basics 01](./img/markup_basics_01.jpg)

![Markup basics 02](./img/markup_basics_02.jpg)

![Markup basics 03](./img/markup_basics_03.jpg)

![Markup basics 04](./img/markup_basics_04.jpg)

![Markup basics 05](./img/markup_basics_05.jpg)

![Markup basics 06](./img/markup_basics_06.jpg)

![Markup basics 07](./img/markup_basics_07.jpg)

![Markup basics 08](./img/markup_basics_08.jpg)

![Markup basics 09](./img/markup_basics_09.jpg)

![Markup basics 10](./img/markup_basics_10.jpg)

![Markup basics 11](./img/markup_basics_11.jpg)

![Markup basics 12](./img/markup_basics_12.jpg)

![Markup basics 13](./img/markup_basics_13.jpg)

![Markup basics 14](./img/markup_basics_14.jpg)

![Markup basics 15](./img/markup_basics_15.jpg)

![Markup basics 16](./img/markup_basics_16.jpg)

![Markup basics 17](./img/markup_basics_17.jpg)

![Markup basics 18](./img/markup_basics_18.jpg)

![Markup basics 19](./img/markup_basics_19.jpg)

![Markup basics 20](./img/markup_basics_20.jpg)

![Markup basics 21](./img/markup_basics_21.jpg)

![Markup basics 22](./img/markup_basics_22.jpg)

![Markup basics 23](./img/markup_basics_23.jpg)

При разработке приложений под Android мы можем использовать различные типы измерений:
- **px**: пиксели текущего экрана. Однако эта единица измерения не рекомендуется, так как реальное представление внешнего вида может изменяться в зависимости от устройства; каждое устройство имеет определенный набор пикселей на дюйм, поэтому количество пикселей на экране может также меняться.
- **dp**: (density-independent pixels) независимые от плотности экрана пиксели. Абстрактная единица измерения, основанная на физической плотности экрана с разрешением 160 dpi (точек на дюйм). В этом случае 1dp = 1px. Если размер экрана больше или меньше, чем 160dpi, количество пикселей, которые применяются для отрисовки 1dp соответственно увеличивается или уменьшается. Например, на экране с 240 dpi 1dp=1,5px, а на экране с 320dpi 1dp=2px. Общая формула для получения количества физических пикселей из dp: px = dp * (dpi / 160).
- **sp**: (scale-independent pixels) независимые от масштабирования пиксели. Допускают настройку размеров, производимую пользователем. Рекомендуются для работы со шрифтами.
- **pt**: 1/72 дюйма, базируются на физических размерах экрана.
- **mm**: миллиметры.
- **in**: дюймы.

**Предпочтительными единицами для использования являются dp**. Это связано с тем, что мир мобильных устройств на Android сильно фрагментирован в плане разрешения и размеров экрана. И чем больше плотность пикселей на дюйм, тем соответственно больше пикселей нам будет доступно:

![Measure units 01](./img/measure_units_01.jpg)

Используя же стандартные физические пиксели, мы можем столкнуться с проблемой, что размеры элементов также будут сильно варьироваться в зависимости от плотности пикселей устройства. Например, возьмем 3 устройства с различными характеристиками экрана Nexus 4, Nexus 5X и Nexus 6P и выведем на экран квадрат размером 300px на 300px:

![Measure units 02](./img/measure_units_02.jpg)

В одном случае квадрат по ширине будет занимать 40%, в другом — треть ширины, в третьем — 20%.

Теперь также возьмем квадрат со сторонами 300х300, но теперь вместо физических пикселей используем единицы dp:

![Measure units 03](./img/measure_units_03.jpg)

Теперь же размеры квадрата на разных устройствах выглядят более консистентно.

Размеры шрифтов рекомендуется указывать в sp.

![Resources 01](./img/resources_01.jpg)

![Resources 02](./img/resources_02.jpg)

![Resources 03](./img/resources_03.jpg)

![Resources 04](./img/resources_04.jpg)

![Resources 05](./img/resources_05.jpg)

![Resources 06](./img/resources_06.jpg)

#### FrameLayout
`FrameLayout` – один из базовых контейнеров в Android, который позволяет размещать элементы интерфейса на экране приложения. Это самый простой контейнер среди всех имеющихся. `FrameLayout` особенно полезен, когда нужно расположить несколько компонентов поверх друг друга, например, для создания слоёв.

`FrameLayout` может показаться негибким и нефункциональным, если рассматривать его изолированно. Однако он имеет свои конкретные сценарии использования, когда он становится хорош в разработке интерфейса:
- **Создание слоёв** – `FrameLayout` идеально подходит для создания слоёв в интерфейсе, где нужно располагать элементы поверх друг друга.
- **Overlay-элементы** – `FrameLayout` часто используется для размещения небольших навигационных элементов, таких как кнопки, на верхней или нижней части экрана. Так они не мешают основному содержимому.
- **Работа с видео и аудио** – `FrameLayout` может быть полезен для создания видеоплееров или аудиоплееров, где контрольные элементы (пауза, воспроизведение, громкость и др.) могут находиться поверх видео или аудио.
- **Простой контейнер для разработки** – в некоторых случаях `FrameLayout` удобен для тестирования и разработки, так как он прост и не вносит дополнительных сложностей в разметку.

![FrameLayout 01](./img/frame_layout_01.jpg)

![FrameLayout 02](./img/frame_layout_02.jpg)

![FrameLayout 03](./img/frame_layout_03.jpg)

![FrameLayout 04](./img/frame_layout_04.jpg)

#### LinearLayout
`LinearLayout` – это один из самых простых макетов (layouts) в Android, который позволяет размещать элементы внутри себя. Делает он это в весьма нехитрой форме – в виде линейной последовательности (поэтому Linear в названии), друг за дружкой. Компоненты внутри `LinearLayout` могут размещаться друг за другом либо горизонтально, либо вертикально.

Этот макет подходит для создания простых интерфейсов. Кроме того, он имеет одну очень классную и жизненно необходимую фишку – веса компонентов.

![LinearLayout 01](./img/linear_layout_01.jpg)

![LinearLayout 02](./img/linear_layout_02.jpg)

![LinearLayout 03](./img/linear_layout_03.jpg)

![LinearLayout 04](./img/linear_layout_04.jpg)

![LinearLayout 05](./img/linear_layout_05.jpg)

![LinearLayout 06](./img/linear_layout_06.jpg)

![LinearLayout 07](./img/linear_layout_07.jpg)

![LinearLayout 08](./img/linear_layout_08.jpg)

#### GridLayout
Компоновка `GridLayout` (сетка) — это относительно новая компоновка, появилась в версии 4.0 (API Level 14). Она использует атрибуты `android:columnCount` и `android`:rowCount для задания количества дочерних элементов соответственно в столбце или в строке сетки. Цель `GridLayout` — позволить дочерним представлениям располагаться в виде сетки. `GridLayout` по существу состоит из ряда невидимых горизонтальных и вертикальных линий сетки, которые служат для разделения представления макета на ряд строк и столбцов, причем каждая пересекающаяся строка и столбец образуют ячейку, которая, в свою очередь, может содержать одно или несколько представлений. Линии сетки называются индексами, которые нумеруются начиная с 0 для линии на переднем крае макета. Нумерация строк и столбцов также начинается с 0, начиная с верхнего левого угла сетки (хотя, как будет показано далее в этой главе, инструмент графического макета считает это позицией 1.

Позиционирование представления внутри ячейки можно определить с помощью настроек гравитации в этом дочернем представлении. Например, гравитацию дочернего представления можно настроить так, чтобы представление отображалось по центру, заполняло всю ячейку или располагалось в определенном углу ячейки, в которой оно находится.

Кроме того, дочернее представление родительского элемента `GridLayout` также можно настроить для охвата нескольких строк и столбцов с помощью свойств `rowSpan` и `columnsSpan` дочернего элемента.

Еще один полезный класс, который можно использовать вместе с `GridLayout`, — это класс `Space`. Это очень простой класс, единственная цель которого — создавать пробелы внутри макетов. В случае класса `GridLayout` представление `Space` можно поместить в любую ячейку, как и любой другой объект представления.

Помимо использования класса `Space` для создания пробелов, расстоянием между представлениями в ячейках можно управлять с помощью различных свойств макета полей (сверху, снизу, слева и справа) каждого дочернего элемента.

![GridLayout 01](./img/grid_layout_01.jpg)

![GridLayout 02](./img/grid_layout_02.jpg)

![GridLayout 03](./img/grid_layout_03.jpg)

![GridLayout 04](./img/grid_layout_04.jpg)

![GridLayout 05](./img/grid_layout_05.jpg)

![GridLayout 06](./img/grid_layout_06.jpg)

![GridLayout 07](./img/grid_layout_07.jpg)

![GridLayout 08](./img/grid_layout_08.jpg)

![GridLayout 09](./img/grid_layout_09.jpg)

![GridLayout 10](./img/grid_layout_10.jpg)

**Задание**: Используя известные вам компоновщики создать макет клавиатуры максимально приближенный к картинке.

![Calculator layout](./img/calculator_layout.jpg)

## 20 ПРАКТИКА по теме "Основы XML-разметки пользовательского интерфейса. FrameLayout, LinerLayout, GridLayout"
[67cec6445040133e8429f165](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-20)

### Разметка клавиатуры
[688291fc63e4ad8e0adf416f](https://e-learn.petrocollege.ru/mod/assign/view.php?id=345178)

Используя известные вам компоновщики создать макет клавиатуры максимально приближенный к картинке.

![Calculator layout](./img/calculator_layout.jpg)

## 21 02 Компоновщики RelativeLayout и ConstraintLayout
[67cec6625040133e8429f166](https://e-learn.petrocollege.ru/course/view.php?id=7179#section-21)

### ЛЕКЦИЯ - 02
[6883b73563e4ad8e0adf4190](https://e-learn.petrocollege.ru/mod/url/view.php?id=345179)

https://wywiwyg.ru/learn_kotlin/MAD/second_semester/lecture-02/?page=1

#### RelativeLayout
Исходя из названия, `RelativeLayout` (рус. относительный макет или если перефразировать – макет с относительным расположением элементов) может располагать элементы относительно друг друга. У его вложенных элементов есть ряд параметров для указания зависимостей относительно остальных элементов или же самого `RelaveLayout`.

Элементы внутри `RelativeLayout` имеют свойства, отвечающие за их расположение по вертикали и горизонтали. По умолчанию горизонтальное свойство расположения прижато к левому краю `RelativeLayout`, а вертикальное — к верхнему. Получается по умолчанию расположение элементов зависят от верхнего и левого края родительского контейнера `RelativeLayout`. Часто такое зависящее от чего-то расположение для удобства называют зависимостью. Например, установить для текста зависимость снизу от кнопки и справа от родительского контейнера. Если вы не укажете ни одной зависимости, то все элементы будут располагаться один над одним в верхнем левом углу. Причём элемент, который будет ниже всего в xml файле будет находиться поверх остальных.

Использование `RelativeLayout` позволяет увеличить производительность приложения, так как мы получаем «плоский» интерфейс (без вложений).

![RelativeLayout 01](./img/relative_layout_01.jpg)

![RelativeLayout 02](./img/relative_layout_02.jpg)

![RelativeLayout 03](./img/relative_layout_03.jpg)

![RelativeLayout 04](./img/relative_layout_04.jpg)

![RelativeLayout 05](./img/relative_layout_05.jpg)

![RelativeLayout 06](./img/relative_layout_06.jpg)

![RelativeLayout 07](./img/relative_layout_07.jpg)

![RelativeLayout 08](./img/relative_layout_08.jpg)

![RelativeLayout 09](./img/relative_layout_09.jpg)

![RelativeLayout 10](./img/relative_layout_10.jpg)

![RelativeLayout 11](./img/relative_layout_11.jpg)

![RelativeLayout 12](./img/relative_layout_12.jpg)

#### ConstraintLayout
Как и все другие макеты, `ConstraintLayout` управляет позиционированием и размером содержащихся в нем визуальных компонентов (также называемых виджетами). Это делается на основе ограничений соединений, установленных для каждого дочернего виджета.

Чтобы полностью понять и использовать `ConstraintLayout`, важно понять следующие ключевые понятия:
- Ограничения
- Поля
- Противоположные ограничения
- Смещение ограничений
- Цепи
- Стили цепочек
- Методические рекомендации
- Группы
- Барьеры
- Поток

##### Преимущества ConstraintLayout
`ConstraintLayout` обеспечивает уровень гибкости, который позволяет реализовать многие функции старых макетов с помощью одного экземпляра макета, где раньше было необходимо вкладывать несколько макетов. Это позволяет избежать проблем, присущих вложению макетов, позволяя разрабатывать так называемые «плоские» или «поверхностные» иерархии макетов, что приводит как к менее сложным макетам, так и к повышению производительности рендеринга пользовательского интерфейса во время выполнения. `ConstraintLayout` также был реализован для удовлетворения широкого спектра размеров экрана устройств Android, доступных сегодня. Гибкость `ConstraintLayout` упрощает разработку пользовательских интерфейсов, которые реагируют и адаптируются к устройству, на котором работает приложение.

##### Создание ConstraintLayout

![ConstraintLayout 01](./img/constraint_layout_01.jpg)

![ConstraintLayout 02](./img/constraint_layout_02.jpg)

![ConstraintLayout 03](./img/constraint_layout_03.jpg)

![ConstraintLayout 04](./img/constraint_layout_04.jpg)

![ConstraintLayout 05](./img/constraint_layout_05.jpg)

![ConstraintLayout 06](./img/constraint_layout_06.jpg)

![ConstraintLayout 07](./img/constraint_layout_07.jpg)

![ConstraintLayout 08](./img/constraint_layout_08.jpg)

![ConstraintLayout 09](./img/constraint_layout_09.jpg)

![ConstraintLayout 10](./img/constraint_layout_10.jpg)

![ConstraintLayout 11](./img/constraint_layout_11.jpg)

![ConstraintLayout 12](./img/constraint_layout_12.jpg)

![ConstraintLayout 13](./img/constraint_layout_13.jpg)

![ConstraintLayout 14](./img/constraint_layout_14.jpg)

![ConstraintLayout 15](./img/constraint_layout_15.jpg)

![ConstraintLayout 16](./img/constraint_layout_16.jpg)

![ConstraintLayout 17](./img/constraint_layout_17.jpg)

![ConstraintLayout 18](./img/constraint_layout_18.jpg)

![ConstraintLayout 19](./img/constraint_layout_19.jpg)

![ConstraintLayout 20](./img/constraint_layout_20.jpg)

![ConstraintLayout 21](./img/constraint_layout_21.jpg)

![ConstraintLayout 22](./img/constraint_layout_22.jpg)

![ConstraintLayout 23](./img/constraint_layout_23.jpg)

![ConstraintLayout 24](./img/constraint_layout_24.jpg)

![ConstraintLayout 25](./img/constraint_layout_25.jpg)

![ConstraintLayout 26](./img/constraint_layout_26.jpg)

![ConstraintLayout 27](./img/constraint_layout_27.jpg)

![ConstraintLayout 28](./img/constraint_layout_28.jpg)

![ConstraintLayout 29](./img/constraint_layout_29.jpg)

![ConstraintLayout 30](./img/constraint_layout_30.jpg)

![ConstraintLayout 31](./img/constraint_layout_31.jpg)

![ConstraintLayout 32](./img/constraint_layout_32.jpg)

![ConstraintLayout 33](./img/constraint_layout_33.jpg)

![ConstraintLayout 34](./img/constraint_layout_34.jpg)

![ConstraintLayout 35](./img/constraint_layout_35.jpg)

![ConstraintLayout 36](./img/constraint_layout_36.jpg)

![ConstraintLayout 37](./img/constraint_layout_37.jpg)

![ConstraintLayout 38](./img/constraint_layout_38.jpg)

![ConstraintLayout 39](./img/constraint_layout_39.jpg)

![ConstraintLayout 40](./img/constraint_layout_40.jpg)

![ConstraintLayout 41](./img/constraint_layout_41.jpg)

![ConstraintLayout 42](./img/constraint_layout_42.jpg)

![ConstraintLayout 43](./img/constraint_layout_43.jpg)

#### Задания
Создать один из двух макетов с использованием изученных компоновщиков.

![Card Layouts](./img/card_layouts.jpg)

Создать один из трех макетов с использованием изученных компоновщиков.

![Coin Market App Layouts](./img/coin_market_app_layouts.jpg)
